<!-- It's totally free for personal non-commercial use. Please enjoy. -->
<!-- It's not allowed to use this commercially and/or by/for any business or corporation. -->
<!-- It's not allowed to use this in your product or project without my agreement. -->
<!-- Read more at github page mentioned above -->
<html id='html'>
<head>
<!--			"vue": 		"https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js"-->
<!--			"vue": 		"/vue.prod.js" -->
<script type="importmap">
	{
		"imports": {
			"vue": 		"https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js"
		}
	}
</script>
</head>
<body style="background: black" id='body'>
	<div id="app" ><chat /></div>

<div class='tmpl' style='display:none'>
	<div id='tmplChat'>
		<div id='chatC'><!--:style='{backgroundImage: `url(${this.config.bgImg.v})`}'-->
			<table id='chat' border=1 height='100%'>
				<tr>
					<td colspan='3' id='heading'><a href='https://www.github.com/drazdra/ollama-chats' target='new' class='nobg'>Ollama-chats (v{{config.version.v}})</a></td>
				</tr>
				<template v-if='inited==2'>
					<tr>
						<td class='center'>
							<div class='nobg'>
								Loading..<br><br>
								<template v-if='this.modelsLoading.inited==2'>
									Models loaded {{ this.modelsLoading.done }} / {{ this.modelsLoading.total }}
								</template>
							</div>
						</td>
					</tr>
				</template>
				<template v-else-if='cardSave.loading'>
					<tr>
						<td class='center'>
							<div class='nobg'>
								Loading card..<br><br>
							</div>
						</td>
					</tr>
				</template>
				<template v-else-if='this.connection==1'>
					<tr>
						<td colspan='3'  id='nicks'>
							<table width='100%' cellspacing=0 cellpadding=0>
								<tr v-if='config.storiesUI.v'>
									<td class='' colspan='2' title="These are presets of users. They are here simply to let you save and quickly access groups of users that talk together. For example, characters in 2 different rooms. Or character talking on a phone to somebody when others do not hear it, etc.">
										<span class='nobgt'>
											<template v-for='(g,gi) in groups'>
												<span @click='groupCh(gi)' :class='"groups "+(gi==group&&"groupSel")'>{{g.n}}</span> <template v-if='gi!=0'>(<span @click='groupDel(gi)' class='del'>x</span>)</template> :
											</template>
											<input placeholder='add new' v-model='groupAddN'/> <span class='lnk' @click='groupAdd(this.groupAddN,[]);groupAddN=""'>add</span>
										</span>
										<br><br>
									</td>
								</tr>
								<tr>
									<td class='nicksListTitle'>
										<div class='understroke nobgt right nobreak'>Users ({{groups[this.group].an['u']}}):</div>
									</td>
									<td width='100%'>
										<user-list :t='"u"' :group='group' :groups='groups' :nicks='nicks'></users-list>
									</td>
									<td><nickadd t='u' :group='group' :groups='groups' :nicks='nicks' :amount-nicks='amountNicks'/></td>
								</tr>
								<tr>
									<td class='right nicksListTitle'>
										<span class='understroke nobgt rightf nobreak'>AIs ({{groups[this.group].an['a']}}):</span>
									</td>
									<td>
										<user-list :t='"a"' :group='group' :groups='groups' :nicks='nicks'></users-list>
									</td>
									<td>
										<nickadd t='a' :group='group' :groups='groups' :nicks='nicks' :amount-nicks='amountNicks'/><br>
									</td>
								</tr>
							</table>
						</td>
					</tr>
					<tr id='chatLog'>
						<td colspan='3'>
							<table width='100%'>
								<tbody id='chatLogC' :style='{display:(this.config.chatHeight.v!=""?"block":"table"),maxHeight: this.config.chatHeight.v+"px"}'>
									<template v-for="(i,index) in turns">
										<chat-row
											v-if='this.turn>0&&index<=turn&&i.branch>=0&&!hideMsg(...tbma(index))'
											:turn			='index'
											:turn-end	='turn'
											:branch		='i.branch'
											:fontSize	='this.config.msgFontSize.v'
											:trinity	='this.config.trinity.v'
											:u				='userS("u")'
											:ai				='this.userS("a")'
											:stories	='this.config.storiesUI.v'
											:nicks		='this.nicks'
											:group		='this.group'
											:tokens		='this.config.tokensCount.v'
											:ctx			='this.settings.options["num_ctx"].v'
											:branch-moving='this.branchMoving'
										></chat-row>
									</template>
									<tr><td id='chatLogEnd'></td></tr>
								</tbody>
							</table>
						</td>
					</tr>
					<tr v-if='this.turnNotLast(turn)'>
						<td class='nobg'></td>
						<td class='lnk nobg'>
							<div class='center' @click='this.turnDown(0)'>
								There is more in the chat below, totally: {{turnLast(turn)-turn}} message(s), press down or click here to see.
							</div>
							<div class='center' @click='this.turnDown(1)'>
								Press shift+down or click here to show all the messages below
							</div>
						</td>
						<td class='nobg'></td>
					</tr>
					<tr v-if='config.storiesUI.v&&turns.length>1' id='contextFilterRow'>
						<td></td>
						<td id='contextFilter' colspan='2' title='Filters the messages of context history by who was meant to read them. You can do it to see either what Ai will see or just the history. "Every1" shows all the messages ever sent to chat. If you have both characters selected, you get one more checkbox that can be "AND" / "OR". "And" means you see only messages visible for BOTH selected characters - that is you see everything they BOTH meant to see. If one of them did not see something, you do not see it in this mode. "OR", on other hand, means you see ALL of the messages visible by any of these characters (in that some message of yours you see might not not be visible Ai, and some of the messages sent by Ai might not be meant for you to see)'>
							<span class='nobg'>
								<template v-if='!context[0]'>
									<span v-if="userS('u')!=null"><input type='checkbox' v-model='context[2]'><nick :id='userS("u")' :name='nicks[userS("u")].n'></nick></span>
									<template v-if='context[2]&&context[1]'>
										<span><input type='checkbox' v-model='context[3]'>{{context[3]?"and":"or"}}</span>
									</template>
									<span v-if="userS('a')!=null"><input type='checkbox' v-model='context[1]'><nick :id='userS("a")' :name='nicks[userS("a")].n'></nick></span>
								</template>
								<span><input type='checkbox' v-model='context[0]'>Every1</span>
							</span>
						</td>
						<td></td>
					</tr>
					<tr v-show='pState["control"]'>
						<td colspan=3 class='center'>
							<br>
							<talkers t='u' :config='config' :group='group' :groups='groups' :nicks='nicks'></talkers>
							<textarea rows='5' tabindex='5300' id='prompt' placeholder='Prompt'
								:disabled='userS("u")==null||userS("a")==null'
								v-model="prompt" 
									@keydown.enter='send($event,1,null)'
								:style='"font-size:"+config.taFontSize.v'
							></textarea>
							<table id='talkersB'>
								<tr>
									<td class='nobgb' width='50'>
										<div class='left leftf' id='imgAdd'>
											<fields n='+Image' id='img' :i='{name:"+Image",f:"file",d:"Upload an image to the prompt"}' :n-show='false'></fields>
										</div>
									</td>
									<td>
										<talkers t='a' :config='config' :group='group' :groups='groups' :nicks='nicks'></talkers>
									</td>
								</tr>
							</table>
							<div class='left' id='imgAddList'>
								<template v-for='(img,ind) in this.imgs'>
									<span class='chatLogImg nobg'>
										<img title='An image to attach to the prompt, click to remove.' @click='this.imgs.splice(ind,1)' class='imgPrompt nobg' :src='`data:image/gif;base64,${img}`'>
									</span>
								</template>
							</div>
							<br>
							<br><br>
							<table id='sysinstr'>
								<tbody>
								<tr>
									<td :width='(pState["sys"]?(pState["instr"]?"50%":"100%"):"0%")'>
										<transition name="ta" mode="out-in">
											<div :key='pState["sys"]' v-if='userS("a")!=null'>
												<div v-show='pState["sys"]' id='sysTitle'>
													<span class='nobgt'>System Prompt of <nick :id='userS("a")' :name='nicks[userS("a")].n'/></span>
												</div>
												<textarea 
													v-show='pState["sys"]'
													id='sys' 
													rows=10 
													v-model='this.nicks[userS("a")].system'
													:placeholder='`Edit this to override the system prompt of (${userS("a")}) ${nicks[userS("a")].n} with this text. Empty means the system uses default system prompt (from modelfile)`'
													:style='"font-size:"+config.taFontSize.v'
												></textarea>
											</div>
										</transition>
									</td>
									<td :width='(pState["instr"]?(pState["sys"]?"50%":"100%"):"0%")'>
										<transition name="ta" mode="out-in">
											<div :key='pState["instr"]' v-if='userS("a")!=null'>
												<div v-show='pState["instr"]' id='instTitle'>
													<span class='nobgt'>Instruction of <nick :id='userS("a")' :name='nicks[userS("a")].n'/></span>
												</div><br>
												<textarea 
													v-show='pState["instr"]'
													id='instr'
													rows=10 
													v-model='this.nicks[userS("a")].instr'
													:placeholder='`You can specify special reminder here for (${userS("a")}) ${nicks[userS("a")].n} on the situation. It will be injected as a last message belonging to the AI, but will not stay in the chat log. I use things like: "I am thinking about doing .., as i am .., i see that.. i feel that.. etc`'
													:style='"font-size:"+config.taFontSize.v'
												></textarea>
											</div>
										</transition>
									</td>
								</tr>
								</tbody>
							</table>

							<div id='ragC' v-show='pState["ragG"]||pState["ragU"]'>
								<br><br>
								<template v-if='this.config.rag.v'>
									<template v-if='rag.err!=null'>
										<div class='center red'><span class='nobg'><rag-err :rag='rag'></rag-err></span></div><br>
									</template>
									<table v-if='userS("a")!=null'>
										<tr>
											<td>
												<div class='nobg' id='remembered'>
													<template v-if='rag[userS("a")].last.length||rag["g"].last.length'>
														<p class='green understroke'>Things {{nicks[userS("a")].n}} remembers at last reply:</p>
														<template v-for='(r,id) in rag["g"].last'>
															<p class='justify'>Knowledge {{id+1}}: {{r.t}} (<span :title='r.cos'>Similarity: {{this.rnd(r.cos,3)}}</span>)</p>
														</template>
														<template v-for='(r,id) in rag[userS("a")].last'>
															<p class='justify'>Memories {{id+1}}: {{r.t}} (<span :title='r.cos'>Similarity: {{this.rnd(r.cos,3)}}</span>)</p>
														</template>
													</template>
													<template v-else>
														<span class='small'>Nothing was remembered last time</span>
													</template>
												</div>
											</td>
										</tr>
									</table>
									<br>
									<transition name="ta" mode="out-in">
										<table id='ragU' v-show='pState["ragU"]' v-if='userS("a")!=null'>
											<tr>
												<td>
													<div id='ragTitle'>
														<span class='nobgt'>Memories (rag) of <nick :id='userS("a")' :name='nicks[userS("a")].n'/>:</span>
													</div>
													<textarea
														id='rag'
														rows=7
														:disabled='this.workingRag||this.working'
														v-model='this.rag[userS("a")].t'
														@blur='ragU(userS("a"))'
														:placeholder='"Edit this to store ("+userS("a")+") "+nicks[userS("a")].n+" memories (rag). Only "+nicks[userS("a")].n+" can access these. You can use any format but i recommend to split it into small paragraphs, every separate paragraph should explicitly mention all the relevant subjects it speaks of, because every paragraph is searched separately. For example:\nMari has the following preferences in reading: Mari reads only sci-fi and hates manga. Favorite authors of Mari are Bubu Dada nad Dudu Baba.\nWhen Mari sees a mouse Mari screams and jumps on any man next her.\nSame about the world, environment, anything. Data in this field is searched by semantic similarity to the prompt."'
														:style='"font-size:"+config.taFontSize.v'
													></textarea><br>
													<div @click='pToggle("ragMemGen")' class='nobgb lnk rightf'>Memories generator</div>
													<div class='left small'>
														&nbsp;
														<rag-status :rag='rag' :id='userS("a")'></rag-status>
													</div>
													<div id='memGen'>
													<br>
													<transition name="ta" mode="out-in" >
														<div class='nobg' v-if='pState["ragMemGen"]' :key='pState["ragMemGen"]'>
															<char-new-mem-sets :char-new='memNew'></char-new-mem-sets>
															<template v-if='memNew.parts.m.length==0'>
																<span class='lnk' @click='memGen4rag(userS("a"))'>Generate</span>
															</template>
															<template v-else>
																<span class='lnk' @click='memGen4rag(userS("a"))'>Re-generate</span>
																: 
																<span class='lnk' @click='memGen2rag(memNew,userS("a"))'>Move to memories</span>
																: <span class='lnk' @click='memGenParsedReset(memNew,0)'>Clear</span>
															</template>
															<div class='rightf' title="When this marked, model will get not just system prompt of the character but also all of the character's 'memories' in its context for new memories generation. This may give a hope to have new memories more consistent with the existing ones.">w. ex. memories: <input type='checkbox' v-model='memNew.parts.wMemories'></div>
															<char-new-mem-parsed :char-new='memNew'></char-new-mem-parsed>
															<template v-if='memNew.working'>
																<template v-if='memNew.parts.tmp.waiting'>..loading..</template>
																<template v-else-if='memNew.working'>..working..</template>
																<textarea disabled=1 v-model='memNew.parts.tmp.content' rows='7'></textarea>
															</template>
															<table class='memparsed'>
																<tr>
																	<td>
																		<char-new-system-edit :char-new='memNew' :p-state='pState' id='0'></char-new-system-edit>
																	</td>
																</tr>
															</table>
														</div>
													</transition>
													</div>
												</td>
											</tr>
										</table>
									</transition>
									<br>
									<transition name="ta" mode="out-in">
										<table id='ragG' v-show='pState["ragG"]'>
											<tr>
												<td>
													<div class='rightf' id='ragTitle'>
														<span class='nobgt'>Public knowledge (rag) of all characters</span>
													</div>
													<textarea
														id='rag'
														rows=7
														:disabled='this.workingRag||this.working'
														v-model='this.rag["g"].t'
														@blur='ragU("g")'
														:placeholder='"Edit this to store global knowledge (rag) of all characters. You can use any format but i recommend to split it into small paragraphs, every separate paragraph should have explicitly mention all the relevant subjects it speaks of, because every paragraph is searched separately. For example:\nCafe where they meet first time for in the city of Kikuku, it was evening and the dragons were dancing in the air.\nTransportation, moving, driving is possible only on donkeys as cars do not exist, cars are just faity tales. If you need to get somewhere, get a donkey.\nSame about the world, environment, anything. Data in this field is searched by semantic similarity to the prompt."'
														:style='"font-size:"+config.taFontSize.v'
													></textarea><br>
													<div class='left small'>
														&nbsp;<span class='nobgb'>
															<rag-status :rag='rag' id='g'></rag-status>
														</span>
													</div>
													<br>
												</td>
											</tr>
										</table>
									</transition>
								</template>
								<template v-else>
									<p class='small nobg center'>Memories (rag) are disabled, please enable in configuration if you wish to use it.</p>
								</template>
								<br>
							</div>
							<div id='setsQ' v-if='config.setsQ.v'>
								<br>
								<template v-for='(g,gind) in configGroups'>
									<template v-for='j of [config,settings.options,settings.req]'>
										<template v-for='(i,ind) of j'>
											<template v-if='i!=null&&i.q===true&&i.g==gind&&!i.hidden'>
												<div style='display:inline-block;'><fields :n='ind' :id='ind' :i='i' n-show='1'/></div>
											</template>
										</template>
									</template>
								</template>
							</div>
							<div v-show='pState["sets"]' align='center'>
								<br>
								<table id='sets' class='nobg'>
									<tr>
										<td colspan='3' class='green heading understroke center'>
											Configuration
										</td>
									</tr>
									<tr>
										<td class='header center'>
											<p class='green right'>Name</p>
										</td>
										<td class='header center'>
											<p class='green'>Value</p>
										</td>
										<td class='header center'><p title='Quick access' class='green'>Quick</p></td>
									</tr>
									<!-- hardcoded settings that are personalized/outside of main ones, too lazy to write templating that would support everything needed. i suppose if needed i can make this "nicks" settings and then it's easy enough.-->
									<tr v-if='userS("a")!=null' class='setsRow'>
										<td class='title' title="Enable this to make the currently active AI to have personal set of settings and configuration. It makes it possible to assign different models per characters, to have different settings like temperature, etc and even different interface style (the latter is totaly useless).">
											<div :class='config.setsDescrShow.v&&"understroke green"'>
												Personal settings for <nick :id='userS("a")' :name='nicks[userS("a")].n'></nick>
											</div>
											<div v-if='config.setsDescrShow.v' class='justify txt'>
												Enable this to make <nick :id='userS("a")' :name='nicks[userS("a")].n'></nick> have personal set of settings and configuration. It makes it possible to assign different models per characters, to have different settings like temperature, etc and even different interface style (the latter is totaly useless).
												Default: false
											</div>
										</td>
										<td class='val'><input type='checkbox' @change='userSetsPerAi(userS("a"))' v-model='nicks[userS("a")].setsDo'></td>
										<td class='setsQ'></td>
										<td v-if='!config.setsDescrShow.v' class='def left'>def: false</td>
									</tr>
									
									<template v-for='(g,gind) in configGroups'>
										<tr>
											<td class='left headerC' colspan='3'>
												<p class='lnk green header' @click='pToggleDo("sets_"+gind)'>{{g.name}}</p>
											</td>
										</tr>
										<template v-for='j in [config,settings["req"],settings["options"]]'>
											<template v-for='(i,ind) in j'>
												<template v-if='i!=null&&i.g==gind&&!i.hidden'>
													<transition name='ta'>
														<template v-if='pState["sets_"+gind]'>
															<tr :id='"sets_"+gind' class='setsRow'>
																<td class='title' :title='i.d'>
																	<div :class='config.setsDescrShow.v&&"green"'>
																	{{i.name?i.name:ind}}
																	</div>
																	<div v-if='config.setsDescrShow.v' class='justify txt pre descr'>
																		{{i.d}}<br>
																		Default: <span>{{i.def===''?"empty":i.def}}</span>
																	</div>
																</td>
																<td class='val'><fields :n='i.name?i.name:ind' :id='ind' :i='i'/></td>
																<td class='setsQ'><input v-if='i.q!==null' type='checkbox' v-model='i.q'/></td>
																<td v-if='!config.setsDescrShow.v' class='def left'><span v-show='(i.def+"")!=""'>def: {{i.def}}</span></td>
															</tr>
														</template>
													</transition>
												</template>
											</template>
										</template>
									</template>
								</table>
							</div>
							<div id='howto' class='nobg' v-if='pState["howto"]'><help></help></div>
							<div v-if='pState["cardSave"]' id='cardSave'>
								<br>
								<div class='nobg'>
									<table class='center'>
										<tr>
											<td colspan='2'><span class='green header center understroke'>Character card saving</span></td>
										</tr>
										<tr>
											<td colspan='2' class='justify'>
												Here you can choose the characters you wish to save to a file. Later you can import them into existing conversation or just share with somebody else if they use my UI.
											</td>
										</tr>
										<tr>
											<td class='right green'>Character</td>
											<td class='green'>Save</td>
										</tr>
										<template v-for='n in this.nicks'>
											<template v-if='!n.del&&n.t!="s"'>
												<tr>
													<td class='right' width='50%'>
														<nick :id='n.id' :name='nicks[n.id].n'/>
													</td>
													<td width='50%'>
														<input class='understroke' type='checkbox' v-model='cardSave.nicks[n.id]'>
													</td>
												</tr>
											</template>
										</template>
									</table><br>
									<div class='center' style='width:90%'>
										<div class='justify'>
											You also may add several messages to start the story.<br><br>
											Select lists in the left column let you choose the message author 
											(from the ones you've selected for saving).
											Text area is the message that will be added on behalf of that user.
											Please specify both for every message or these will not be saved.<br><br>
											On loading these messages will be added as first ones, if the chat log is empty.
											In case if card is loaded when there is some chat log, it will create
											a new branch at the first turn, keeping the existing chat log branch untouched.
											This doesn't support features like trinity and stories and is just plain 
											messages that will be converted into the settings of the person who imports it.
											The reason for that is that using whole features list would pose a lot of 
											question on what to do with the existing settings of the user who loads and
											also it would require a lot of changes to the code while too few would use it.
											Maybe i will do it in the future, tho.
											<br><br>
										</div>
									</div>
									<table class='center' id='msgs'>
										<tr>
											<td class='green center'>Character</td>
											<td class='green center'>Message</td>
											<td class='green center'>Del</td>
										</tr>
										<template v-for='(m,mey) in cardSave.msgs'>
											<tr>
												<td class='nick'>
													<select v-model="m.u">
														<template v-for="(u,uind) in this.nicks">
															<template v-if='!u.del&&cardSave.nicks[u.id]'>
																<option :value='u.id'><nick :id='u.id' :name='u.n'/></option>
															</template>
														</template>
													</select>
												</td>
												<td class='content'>
													<textarea width='100%' rows=7 v-model='m.content'></textarea>
												</td>
												<td class='del'>
													(<span @click='cardSave.msgs.splice(mey,1)' class='del'>x</span>)
												</td>
											</tr>
										</template>
									</table>
									<span class='lnk center' @click='this.cardSaveDo()'>Save</span>
									<br><br>
								</div>
							</div>
							<div v-if='pState["pull"]' id='pull'>
								<br>
								<div class='nobg'>
									<p class='heading understroke green center'>Pull a model</p>
									<br>
									<template v-if='!this.working'>
										<div v-if='!this.models.length'>
											There are no models installed, please install the models in the console
											or install it through this interface. 
										</div>
										To install a model enter your preferred model's name, as it is at 
										<a href='https://ollama.com/library' target='new'>https://ollama.com/library</a>
										and click "pull".<br><br>
										<input @keydown.enter.prevent='this.pull()' v-model='modelPull'/> <span class='lnk' @click='this.pull()'>pull</span>
										<br><br>
										<div v-if='this.connectionErr.length'>
											Error: {{this.connectionErr}}
										</div>
									</template>
									<template v-else>
										Pulling model: {{this.modelPull}}<br><br>
										<template v-for='i in this.mpull'>
											<div>
												{{i.status}} 
												<span v-if='i.total'>
													{{i.done}} / {{i.total}} = {{i.prcnt}}%
												</span>
											</div><br>
										</template>
									</template>
								</div>
							</div>
						</td>
					</tr>
					<tr v-if='pState["charNew"]' id='charNew'>
						<td colspan='3' class='center nobg'>
							<transition name="ta" mode="out-in" :key='pState["charNew"]'>
								<div>
									<div>
										<div class='header understroke green center'>
											Generation of a new character 
												<template v-if='charNew.parts.auto.working'>
													{{charNew.parts.auto.at}} of {{charNew.parts.auto.amount}}
													(<span class='del' @click='this.charNew.cancel=this.cancel=0'>cancel</span>)
												</template>
										</div>
									</div>
									
									<transition name="ta" mode="out-in" :key='charNew.stepShow'>
										<table width='100%'>
											<tr>
												<td colspan='2'>
													<template v-if='charNew.step>0'>
														<table id='charNewStep'>
															<tr>
																<td>
																	<div class='lnk header' v-if='charNew.stepShow>0' @click='charNew.stepShow--'>Back to step {{charNew.stepShow}}</div>
																</td>
																<td>
																	<div v-if='charNew.stepShow>0' class='header understroke green center'>Step {{charNew.stepShow+1}}</div>
																</td>
																<td>
																	<div class='lnk header rightf' v-if='charNew.step>charNew.stepShow' @click='charNew.stepShow++'>Back to step {{charNew.stepShow+2}}</div>
																</td>
															</tr>
														</table>
													</template>
												</td>
											</tr>
											<tr>
												<td colspan='2'>
													
												</td>
											</tr>
											<template v-if='charNew.stepShow==0'>
												<tr>
													<td colspan='2' style='width:100%' class='center'>
														<div>
															<span class='lnk' @click='charCreate(0)'>Click to create step by step</span> or 
															<span class='lnk' @click='charCreateAuto()'>Click to create in 1 click</span> <input class='understroke' characters style='width: 21px' v-model='charNew.parts.auto.amount'> characters
															<div class='del rightf' @click='charCreateReset(charNew,1)'>Click to reset</div>
															</div>
														<p>
															Here you can generate a new character. Refer to help section at the bottom for instruction.
															To start you can predefine any of the parameters below or leave all empty and just start.
															The input to the right from parameters is the amount of character memories to generate about
															that "topic". You can leave it empty.<br>
															Btw, you can even remove any of these parameters if they don't fit your idea and 
															add any custom parameters.
														</p>
													</td>
												</tr>
												<tr>
													<td colspan='2' class='center'>
														<div style='max-width:90%;' class='center'>
															<char-new-parsed-params :char-new='charNew'></char-new-parsed-params>
															<br>
															<char-new-mem-sets :char-new='charNew'></char-new-mem-sets>
															<br><br>
															<char-new-system-edit :char-new='charNew' :p-state='pState' id='0'></char-new-system-edit>
														</div>
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==1'>
												<tr>
													<td class='center'>
														Below are values recognized in the content generated by the model.
														You can edit it before doing next step or just re-create these. 
													</td>
													<td class='center'>
														<template v-if='charNew.step==1'>
															<div class='center green'>
																<template v-if='charNew.parts.tmp.waiting'>..loading..</template>
																<template v-else-if='this.charNew.working'>..working..</template>
															</div>
														</template>
														<template v-if='!charNew.working'>
															<template v-if='charNew.step>charNew.stepShow'>
																<div class='center lnk bold' @click='charNew.stepShow++'>Move to next step</div>
																<br>
															</template>
															<div class='center lnk' @click='charCreate(0)'>Click here to re-create</div>
														</template>
													</td>
												</tr>
												<tr>
													<td>
														<char-new-parsed-params :char-new='charNew'></char-new-parsed-params>
														<br><br>
														<char-new-system-edit :char-new='charNew' :p-state='pState' id='0'></char-new-system-edit>
													</td>
													<td>
														<textarea v-show='charNew.working&&charNew.step==1' :disabled="1" style='width: 100%;height:100%;' v-model='charNew.parts.tmp.content'></textarea>
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==2'>
												<tr>
													<td class='center green'>
														Below are values recognized in the content generated by the model. To edit these move to the previous step.
													</td>
													<td class='center'>
														<template v-if='charNew.step==2'>
															<div class='center green'>
																<template v-if='charNew.parts.tmp.waiting'>..loading..</template>
																<template v-else-if='this.charNew.working'>..working..</template>
															</div>
														</template>
														<template v-if='!charNew.working'>
															<template v-if='charNew.parts.sys.length'>
																<div class='lnk center middle bold' @click='charNew.stepShow++'>Move to next step</div>
																<br>
															</template>
															<div class='lnk center middle' @click='charCreate(1)'>Click here to do rephrasing of generating content.</div>
															<br>
															You can edit it manually too, of course.
														</template>
													</td>
												</tr>
												<tr>
													<td>
														<char-new-parsed-params :char-new='charNew'></char-new-parsed-params>
														<br><br>
														<char-new-system-edit :char-new='charNew' :p-state='pState' id='1'></char-new-system-edit>
													</td>
													<td>
														<template v-if='charNew.working==1'>
															<textarea :disabled='charNew.working' style='width:100%;height:100%' v-model='charNew.parts.tmp.content'></textarea>
														</template>
														<template v-else>
															<textarea style='width:100%;height:100%' v-model='charNew.parts.sys'></textarea>
														</template
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==3'>
												<tr>
													<td class='center green'>
														You can edit the memories below after the generation.
													</td>
													<td>
														<template v-if='charNew.step==3'>
															<div class='center green'>
																<template v-if='charNew.parts.tmp.waiting'>..loading..</template>
																<template v-else-if='charNew.working'>..working..</template>
															</div>
														</template>
														<template v-if='!charNew.working'>
															<template v-if='charNew.parts.m.length'>
																<div class='lnk center middle bold' @click='charNew.stepShow++'>Move to next step</div>
																<br>
															</template>
															<div class='center middle'>
																<span class='lnk' @click='charCreate(2)'>Click here to start (re)generating memories</span>
																or
																<span class='lnk' @click='charNew.stepShow=4'>Skip this step</span>
															</div>
														</template>
													</td>
												</tr>
												<tr>
													<td class='center'>
														<div><char-new-mem-sets :char-new='charNew'></char-new-mem-sets></div>
														<char-new-mem-parsed :char-new='charNew'></char-new-mem-parsed>
														<br><br>
														<char-new-system-edit :char-new='charNew' :p-state='pState' id='2'></char-new-system-edit>
													</td>
													<td>
														<textarea v-show='charNew.working&&charNew.step==3' :disabled='charNew.working==1' style='width:100%; height:100%' v-model='charNew.parts.tmp.content'></textarea>
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==4'>
												<tr>
													<td class='center green'>
														Remaining steps to complete:
													</td>
													<td>
														<div class='center'><span class='lnk bold' @click='charCreate(3)'>Click here</span> to make new character with the generated data</div>
													</td>
												</tr>
												<tr>
													<td>
														<table width='100%'>
															<tr>
																<td class='green'>Name <span class='small'>(if you change this, update the system prompt manually)</span>:<br>
																	<textarea rows=1 v-model='charNew.parts.name.c'></textarea>
																</td>
															</tr>
															<tr>
																<td class='green center'>System prompt, these 3 parts will be united:<br>
																	<textarea v-model='charNew.parts.sysPre' rows='4'></textarea>
																	+
																	<textarea v-model='charNew.parts.sysKq' rows='4'></textarea>
																	+
																	<textarea v-model='charNew.parts.sys' rows='7'></textarea>
																</td>
															</tr>
															<tr>
																<td>
																	<char-new-mem-parsed :char-new='charNew'></char-new-mem-parsed>
																</td>
															</tr>
														</table>
													</td>
													<td>
														<br>
														<table width='100%'>
															<tr>
																<td style='width:90%'>Creating new character:</td>
																<td style='width:10%'>{{charNew.parts.copy.userAdd?("done, user: "+charNew.parts.copy.userAdd):".."}}</td>
															</tr>
															<tr>
																<td>Adding system prompt:</td>
																<td>{{charNew.parts.copy.sysPrompt?"done":".."}}</td>
															</tr>
															<tr>
																<td>Adding character to the group:</td>
																<td>{{charNew.parts.copy.add2group?"done":".."}}</td>
															</tr>
															<tr>
																<td>Selecting character as active:</td>
																<td>{{charNew.parts.copy.select?"done":".."}}</td>
															</tr>
															<tr>
																<td>Adding memories and converting these to embeddings:</td>
																<td>
																	<template v-if='!charNew.parts.copy.embedding'>
																		..
																	</template>
																	<template v-else>
																		<rag-status :rag='rag' :id='charNew.parts.u'></rag-status>
																	</template>
																</td>
															</tr>
														</table>
													
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==5'>
												<tr>
													<td colspan='2'>
														<div class='center green'>
															You have finished creating a new character.
														</div>
														<br><br>
														<div class='center'>
															<span class='lnk' @click='pToggle("charNew")'>You can close this</span>
															<br><br>or<br><br>
															<span class='lnk' @click='charNew.stepShow=0'>Create one more character with the same presets</span>.
															<br><br>or<br><br>
															<span class='lnk' @click='charCreateReset(charNew,1)'>Create one more character from scratch</span>.
														</div>
													</td>
												</tr>
											</template>
										</table>
									</transition>
									<br><br>
									<div id='charNewHelp'>
										<div class='green understroke right header'>Help</div>
										<ol>
											<template v-if='charNew.stepShow==0'>
												<li>Set all the desired predefined characteristics above or just leave them empty</li>
												<li>
													Input field to the right from each characteristic is the amount of memories
													you wish to be generated about it at a later stage. In other words,
													if you put 3 here, you will
													get 3 autogenerated memories about this parameter later. Just as
													it goes with predefined topics for memories at the bottom.
												</li>
												<li>
													You can proceed by steps, controlling everything, or just click
													an automatic creation in 1-click of any amount of new characters.
													The choice is yours.
												</li>
												<li>
													If you wish to control every step, click on "click to create by steps" 
													at the top, it will use your predefined 
													parameters to start generating the rest. 
												</li>
												<li>
													If you choose to create everything in one click, it will
													use the predefined values and create as many characters as
													you have requested. The predefined values will be used for all of the
													generations, everything else is re-generated.
												</li>
												<li>
													Please note, if you move back and forth between the steps,
													data is retained. But if you re-generate things, at, say, step 2,
													then everything in the next steps is erased to keep things
													consistent. If you just edit things, data in the next
													steps is not erased, because i believe you know what you do
													with manual editing.
												</li>
											</template>
											<template v-if='charNew.stepShow==1'>
												<li>
													Here you see the values generated for your new character, 
													if you wish, you can correct any of these. It's a good idea to check
													them for consistency.
												</li>
												<li>
													If the reply was 
													bad and generated parameters were not recognized, 
													it will try to repeat the process multiple times,
													regenerating only the absent parameters. 
													You can cancel it with "Esc" button on your keyboard.
												</li>
												<li>
													If you don't like the values, you can click on a link to re-create these.
												</li>
												<li>
													When done, click on the link to move to the next step.
												</li>
											</template>
											<template v-if='charNew.stepShow==2'>
												<li>
													Click on a link in the upper right column to proceed 
													with rephrasing of the generated character parameters into a more human/llm readable form. 
													It adds more life to the system prompt.
												</li>
												<li>
													It may automatically try to do it several times if the model doesn't generate it properly. You can cancel the process with "Esc" button on the keyboard.
												</li>
												<li>
													Once ready, you can edit the resulting system prompt right where it is. The edits
													you make are used in the final character settings.
												</li>
												<li>
													Once you are satisfied click to proceed to the next step.
												</li>
											</template>
											<template v-if='charNew.stepShow==3'>
												<li>
													This step is for creating various memories of the new character.
												</li>
												<li>
													If you don't use RAG and don't want to generate memories,
													you can skip this step by clicking the appropriate link at the 
													top of the right column. 
												</li>
												<li>
													If you wish to generate specific memories, just
													add the desired topics in the left column. You can
													define any amount of topics for model to hallucinate about and
													set any desired amount of these to generate (0-9999). 
													Please note that all of the generated memories remain
													in the context of a model, to make them consistent, so
													requesting a lot of these may overfill your context window
													size (num_ctx).
												</li>
												<li>
													It's a good idea to generate memories with desired
													reactions to the situations you expect. For example: "i feel irritated and i scream",
													"i saw a flower and i cried", "talking to the walls is a sign of a clever person", etc.
													If you have only a few memories, these will almost always emerge, 
													thus somewhat limiting the variativity of character's replies. 
													It means that in general, having a few memories might be a bad idea. 
													However, i often use it as i may just turn rag on and off when needed.
												</li>
												<li>
													Once generated, check the results to ensure everything is consistent.
													You can edit the memories in place.
												</li>
												<li>
													Please note, a click on generation will delete all existing memories.
												</li>
												<li>
													When ready, proceed to the next step.
												</li>
											</template>
											<template v-if='charNew.stepShow==4'>
												<li>
													This uses all the generated data
													and creates a new character.
												</li>
												<li>
													If you didn't have a field with the "name" data, then
													system doesn't know how to call your character. You might
													want to enter the name manually then. Also, be sure to 
													edit the system prompt manually after that.
												</li>
												<li>Enjoy!</li>
											</template>
										</ol>
									</div>
								</div>
							</transition>
						</td>
					</tr>
					<tr v-if='pState["opt"]' id='opt'>
						<td colspan='3' class='center nobg'>
							<opt :branch='branchac':config='config' :settings='settings' :opt='opt' :p-state='pState'></opt>
						</td>
					</tr>
					<tr>
						<td colspan=3 class='center' id='menu'>
							<br>
							<table v-if='pState["menu"]'>
								<tr>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("howto")' title='Help'><menun k='F1' t='Help'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='save()' title='Save state'><menun k='F2' t='Save'/></span></td>
									<td></td>
									<td><span class='nobgt' title='Load old state'><input id='load' type='file' @change='load()'/><label class='lnk' for="load" id="loadlabel"><menun k='F3' t='Load'></label></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("sys")' title='System prompt'><menun k='F4' t='Sys.pr.'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("instr")' title='Instruction'><menun k='F5' t='Instr'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='list()' title='Reload models'><menun k='F6' t='Rld.mdls'/> </span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("pull")' title='Pull a model'><menun k='F7' t='Pull'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='this.prune()' title='Prune'><menun k='F8' t='Prune'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("sets")' title='Configuration and settings'><menun k='F9' t='Config'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='quit()' title='Quit'><menun k='F10' t='Quit'/></span></td>
								</tr>
								<tr>
									<td><span class='nobgt'>Shift+</span>&nbsp;</td>
									<td><span class='gray nobgt'><menun k='F1' t='None'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='cardSaveToggle()' title='Save characters card'><menun k='F2' t='Sv ch.'/></span></td>
									<td></td>
									<td><span class='nobgt' title='Load characters card'><input id='loadcard' type='file' @change='loadFile("card")'/><label class='lnk' for="loadcard" id="loadLabelCard"><menun k='F3' t='Ld.ch.'/></label></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("ragG")' title='Public knowledge'><menun k='F4' t='P.knlg'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("ragU")' title="Character's memory"><menun k='F5' t='Mem'/></span></td>
									<td></td>
									<td><span class='gray nobgt'><menun k='F6' t='None'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("charNew")' title="Generate a new character"><menun k='F7' t='Gen.ch.'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='clear()' title='Clear'><menun k='F8' t='Clear'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='optToggle()' title='Try different combinations of parameters automatically'><menun k='F9' t='Tune'/></span></td>
									<td></td>
									<td><span class='gray nobgt'><menun k='F10' t='None'/></span></td>
								</tr>
							</table>
						</td>
					</tr>
				</template>
				<template v-else>
					<tr>
						<td class='center nobg'>
							Ollama url<br>
							<input v-model='this.config.url.v' class='understroke'/>
							&nbsp;<span class='lnk' @click='this.config.url.v=this.def.configGlobal.url.v'>reset</span>
							<br><br>
							<template v-if='this.connectionErr.length'>
								<br>
								<span class='lnk' @click='this.urlTest()'>Re-try</span><br><br>
								{{this.connectionErr}}
							</template>
							<br><br><br><br>
							<table>
								<tr>
									<td colspan=2>
										<p class='header center green'>Installation</p>
										<p>There is not much to install, it's a single index.html file. 
											However, the file needs to connect to your local Ollama server and you have 2 choices for that:
											<ul>
												<li>You can install a local web-server as a reverse proxy.
												<li>If Ollama runs on your own computer, you can use a bad way to configure Ollama to
													allow a specific Origin header. As it still runs only on your local 127.0.0.1 address, others still
													won't be able to connect to it directly. However, sites you visit may use malicious code 
													to connect to your local network, as you run their code in your browser on your local 
													computer. So any site you open theoretically will be able to exploit your Ollama with this.
													You could limit the Origin header to a certain URL only but then you won't be able to run
													this from your local computer only, you would have to access this page on internet,
													which doesn't make much sense in my opinion as it's totally not required.
											</ul>
										</p>
										<p>So here is a longer but better way with a web-server:</p>
										<p>If you already have a web-server, there is not much to say, just put "index.html" from this
											project into any of your web folders, rename it as you wish if needed and access in browser.
										</p>
										<p>If you don't have a web-server, the easiest and the best one is Nginx.</p>
									</td>
								</tr>
									<tr>
									<td>
										Ubuntu:
									</td>
								</tr>
								<tr>
									<td>
										<ol>
											<li>Download the project, let's say it's in ~/ollama-chats
											<li>Open terminal
											<li>sudo apt install nginx
											<li>sudo cp ~/ollama-chats/nginx-ollama.conf /etc/nginx/conf.d
											<li>If you have different paths, make sure to edit the config file.
											<li>sudo cp ~/ollama-chats/index.html /var/www/html/ollama-chats.html
											<li>sudo chmod 640 /var/www/html/ollama-chats.html
											<li>sudo chown "$USER":www-data /var/www/html/index.html
											<li>sudo service nginx restart
											<li>Access http://127.0.0.1/ollama-chats.html in your browser
											<li>If you configured everything correctly, that's it. It was probably just 2-3 minutes.
										</ol>
									</td>
								</tr>
							</table>
						</td>
					</tr>
				</template>
			</table>
		</div>
	</div>
	<template id='tmplChatRow'>
		<tr :class='chatRowClass'>
			<td class='prev'>
				<div class='prevC'>
					<div :class='"nobg "+branchDelClass' @click='this.$root.listmsgs(0,this.turn,this.m)'>
						<template v-if='msgIndex!=0'>
							&lt;<br>
							{{msgIndex}}
						</template>
					</div>
				</div>
			</td>
			<td 
				:class='"nobg "+(msgLast?"lastmsg":"msg")+" "+msgDelClass'
				width	='100%'
			>
				<transition name="slide-fade" mode="out-in">
					<div :key='msgIndex' :class='this.msgContClass' :id='divId'>
						<div :class='nickClass'>
							<span contenteditable='true' @blur='editNick($event)'>{{m.nick}}</span> #{{msgIndex+1}}:
						</div>
						<div>
							<template v-for='(tr,trey) in this.trinityFields'>
								<div 
									:class='msgClass(tr)'
									:style					='"font-size:"+fontSize'
									:tabindex				='tabIndex+trey'
									:contenteditable='msgEditable'
									@blur						="edit($event,tr)"
									:key='trinity+"_"+this.uType'
								>
									{{ content(tr) }}
								</div>
							</template>
						</div>
						<template v-if='m.images&&m.images.length'>
							<br><br>
							<div>
								<template v-for='(img,ind) in m.images'>
									<span class='chatLogImg'>
										<img @click='img.s=img.s==0?1:0' :class='img.s==0?"imgEmbed":"imgBig"' :src='`data:image/gif;base64,${img.c}`'>
									</span>
								</template>
							</div><br>
						</template>
						<div class='msgFooter'>
							<span :class='"small "+statusClass'>{{status}}</span>
							<span class='msgNicks' v-if='stories'>
								<template v-if='usersAvail.length'>
									<span v-if='!msgUserListOn' class='lnk' @click='usersAvailShow(true)'>add</add></span>
									<template v-else>
										<span class='msgUserList'>
											<template v-for='uid in usersAvail'>
												<span class='lnk' @click='msgUserAdd(uid)'><nick :id='uid' :name='nicks[uid].n'></nick></span>
												&nbsp;
											</template>
										</span>
									</template>
								</template>
								&nbsp;
								<template v-for='(u) in m.nicksArr'>
									<span @click='msgUserDel(u)' class='lnk'><nick :id='u' :name='nicks[u].n'></nick></span> 
									&nbsp;
								</template>
							</span>
							<span 
								class='tokens' 
								v-show='tokensShow'
							>
								Tokens: 
								<template v-if='tokensTotal'>
									<!--span title='History token'>{{tokens('tp')}}</span>
										+
									<span title='Response tokens'>{{tokens('tr')}}</span>
									= -->
									<span title='Whole history tokens'>
										{{ tokensTotal }}
									</span>
									<template v-if='ctx.length'>
										of 
										<span title='Configured context window'>
											{{ ctx }}
										</span>
									</template>
								</template>
							</span>
							&nbsp;&nbsp;
							<span class='rating'>
								<span :class='m.rating===0&&"litn"' @click='msgRating(0)'>--</span>
								 / 
								<span :class='m.rating===1&&"litp"' @click='msgRating(1)'>++</span>
							</span>
							&nbsp;&nbsp;
							<span v-if='branchMoving' turn='this.turn' branch='this.branch'>
								<span v-if='!this.$root.branchMoving.self[msgUserListId]' class='red' @click='branchMvEnd()'>Graft to this branch</span>
								 or 
								<span @click='branchMvCancel()' class='red'>cancel moving</span>
								&nbsp;&nbsp;
							</span>
							<span v-else>
								<template v-if='!this.msgSide()'>
									(<span @click='branchMvStart()' class='del' title="You can move the branch growing from this place (everything to the bottom from here including side-replies) to any place in the chat. Well, apart from moving it into itself, that's a prohibited magic.">Mv</span>)
								</template>
								<span title='Delete the whole branch' @mouseEnter='this.delShow(1)' @mouseLeave='this.delShow(0)'>
									(<span class='del' @click='this.branchDel()'>X</span>)
								</span>
							</span>
							<!--span title='Delete this message and move everything below up one turn. It means that the messages from the next turn will merge into the current turn and everything below will just move up' @mouseEnter='this.mvShow(1)' @mouseLeave='this.mvShow(0)'>
								(<span class='del' @click='this.branchMerge()'>X</span>)
							</span-->
						</div>
					</div>
				</transition>
			</td>
			<td 
				class='next'
				@click='this.$root.listmsgs(1,this.turn,this.m)'
			>
				<div class='nextC'>
					<div
						v-if="m.side!=1"
						:class='"nobg "+branchDelClass'
						title="This will generate an alternative message."
					>
						><br>
						{{msgMore||">"}}<br>
					</div>
					<div 
						v-if	='m.side!=1&&msgRole==="a"&&branchRated'
						class	='nobg'
						title	="This (ctrl+right on keyboard) will generate a new message trying to use the messages you've rated in this turn as good/bad examples for AI"
						@click.prevent='this.$root.listmsgs(2,this.turn,this.m)'
					>
						+-<br>
						><br>
					</div>
				</div>
			</td>
		</tr>
	</template>
	<div id='tmplNick'><span>({{id}}) {{name}}</span></div>
	<div id='tmplMenuN'><span v-show='config.fKeys.v' class='menuHK'>{{k}}&nbsp;</span>{{t}}</div>
	<div id='tmplField' style='height:auto'>
		<div style='display: flex;align-items:center;height:100%;justify-content:center' :title='n+": "+i.d'>
			<span class='nobg' :style='(i.f==="ta"||i.f==="tb")&&"height:100%;width:100%;padding: 5px"'>
			<template v-if='nShow'>{{i.qn??n}}: </template>
			<template v-if='i.f==="ro"'>
				{{i.v}}
			</template>
			<template v-else>
				<template v-if='i.f==="cb"'>
					<input :title='n+": "+i.d' type='checkbox' v-model='i.v' :id='"field"+id'/>
				</template>
				<template v-else-if='i.f==="sel"'>
						<select v-model="i.v.v" :id='"field"+id'>
						<template v-for="(j,jind) in i.v.l">
							<option :value='jind'>{{j.n}}</option>
						</template>
					</select>
				</template>
				<template v-else-if='i.f==="mis"'>
						<template v-for='(k,kind) in i.v'> 
						<span class='nobreak'>{{kind+1}}: 
							<input class='understroke' type='input' v-model='i.v[kind]' :id='"field"+id+kind'/>
						</span><br>
					</template>
				</template>
				<template v-else-if='i.f==="file"'>
					<input :id='"load"+id' type='file' @change='loadFile(id)'/>
					<label class='lnk nobg' :for="'load'+id" :id="'loadLabel'+id">{{n}}</label>
					<template v-if='i.v!=""&&i.unload'><br>
						or <span class='lnk' @click='i.v=""'>remove existing</span>
					</template>
				</template>
				<template v-else-if='i.f==="ta"'>
						<textarea rows='4' style='height:100%;min-width:100%' v-model='i.v' :id='"field"+id'></textarea>
					</span>
				</template>
				<template v-else-if='i.f==="tb"'>
					<textarea rows='7' style='height:100%;min-width:100%' v-model='i.v' :id='"field"+id'></textarea>
				</template>
				<template v-else>
					<input v-model='i.v' :id='"field"+id'/>
				</template>
			</template>
			</span>
		</div>
	</div>
	<div id='tmplNickAdd'>
		<table width='100%'>
			<tr>
				<td class='nowrap addTxt right'>
					<div class='right'><span class='nobg'>New {{ut}}:</span></div>
				</td>
				<td class='addVal'>
					<input @keydown.enter='this.userAdd()' v-model='userNickA' :placeholder='ut'/>
				</td>
				<td class='addBtn'>
					(<span class='lnk nobgt' @click='this.userAdd()'>+</span>)
				</td>
			</tr>
			<tr v-show='uListAvail.length'>
				<td class='nowrap addTxt right'><div class='right'><span class='nobg'>Existing {{ut}}:</span></div></td>
				<td class='addVal'>
					<template v-if='amountNicks[t]>groups[group].an[t]'>
						<template v-if='t=="u"'>
							<select class='nickGroupAddList' v-model='userGroupAddId'>
								<template v-for='i in uListAvail'>
									<option :value='i'>({{i}}) {{nicks[i].n}}</options>
								</template>
							</select>
						</template>
						<template v-else>
							<select class='nickGroupAddList' v-model='userGroupAddId'>
								<template v-for='i in uListAvail'>
									<option :value='i'>({{i}}) {{nicks[i].n}}</options>
								</template>
							</select>
						</template>
					</template>
					<template v-else>
						all are in
					</template>
				</td>
				<td class='addBtn'>
					(<span @click='userGroupAdd()' class='lnk nobg'>+</span>)
				</td>
			</tr>
			<tr v-if='t==="a"'>
				<td></td>
				<td colspan='2'>
					<br>
					<span class='lnk nobg' @click='pToggle("charNew")'>Generate new</span>
				</td>
			</tr>
		</table>
	</div>
	<div id='tmplHeardBy'>
		<div class='heardBy' :style='!config.storiesUI.v&&"display:none;"' :title='`New message by (${u}) ${nicks[u].n} will be "heard" only by these users`'>
			<span :class='nicks[u].t=="a"?"nobgb":"nobgt"'>
			<template v-for='id in users'>
				<template v-if='u!=id'>
					<input type='checkbox' v-model='groups[group].u[u][id]'><nick :id='id' :name='nicks[id].n'/>
				</template>
			</template>
			</span>
		</div>
	</div>
	<div id='tmplTalkers'>
		<template v-if='userS(t)!=null'>
			<transition name="slide-fade" mode="out-in">
				<div><!-- :key='group+groups[group]["u"].length'-->
					<table class='talkers'>
						<tr>
							<td :class='t=="a"?"nobgb":"nobgt"'>
								<center>
								<span>
									<span title="This simply changes the set of characters if you don't want to see them all. You can predefine these at the top" @click='groupPrev()' class='lnk groupPN' v-if='config.storiesUI.v&&group>0'>&lt; {{groups[group-1].n}}</span>
									&nbsp;
									<template v-for='(i,id) in groups[group]["u"]'>
										<template v-if='userVis(id)'>
											<span class='nickSel' 
												@click.right.prevent='send($event,1,null,id)'
											:title='
												t==="u"?
													`"Speak for" selector. This selects the character you play for in this turn. For example you nay have your main "hero" and "World" describing the changes of the situation.`
													:`"Reply from:" selector. This selects an AI character that will generate a reply. You can have multiple personages talking to you. Every AI personage has its own instruction (instr) and system prompt. Click on the desired character here and then edit their system prompt by clicking "System prompt" below. Add more AI characters at the top. Hint: right-click on this nick will auto-submit current prompt as this user.`
											'>
												<input 
													:id='"s"+t+id' :name='"s"+t+id' :key='"s"+t+id'
													class='nickSel'
													type='radio' 
													:tabindex='(t==="u"?5100:5500)+id*1' 
													
													@change='userCh()' 
													
													@keydown.enter.stop	='send($event,1,null,id)' 
								
													:value='id' 
													v-model='groups[group]["sel"][t]'
												/>
												<label 
													class='lnk' 
													:for='"s"+t+id'
												><nick :id='id' :name='nicks[id].n'/></label>&nbsp;
											</span>
										</template>
									</template>
									&nbsp;
									<span title="This simply changes the set of characters if you don't want to see them all. You can predefine these at the top" @click='groupNext()' v-if='config.storiesUI.v&&group<(groups.length-1)' class='lnk groupPN'>{{groups[group+1].n}} ></span>
								</span>
								</center>
							</td>
							<td :class='"right "+(t=="a"?"nobgb":"nobgt")' v-if='config.storiesUI.v'>
								<heard-by :u='userS(t)' :config='config' :nicks='nicks' :groups='groups' :group='group'></heard-by>
							</td>
						</tr>
					</table>
				</div>
			</transition>
		</template>
		<template v-else>
			<template v-if='t=="u"'>
				<p class='talkers nobgt'>Please add at least one user you control at the top-right corner.
			</template>
			<template v-else>
				<p class='talkers nobgb'>Please add at least one AI controlled user at the top-right corner.</p>
			</template>
		</template>
	</div>
	<div id='tmplUserList'>
		<template v-for='(i,id) in groups[group]["u"]'>
			<template v-if='userVis(id)'>
				<span class='nick'>
					(<span class='nobg'>{{id}}</span>)
					<input v-model='nicks[id].n'/>(<span @click='userTypeCh(id)' class='lnk userTypeCh nobg' title='Change user type from manual to AI and vice-versa if you all of a sudden decide to control some character yourself or wish AI to control your character.'><template v-if='t=="a"'>&uarr;</template><template v-else>&darr;</template></span>)<span class='nickDelC'>(<span class='nickDel nobg' @click='group==0?userDel(id):userGroupDel(id)'>x</span>)</span>
				</span>&nbsp;
			</template>
		</template>
	</div>
	<div id='tmplHelp'>
		<div id='help'>
			<div class='center understroke header green'>How to chat here, a short guide</div>
			<ol>
				<li>At the top left rename your character, rename Ai character.</li>
				<li>At the top right add more characters if your rpg will have more people.</li>
				<li>Click "system prompt", a new text area opens. 
						Write the definition of the first AI character into the system prompt.
						like "You are...". Alternatively, click on "generate new" (shift+F7)
						and let the system generate a new character for you automatically!
				</li>
				<li>If you have more than one AI character, under the prompt text area
						you will see several radio buttons with the names you created.
						By default the first one is chosen and you've already defined the system prompt
						for this one. Now, click on the next radio button and system prompt
						box will be cleared, as now it is a system prompt of the newly selected
						character. Write a definition for this character. Repeat with all
						AI characters you've created. You can update these anytime during
						the chat.</li>
				<li>Click on "system prompt" link again to hide it.</li>
				<li>Click on "instr". It uses the same logic as system prompt and defines
						instructions for each AI character. You can use it to push character
						towards certain actions in a story. It should be written in first person.
						For example: "i'm so jealous". or "i'm angry". or "i want to..".
						Also you can use it for describing the location of personages, for whatever.
						Use it throughout the chat process, changing accordingly.</li>
				<li>Click on instr to hide it, if you don't want to see the text area.</li>
				<li>Before start, check the configuration (F9) and set the num_ctx param to a desired value.
						It's a size of the context memory in tokens that AI remembers. 
						Check other settings you may need, like temperature, etc.</li>
				<li>Below the "prompt" text area in the select list choose the model you wish to get reply from.
						if you don't have models, you can click "pull" and download some.
						Names of the models to pull you can see at ollama.com/library website.</li>
				<li>It's a good idea to click "Save" now to save your starting point of the game.</li>
				<li>Type in your first message. it's best to start from introduction,
						like "I'm ...describe yourself... walking/sitting/doing sth.	
						Usually you can put into the system prompts how they are related to you. 
						so the reply should make some sense, when they meet you.</li>
				<li>Hit enter to send your first message.</li>
				<li>Once the model is loaded, which may take time, the character will reply.</li>
				<li>If you dislike the reply, just hit "right" on the keyboard or click the arrows
						on the right of the AI reply.
						repeat until the reply is good.</li>
				<li>If the reply is nearly ideal but something is wrong, just click on the
						reply and edit that part yourself. Erasing of extra bs is a good idea,
						as models love to litter with meaningless garbage, platitudes, etc.</li>
				<li>If you decide that your own message is no good, you can edit it too. or, you can
						create an alternative side-reply, by clicking the "right" arrows on the right
						from your message. Then just type new prompt as usually and send it.</li>
				<li>Use rating buttons for AI messages. By default AI is instructed to follow the style of these. You can disable it in configuration, if you wish to use the rating for future finetuning project but do not wish the model to see it in the chat.</li>
				<li>Also, you can use the rating of model's answers in the last turn to instruct the model. If you click "ctrl+right" or (-/+ button to the right from message, it's shown only if you have a rated messages), the model will be instructed to provide a new reply unlike bad ones and alike to the good ones. It may help if the answers are really bad.</li>
				<li>If you are bored with the story development you can anytime use up/down arrows to go up in the story and start another branch there or continue an existing alternative branch.</li>
				<li>It's a good idea to post situation changes from the name of the
						"World" character. like "That person went away". or "it started to rain".
						or "You have noticed that..". etc. To send message from another user
						just type in the prompt, click on the respective radio button above the prompt text area and
						hit enter.</li>
				<li>You can choose which character replies next by clicking on the respective
						radio button under the prompt box. You even can send empty messages,
						to make them talk to each other, that's half of the fun. Empty messages are hidden by default,
						so it looks like they just talk to each other, but you can change it in the configuration.
						If they don't want to talk to each other, use "instr" field with sth like
						"now i should reply to.." or add some message from the world. To save a click
						on a prompt, if you just want another ai character to reply, just do a right click on it,
						it will make it choose that character and submit the current prompt right away.</li>
				<li>If you feel you need more control over the character's memory, you can use "Stories", it's enabled in the configuration. With this feature on, you can define the access list for all messages, so you can have characters that don't know what's going or who plan something and others have no clue, or just characters that come late and being unaware, etc.</li>
				<li>If you wish, you can define different settings per AI with personal settings in.. configuration. This way, for example, you could use 2 different models for 2 characters without need to change them every time.</li>
				<li>To expand the memory and world knowledge of the characters, you can fill in their memories with shift+f4 and shift+f5 keys (P.knlg and Ch.mem. in the menu). You can put any amount of data there and it will be searched by relevance to your last chat context and injected as something that character remembers. To have the best effect, use a lot of synonyms in each line. You can make these relevant not just text, but to moods.</li>
				<li>You can save the created characters with SHIFT+F2 and load with SHIFT+F3 into existing chat or share with your friends</li>
				<li>3ty (trinity) mode makes characters to reply in 2 parts: thoughts + actions. You can deactivate this mode if you don't like it.</li>
				<li>Repeat the process till the alarm clock is ringing telling you it's time to wake up.
						it was good idea to set alarm clock in your phone to the evening time, so
						you still have time to sleep tonight.</li>
				<li>Enjoy.</li>
			</ol>
		</div>
	</div>
	<div id='tmplOpt'>
		<template v-if='!opt.run'>
			<table id='optL' >
				<tr>
					<td colspan='6'>
						<p class='green center'>
							<span class='header'>Configure here ranges of parameters to try, per model.</span>
							<br>
							<span @click='pToggle("optHelp")' class='lnk'>(click for a short instruction)</span>
						</p>
						<transition name='slide-fade'>
							<div v-if='pState["optHelp"]' id='optHelp' :key='pState["optHelp"]'>
								<p class='justify'>
									Here you can try to tune parameters to get the replies you like.
									How? Simple, it allows you to set starting value and final value of the range to try,
									as well as step size for next iteration. Then you just see which parameter combinations
									produce the best replies.
								</p>
								<p>
									<ul class='justify'>
										<li>
											IMPORTANT: always set SEED to start=1, end=1, step=1 and toggle on the "use"
											for seed! That guarantees, that replies models produce do not have
											a random element to them. I can not set this as default for 
											logical reasons of various use cases.
										</li>
										<li>
											Before starting this, remember to set everything in configuration to 
											default, unless you actually want to use your manual configuration
											together with this. 
										</li>
										<li>
											To make it work you need to set Start value of the range you want to try,
											End value (that is, when to stop) and the Step value, that is how much
											we should add at every next try. For example: temperature start=1,
											end=5, step=2 will try to get replies for temperatures: 1, 3, 5.
										</li>
										<li>
											This thing works PER model. Beautiful. It means, you can set
											separate paramaters to try per each model you wish to try. To do that,
											simply select the model you wish to try and configure parameters to try,
											then switch to a second model and repeat for the second one, etc. Once
											you click "Run" all configured models are tried, one by one.
											Non-configured models are skipped.
										</li>
										<li>
											Most important parameters to play with are: temperature, top_k, top_p,
											mirostat, single prompt.
										</li>
										<li>
											Do not use small steps. Like, if you configure trying temperatures
											from 1 to 300 with the step "1", you get 300 replies to wait for.
											Now, if you you also add to that top_k 1 to 300 with the step 1, that's
											300*300 (every possible temperature vs every possible top_k) which makes
											it 90000 replies to wait for - if your setup generates a reply in 1
											second, that's 25 hours to wait :). So what's your strategy?
											Simply provide a very big steps, like temperature 1 to 300, step 50.
											That's only 6 replies. And top_k 1 to 300 is 6 more. So you get
											36 replies to wait for. If you add to that top_p from 1 to 100, step 20,
											you get 5 more steps, which makes it 36*5=180 replies. Even that is
											a lot, unless your setup is very fast. But with these you will see what 
											these changes do to replies, so you can figure out what rocks your boat.
											Once you know the approximate good parameters combination, you can repeat 
											the process but in that small nice area with a smaller ranges and steps.
										</li>
										<li>
											The results are auto-normalized for your convenience. That means, that
											all identical replies are collapsed into one, all the
											parameter combinations that produced that very same result are placed 
											next to it.
										</li>
										<li>
											Do not try to change settings during the work, it makes everything
											meaningless.
										</li>
										<li>
											Before starting this experiment, first have a your typical chat with ai,
											so it would have some context. Then you can actually see what your
											configuration do in a real chat. Using this with just "hi" is pointless,
											unless you search for an ideal config to run functions or something like 
											that.
										</li>
									</ul>
								</p>
							</div>
						</transition>
					</td>
				</tr>
				<tr>
					<td colspan='6' class='center'>
						Settings for:<fields n='' :i='settings.req.model' :n-show='false'/>
					</td>
				</tr>
				<tr>
					<td colspan='6' class='center' id='optTimes'>
						Amount of replies per combination: <input v-model='opt[settings.req.model.v.v].times'>
					</td>
				</tr>
				<tr>
					<td class='param' title='Name of the parameter to try to be changed'>Param</td>
					<td class='start' title='Starting value of this parameter'>Start</td>
					<td class='end' title='Ending value of this parameter'>End</td>
					<td class='step' title='Step we will go by, walking from start value to end value, for example from 1 to 5 step can be=1.'>Step</td>
					<td class='round' title='Round the parameter to this many decimals, to avoid getting parameters like 3.0000000000000004. If empty, no rounding. Please note, that if you round things wrong, you may end up posting the same combination many times (e.g. if you round 0.1-0.7 to an integer.'>Round</td>
					<td class='use' title='Should we use this parameter in our trial or not.'>Use</td>
				</tr>
				<template v-for='j of [config,settings.options,settings.req]'>
					<template v-for='(i,ind) of j'>
						<template v-if='i.opt===true'>
							<tr>
								<td class='param'>{{i.name??ind}}:</td>
								<template v-if='i.f!="cb"&&i.f!="sel"'>
									<td class='start'><input class='understroke' @keyup="optChUse(settings.req.model.v.v,ind)" v-model='opt[this.settings.req.model.v.v]["v"][ind]["start"]'></td>
									<td class='end'><input class='understroke' @keyup="optChUse(settings.req.model.v.v,ind)" v-model='opt[this.settings.req.model.v.v]["v"][ind]["end"]'></td>
									<td class='step'>
										<input class='understroke' @keyup="optChUse(settings.req.model.v.v,ind)" v-model='opt[this.settings.req.model.v.v]["v"][ind]["step"]'>
									</td>
									<td class='round'><input class='understroke' v-model='opt[this.settings.req.model.v.v]["v"][ind]["rnd"]'></td>
								</template>
								<template v-else>
									<td colspan='4' class='step'>a true/false param, nothing to configure</td>
								</template>
								<td class='use'>
									<input class='understroke' type='checkbox' v-model='opt[this.settings.req.model.v.v]["v"][ind]["use"]'>
								</td>
							</tr>
						</template>
					</template>
				</template>
				<tr>
					<td colspan='6' class='right'><span class='lnk' id='optRun' title="start the experiment" @click='optimizeRun()'>->Run</span></td>
				</tr>
			</table>
		</template>
		<template v-else>
			<p class='header'>Running.. {{opt.count.d}} / {{opt.count.t}} &nbsp;&nbsp;<span class='lnk' @click='optimizeCancel()'>Cancel</span></p>
			<template v-if='opt.vals.length||opt.count.t>0'>
				<table class='optResP' id='optResCur'>
					<tr>
						<td :colspan='opt.vals.length+1' class='center'>{{settings.req.model.v.l[opt.m].n}}<br></td>
					</tr>
					<template v-if='1'>
						<opt-res-vals-header :m='opt.res[opt.m]'></opt-res-vals-header>
					</template>
					<template v-if='1'>
						<opt-res-vals-line 
							:m='opt.res[opt.m]'
							:mid='branch.msg+1'
							:vals='opt.vals'>
						</opt-res-vals-line>
					</template>
				</table><br>
			</template>
		</template>
		<table width='100%' class='center' id='optRes' v-if='opt.count.t>0'>
			<tr>
				<td><span class='header'>.. results .. results .. results ..<br></span><span class='lnk rightf' @click='optResSave()'>Export to a file</span></td>
			</tr>
			<template v-for='(m,mi) in opt.res'>
				<template v-if='m.v.length'>
					<tr>
						<td class='header'>{{settings.req.model.v.l[mi].n}}</td>
					</tr>
					<template v-for='(i,ind) in m.v' >
						<tr>
							<td class='justify'>
								<opt-res :m='m' :i='i'></opt-res>
								<span class='green header'>{{ind+1}}:</span> {{i.c}}
							</td>
						</tr>
					</template>
				</template>
			</template>
		</table>
	</div>
	<template id='tmplOptRes'>
		<table class='rightf optResP'>
			<template v-if='1'>
				<opt-res-vals-header :m='m'></opt-res-vals-header>
			</template>
			<template v-for='(vals,valsid) in i.v'>
				<opt-res-vals-line :mid='i.ids[valsid]+1' :vals='vals' :m='m'></opt-res-vals-line>
			</template>
		</table>
	</template>
	<template id='tmplOptResValsLine'>
		<tr>
			<td class='center'>{{mid}}</td>
			<template v-for='(v,vind) in vals'>
				<td class='center'>
					<template v-if='m.k[vind].f=="cb"'>{{v==0?"False":"True"}}</template>
					<template v-else>{{v}}</template>
				</td>
			</template>
		</tr>
	</template>
	<template id='tmplOptResValsHeader'>
		<tr>
			<td class='center green' title='side message number in the chat'>#</td>
			<template v-for='k in m.k'><td class='center green' :title='`${k.name}: ${k.d}`'>{{k.qn??k.name}}</td></template>
		</tr>
	</template>
	<div id='tmplRagErr'>
		<template v-if='rag.err!=null'>RAG is not working: {{rag.err}}</template>
	</div>
	<div id='tmplRagStatus'>
		<span class='nobgb'>
			<template v-if='rag.err!=null'>
				<rag-err :rag='rag'></rag-err>
			</template>
			<template v-else-if='rag[id].doing'>
				Updating: {{rag[id].done}} / {{rag[id].total}}
			</template>
			<template v-else>
				Total: {{rag[id].v.length}}
			</template>
		</span>
	</div>
	<div id='tmplCharNewParsedParams'>
		<table class='charNewParams'>
			<template v-for='(r,rey) in charNew.parts.paramsCore'>
				<tr>
					<td class='right green'>
						{{r.pnl}} &lt;-> {{r.pnr}}:
						<br>
						<template v-if='charNew.stepShow==0&&r.v==0'>
							random
						</template>
						<template v-else>
							<template v-if='r.v==0'>
								<b>random</b>: {{r.vh}}
							</template>
							<template v-else>
								{{r.vh}}
							</template>
							({{r.vp}}%)
						</template>
					</td>
					<td>
						<template v-if='charNew.stepShow==0'>
							<input :disabled='disabled' @input='charNewCoreParamCh(r)' :class='r.v==0&&"rangeRandom"' type='range' :min='r.min' :max='r.max' v-model='r.v'>
						</template>
						<template v-else>
							<input :disabled='disabled' @change='r.v=$event.target.value;charNewCoreParamCh(r)' :class='r.v==0&&"rangeRandom"' type='range' :min='r.min' :max='r.max' :value='r.c'>
						</template>
					</td>
					<td style='width: 30px'></td>
				</tr>
			</template>
			<template v-for='(p,pey) in charNew.parts.params'>
				<template v-if='(p.n!=""||charNew.stepShow==0)&&!p.h'>
					<tr>
						<td class='right green'>
							<input :disabled='disabled' class='understroke 'v-model='p.n' :placeholder='p.nph'>
						</td>
						<td>
							<template v-if='charNew.stepShow==0'>
								<textarea :disabled='disabled' rows=2 style="width:100%" v-model='p.v' :placeholder='(p.c!=null&&p.c.length)?p.c:p.ph'>{{p.v}}</textarea>
							</template>
							<template v-else>
								<textarea :disabled='disabled' rows=2 style="width:100%" v-model='p.c'>{{p.c}}</textarea>
							</template>
						</td>
						<td v-if='charNew.stepShow==0'>
							<input :disabled='disabled' placeholder='0' title='Amount of memories to generate about this. Leave empty to not generate any memories for this parameter.' class='understroke' style='width:30px' v-model='p.memq'>
						</td>
						<td>
							<template v-if='p.n.length&&!disabled'>(<span class='nobg del' @click='charNewParamsDel(pey)'>x</span>)</template>
						</td>
					</tr>
				</template>
			</template>
		</table>
	</div>
	<template id='tmplCharNewMemSets'>
		<table class='charNewMemSets' v-if='charNew.parts.mem!=null'>
			<tr>
				<td colspan='2' class='center'>
					<span class='nobg green'>Custom topics to generate new memories:</span>
				</td>
			</tr>
			<template v-for='(mc,mey) in charNew.parts.mem.custom'>
				<tr>
					<td title='Topic' style='width: 100%'>
						<textarea :disabled='charNew.working' placeholder='Use this field to create one more topic for memories' v-model='mc.v'>{{mc.v}}</textarea>
					</td>
					<td title='Amount of memories to generate' style='width:40px;vertical-align:middle;'>
						<input :disabled='charNew.working' class='understroke' style='width:30px' v-model='mc.q'>
					</td>
					<td v-if='!charNew.working' title='Delete the topic' style='width:40px;vertical-align:middle;'><template v-if='mey!=charNew.parts.mem.custom.length-1'>(<span class='nobg del' @click='memSetsDel(charNew,mey)'>x</span>)</template></td>
				</tr>
			</template>
			<template v-if='charNew.stepShow>0&&charNew.parts.memCountT.hasOwnProperty("params")&&charNew.parts.memCountT["params"]>0'>
				<tr>
					<td colspan='3'>
						<div class='nobg green'>
							Topics below are not editable at this step as these use model generated content. If you wish to change the value, you can edit parsed parameters at the step 2 and then to regenerate the system prompt, to keep things consistent.
						</div>
					</td>
				</tr>
				<template v-for='(p,pey) in charNew.parts.params'>
					<tr v-if='p.memq!=""&&p.memq>0'>
						<td title='Topic' style='width: 100%'>
							<textarea disabled=1>{{p.memt.length?p.memt:`${p.n}: value that will be generated`}}</textarea>
						</td>
						<td title='Amount of memories to generate' style='width:40px;vertical-align:middle;'>
							<input :disabled='charNew.working' class='understroke' style='width:30px' v-model='p.memq'>
						</td>
						<td v-if='!charNew.working' title='Delete the topic' style='width:40px;vertical-align:middle;'>
							(<span class='nobg del' @click='p.memq=""'>x</span>)
						</td>
					</tr>
				</template>
			</template>
		</table>
	</template>
	<template id='tmplCharNewMemParsed'>
		<table width='100%' class='memParsed'>
			<tr>
				<td colspan='2' class='left'>
					<span class='left green nobg'>
						<template v-if='charNew.stepShow==3'>
							Parsed memories: {{charNew.parts.m.length}} / {{charNew.parts.memCountT.total}}
						</template>
						<template v-else>
							Memories: {{charNew.parts.m.length}} / {{charNew.parts.memCountT.total}}
						</template>
					</span>
				</td>
			</tr>
			<template v-if='charNew.parts.m.length'>
				<template v-for='(m,mey) in charNew.parts.m'>
					<tr>
						<td style='width:20px;vertical-align: middle;' class='middle right green'><div class='nobg'>{{mey+1}}:</div></td>
						<td style='width:100%'>
							<textarea :disabled='charNew.working' rows='4' v-model='charNew.parts.m[mey]'></textarea>
						</td>
						<td style='width:20px;vertical-align: middle;'>
							<template v-if='!this.charNew.working'>(<span class='nobg del' @click='memParsedDel(charNew,mey)'>x</span>)</template>
						</td>
					</tr>
				</template>
			</template>
			<template v-else-if='charNew.stepShow==3'>
				<tr>
					<td colspan='2' class='center'>
						<span class='nobg'>..nothing yet..</span>
					</td>
				</tr>
			</template>
		</table>
	</template>
	<template id='tmplCharNewSystemEdit'>
		<div class='left'>
			<span class='lnk nobg' @click='pToggleDo("charNewSys"+id)'>Show the prompt used for generation</span>
			<transition name='ta'>
				<div v-if='pState["charNewSys"+id]' :key='pState["charNewSys"+id]'>
					<div class='nobgt rightf'>System prompt</div>
					<textarea :disabled='charNew.working' rows='7' :id='"charNewSys"+id' v-model='charNew.parts.system[id].sys'></textarea>
					<span class='lnk nobgb' @click='charNewSystemReset(charNew,id)'>restore</span>
					<br><br>
					<template v-for='(r,rey) in charNew.parts.system[id].req'>
						<div class='rightf nobgt'>{{r.t}}</div><br>
						<textarea :disabled='charNew.working' rows='7' v-model='r.req'></textarea>
						<span class='lnk nobgb' @click='charNewReqReset(charNew,id,rey)'>restore</span>
						<br><br>
					</template>
				</div>
			</transition>
		</div>
	</template>
	<div id='tmplCss'>
<style id='css'>
html {
}
.tmpl {
	display: none;
}
* {
	font-size: 14px;
	font-family: Arial;
	transition: all 0.71s ease-out;
//	color: #e5e5e5;
}
::selection {
  color: #10ee10;
  background: #103510;
}
body {
	background-color: #141414;
	color: #e0e0e0;
	background-size: 100% auto;
	background-repeat: repeat-y;
}
textarea {
	text-size: 16px;
	//background-color: black;
	background-color: rgba(0,0,0,0.45);
	color: #e0e0e0;
//	color: white;
	width: 100%;
	box-sizing: border-box;
	border-color: silver;
	border-radius: 5px;
  border-image: linear-gradient(#103510, #141414, #103510) 2/3px 2px 3px 2px;
  box-shadow: 0px 0px 7px rgba(0,0,7,0.7);
  padding: 10 10 10 10;
}
textarea:focus {
	outline: #e0e0e0 solid 1px;
	background-color: rgba(0,0,0,0.45);
	border-color: silver;
}
input {
	text-size: 16px;
	background-color: rgba(0,0,0,0.45);
	color: #15ea15;
	accent-color: darkgreen;
	outline-color: transparent;
	box-sizing: border-box;
	border-color: transparent;
	border-width: 0 0 1 0;
	border-radius: 5px;
	padding: 4 3 2 3;
  text-align: center;
}
input:focus {
	outline: none;
}
input[type=checkbox] {
	accent-color: darkgreen;
	padding: 3 3 3 3;
}
input[type="file"] {
	display: none;
}
select {
	text-size: 16px;
	color: mediumseagreen;
	background-color: rgba(0,0,0,0.45);
	//background-color: black;
	box-sizing: border-box;
	border-color: #e0e0e0;
	//margin: 15 15 15 15;
	padding: 5 2 2 2;
  border-image: linear-gradient(#103510, #141414, #103510) 2/3px 2px 3px 2px;
}
#app {
	width: 100%;
}
li {
	margin-bottom: 7px;
}
#bg {
	position: absolute;
	z-index: -1;
	width: 100%;
	height: 100%;
}
.imgEmbed {
	width: 150px;
}
.imgBig {
	width: 100%;
}
.imgPrompt {
	width: 35px;
}
#imgAdd {
	padding-top: 0px;
}
#imgAddList {
	padding: 2 5 2 2;
}
.chatLogImg {
	padding: 2 2 2 5;
}
#chat {
	width: 800px;
	max-width: 800px;
	margin: auto;
	height: 100%;
	border-spacing: 13px 10px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/2px 0px 2px 0px;
}
#chat td {
	border-width: 0px;
	vertical-align: top;
	border-radius: 7px;
	padding: 7 10 5 10;
}
#chat #nicks td {
	text-align: left;
	padding: 2 5 2 5;
	vertical-align: middle;
}
.talkers {
	width: 100%;
	border-spacing: 0;
	text-align: center;
	padding: 0 0 0 0 !important;
	margin: 0 0 0 0 !important;
}
.talkers td {
	border-spacing: 0px;
	padding: 0 0 0 0 !important;
}
#talkersB {
	border-spacing: 0px 0px;
	width: 100%;
}
#talkersB td {
	border-width: 0px;
	vertical-align: top;
	padding: 0 0 0 0 !important;
}
#cardSave #msgs {
	border-spacing: 0px 0px;
	width:100%;
}
#cardSave #msgs td {
	vertical-align: middle;
}
#cardSave #msgs .nick {
	min-width: 150px;
}
#cardSave #msgs .content {
	width: 100%;
}
#cardSave #msgs .del {
	min-width: 30px;
}
#memGen {
	width: 100%;
}
.memParsed {
	width: 100%;
	border-spacing: 13px 10px;
}
#charNew {
	width: 100%;
	padding: 5 10 10 10;
	margin-top: 20px;
	& td {
		width: 50%;
		height: 100%;
	}
}
#charNewStep {
	width: 100%;
}
#charNewStep td {
	width: 33%;
}
#charNewHelp li {
	text-align: justify;
}
.charNewMemSets {
	width: 100%;
	border-spacing: 13px 10px;
}
.charNewParams {
	width: 100%;
	& td {
		vertical-align: middle!important;
	}
	& td:nth-child(1) {
		width: 120px !important;
		max-width: 120px !important;
		min-width: 120px !important;

		& input {
			width: 100%;
			min-width: 90px;
			text-align: right;
		}
	}
	& td:nth-child(3) {
		width: 30px !important;
	}
	& td:nth-child(4) {
		width: 30px !important;
	}
	& td:nth-child(2) {
		width: 100% !important;
		& input[type="range"] {
			width: 100%;
			min-width: 90px;
		}
	}
}
#chatLogC {
//	display: block;
	overflow: scroll;
//	max-height: 300px;
	scrollbar-color: mediumseagreen;
}
#chatC {
	background-size: 100% auto;
	background-repeat: repeat-y;
}
.chatRow {
}
.nobg {
	padding: 5 5 5 5;
	background-color: rgba(0,0,0,0.7);
	border-radius: 25px;
	box-shadow: 0px 0px 7px rgba(0,0,7,0.7);
}
.nobgb {
	padding: 0 5 5 5 !important;
	background-color: rgba(0,0,0,0.7);
	border-radius: 0px 0px 9px 9px !important;
	box-shadow: 0px 0px 7px rgba(0,0,7,0.7);
}
.nobgt {
	padding: 5 5 5 5 !important;
	background-color: rgba(0,0,0,0.7);
	border-radius: 9px 9px 0px 0px !important;
	box-shadow: 0px 0px 7px rgba(0,0,7,0.7);
}
#menu .nobg {
	padding: 1 1 1 1;
	background-color: rgba(0,0,0,0.75);
	display: block;
	width: 100%;
	font-weight: bold;
}
#chat #nicks * {
	font-size: 12px;
}
#chat #nicks input {
	width: 95px;
	font-size: 12px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#chat .nicku,#chat .nickai {
	font-size: 12px;
	font-style: italic;
	background-color: #101910;
	clear: both;
	padding: 10 10 10 10;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/2px 0px 2px 0px;
}
.filterDark {
	filter: brightness(75%);
}
.filterGray {
	filter: saturate(0%) brightness(60%);
}
.rangeRandom {
	filter: invert(100%) hue-rotate(180deg);
}
.gray {
	filter: saturate(0%) brightness(60%);
}
.msgUserList * {
	filter: saturate(0%);
}
.msgTextCont {
	height: 100%;
}
.msgTextCont:hover .nicku,.msgTextCont:hover .nickai {
	border-radius: 0px;
	border-width: 0px;
	border-image: linear-gradient(to right, #023502, #306530, #306030, #023502) 3/2px 1px 2px 1px;
  background: radial-gradient(85% 1110%, #054505,#002000);
}
.msg:hover,.lastmsg:hover {
 	background-color: #002500;
}
.msgNicks, .msgNicks * {
	font-size: 10px;
}
.msgNicks {
	margin-right: 15px;
	vertical-align: middle;
}
.msgDelShow {
	background-color: #210000 !important;
	filter: brightness(68%);
}
.msgMvShow {
	background-color: #003800 !important;
}
#chat .nicku {
	float: left;
	margin: 0 7 7 0;
}
#chat .nickai {
	float: right;
	margin: 0 0 7 7;
}
#chat .msgText {
	padding: 11 4 1 4;
	white-space: pre-wrap;
}
#chat .lastmsg {
}
#chat .next,#chat .prev {
	vertical-align: middle;
	min-width: 20px;
	font-weight: bold;
	text-align: center;
  padding: 2 2 2 2;
  height: 100%;
}
.next *,.prev * {
  color: #15c015;
}
.prevC,.nextC {
	display: flex;
	flex-direction: column;
	height: 100%;
	gap: 5px;
  background-color: #141414;
}
.prevC div,.nextC div {
	display: flex;
	justify-content: center;
	align-items: center;
	flex: 1;
  border-image: linear-gradient(#103510, #141414, #103510) 2/3px;
	padding: 7px;
}
.prevC div:hover,.nextC div:hover {
  background: radial-gradient(150% 200%, #052005, #141414);
}
.prevC div,.nextC div {
  border-radius: 7px;
}
#menu table {
	border-spacing: 0px 5px;
}
#menu table td {
	padding: 1px;
	padding-top: 4px;
	text-align: justify;
	white-space: nowrap;
}
#chat .msg, #chat .lastmsg {
	height: auto;
	border-image: linear-gradient(to right, #141414, #205520, #205520, #141414) 5/1px 0px 2px 0px;
}
#loadlabel {
  display: inline-block;
  cursor: pointer;
}
#loadRaglabel {
  display: inline-block;
  cursor: pointer;
}
.msgFooter {
	margin: 7 7 7 7;
	float: right;
	clear: none;
}
.rating {
	vertical-align: middle;
}
.rating * {
	font-size: 18px;
}
.litp {
	color: #15c015;
}
.litn {
	color: #d51515;
}
#contextFilter {
	text-align: right;
	padding: 0 10 0 0 !important;
	margin: 0 10 0 0 !important;
}
#contextFilterRow td {
	padding: 0 10 0 0 !important;
	margin: 0 10 0 0 !important;
}
#contextFilter * {
	text-align: right;
	font-size: 10px;
}
#contextFilter * input {
	padding-right: 2px;
	margin-right: 2px;
	width: 10px;
	height: 10px;
}
.understroke {
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#sysinstr {
	width: 100%;
	text-align: center;
	margin: 10 0 0 0;
	padding: 0 0 0 0;
}
#sysinstr td {
	text-align: center;
	border-spacing: 0px 0px;
	margin: 0 0 0 0;
	padding: 0 0 0 0;
}
#sets {
	//max-width: 100%;
	width: 800px;
	text-align: center;
}
#sets .title {
	width: 300px;
	text-align: right;
}
#sets .descr {
	max-height: 125px;
	overflow: auto;
}
#sets .def {
	width: 180px;
	vertical-align: middle;
}
#sets .val {
	width: 300px;
	height: 100%;
	overflow: clip;
	//max-width: 200px;
	min-width: 200px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
	padding: 5px;
	margin: 7 10 5 10;
	vertical-align: middle;
}
#sets input {
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#sets .setsQ {
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
	width: 20px;
	padding: 0px;
	vertical-align: middle;
}
#setsQ div {
	color: silver;
}
#setsQ input {
	width: 30px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
	padding: 0px;
	margin: 2 2 2 2;
	vertical-align: middle;
}
#setsQ input[type='checkbox'] {
	width: 10px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
	padding: 0px;
	margin: 2 7 2 0;
	vertical-align: middle;
}
#sets .val input {
	border-width: 0 0 0 0;
	text-align: center;
}
#optRes {
	border-color: mediumseagreen;
	border-radius: 5px;
	border-spacing: 0px 15px;
}
#optResCur {
  margin-left: auto;
  margin-right: auto;
}
#optResCur td {
	padding: 7 10 5 10;
	border-width: 2px;
	border-radius: 5px;
  border-image: linear-gradient(#103510, #313531, #265126) 2/3px 2px 3px 2px;
}
.optResP {
	margin-left: 10px;
	margin-bottom: 5px;
	margin-top: -7px;
}
#optRes .header {
	font-size: 16px;
	color: mediumseagreen;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#optRes td {
	padding: 7 10 5 10;
	word-wrap: break-word;
	border-width: 2px;
	border-radius: 5px;
  border-image: linear-gradient(#103510, #313531, #265126) 2/3px 2px 3px 2px;
}
#optRun {
	font-size: 16px;
	font-weight: bold;
}
#optTimes input {
	width: 30px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#optL {
	width: 100%;
	//border-color: mediumseagreen;
	//border-radius: 5px;
  //border-image: linear-gradient(#103510, #141414, #103510) 2/3px 2px 3px 2px;
}
#optL .param {
	text-align: right;
	min-width: 175px;
	max-width: 200px;
}
#optL .start, #optL .end, #optL .step  {
	text-align: center;
	max-width: 55px;
	vertical-align: middle;
}
#optL .use {
	text-align: center;
	min-width: 35px;
}
#optL .start input, #optL .end input, #optL .step input {
	text-align: center;
	width: 55px;
}
#optL .round {
	text-align: center;
	min-width: 35px;
	max-width: 35px;
}
#optL .round input {
	text-align: center;
	width: 35px;
}
.nowrap * {
	white-space: nowrap;
}
.groups {
	color: mediumseagreen;
	font-style: italic;
}
.groupSel {
	font-weight: bold;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
.groupDel {
	color: #d51515;
}
.groupPN {
	font-size: 10px;
	vertical-align: middle;
	padding: 3px;
}
.nickDel {
	cursor: pointer;
	text-decoration: underline;
}
.del,.red {
	color: #d51515;
}
.del {
	cursor: pointer;
	text-decoration: underline;
}
.nickGroupAddList {
	margin: 2 2 2 2;
	padding: 4 3 2 3;
	width: 100%;
	font-size: 12px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
.userTypeCh {
	font-weight: bold;
}
.nickDelC {
}
.nickDel {
	color: #d51515;
}
#nicks {
	width: 200px;
}
#nicks .addTxt {
	vertical-align: middle !important;
	text-align: right;
	margin-right: 0px !important;
	padding-right: 0px !important;
	min-width: 90px;
	max-width: 90px;
}
#chat #nicks .addTxt *, #chat #nicks .nicksListTitle * {
	font-size: 10px;
}
#nicks .addVal {
	vertical-align: middle;
	min-width: 100px;
	padding-left: 0px !important;
}
#nicks .addVal {
	vertical-align: middle;
	min-width: 100px;
	padding-left: 0px;
	padding-right: 0px !important;
	margin-right: 0px !important;
}
#chat #nicks .addVal input {
	vertical-align: middle;
	width: 100px;
}
#nicks .addBtn {
	vertical-align: middle !important;
	padding-left: 0px !important;
	margin-left: 0px !important;
}
.nick {
	white-space: nowrap;
	padding: 5 0 5 0;
	display: inline-block;
}
.left {
	text-align: left;
}
.right {
	text-align: right;
}
.leftf {
	float: left;
	clear: none;
}
.rightf {
	float: right;
	clear: none;
}
.center {
	text-align: center;
	margin: 0 auto;
}
.justify {
	text-align: justify;
}
.middle {
	vertical-align: middle;
}
.nobreak {
	white-space: nowrap;
}
.bold {
	font-weight: bold;
}
.lnk, a {
	text-decoration: underline;
	color: mediumseagreen;
	cursor: pointer;
}
input[type="radio"] {
	accent-color: green;
}
.msgText[contenteditable]:focus {
  outline: 0px solid darkgreen;
}
.msgText:hover {
  //background-color: #002500;
  color: white;
}
.heardBy {
	display:block;
	clear: none;
	float: right;
	//min-width: 50%;
	text-align: right;
}
.heardBy * {
	font-size: 10px;
}
.heardBy input {
	width: 10px;
	height: 10px;
}
#prompt {
  padding: 11 7 11 7;
  margin: 0 0 0 0;
  border-width: 1px;
  outline: 0px;
}
#prompt:focus, #prompt:hover,#sys:hover,#sys:focus,#instr:hover,#instr:focus,#rag:hover,#rag:focus {
  background-color: #002500;
  outline: 0px;
}
#sysTitle {
	text-align:left;
	font-size: 12px;
	color: silver;
}
#instTitle {
	float: right;
	clear:none;
	font-size: 12px;
	color: silver;
}
#ragTitle {
	text-align:left;
	font-size: 12px;
	color: silver;
}
#ragC {
	width: 100%;
}
#remembered {
	padding: 5 10 10 10;
}
#ragC table {
	width: 100%;
	text-align: center;
	margin: 0 0 0 0;
	padding: 0 0 0 0;
}
#ragC td {
	width: 100%;
	margin: 10 0 0 0;
	padding: 0 0 0 0;
}
.small {
	font-size: 12px;
}
#howto {
	text-align: justify;
	margin-top: 20px;
}
#help {
	padding: 5 10 10 10;
}
.slide-fade-enter-active {
  transition: all .2s ease;
}
.slide-fade-leave-active {
  transition: all .2s;
}
.slide-fade-enter-from {
  transform: translateY(7px);
  opacity: 0;
}
.slide-fade-leave-to {
  transform: translateY(-7px);
  opacity: 0;
}
.ta-enter-active {
  transition: opacity .35s ease;
}
.ta-leave-active {
  transition: opacity .21s ease;
}
.ta-enter-from {
  opacity: 0;
  color: mediumseagreen;
}
.ta-leave-to {
  opacity: 0;
  color: mediumseagreen;
}
.tokens span,.tokens {
	font-size: 11px;
}
.tokens {
	vertical-align: middle;
}
#sets .headerC {
	padding-top: 7px;
	padding-bottom: 9px;
}
#sets .txt {
	padding: 10 14 10 10;
	background-color: #002500;
	border-radius: 14px;
}
.pre {
	white-space: pre-wrap;
}
#sets .setsRow {
}
#sets .header {
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#sets .header * {
	font-size: 16px;
}
#heading {
	text-align: center;
}
#heading * {
	font-size: 12px;
}
.header {
	font-size: 16px;
	font-color: mediumseagreen;
}
.nickSel * {
}
.nickSel * {
	font-size: 12px;
}
.nickSel input {
	width: 10px;
	height: 10px;
}
.models {
	font-size: 12px;
}
.green {
  color: mediumseagreen;
}
#chat .empty {
	font-size: 10px;
	font-style: italyc;
	vertical-align: middle;
}
#chat .error {
	font-size: 12px;
	font-style: italyc;
	vertical-align: middle;
	color: #d51515;

}
</style>
	</div>
</div>

<script type="module">

import { createApp,reactive,computed,ref,nextTick,inject,provide } from 'vue';


window.app=createApp({
	template:'#tmplChat',
	data() {
		return {
			def:{},
			prompt:	'',
			groups: [],
			group: 0,
			groupAddN: '',
			context: {1:true,2:true,0:false,3:true},
			turns: [
				{
					"role":'root',
					'branch':0,
					'branches':[{msg:0,msgs:[{
							"content":	'',
							"nick":		'',
							"nicks":{},
							"nId":-1,
							an:{}
						}]}],
					'tree':{0:{ 0:0 }},//parent's branch:{selected msg:local branch growing from that msg}
				},
			],
			models: [],
			modelsEmb: [],
			modelsLoading: { done:0,total:0,inited:0 },
			pState: {
				sys:				1,
				instr:			0,
				sets:				0,
				pull: 			0,
				howto: 			0,
				optHelp:		0,
				opt: 				0,
				menu:				1,
				control:		1,
				ragU:				0,
				ragG:				0,
				charNew:		0,
				ragMemGen:	0,
				cardSave	:	0,
			},
			configGroups: {
				ver:		{ name:'Version'									},
				url:		{ name:'Connection settings'			},
				logic:	{ name:'Chat logic features'			},
				stories:{ name:'Stories features'					},
				rag:		{ name:'Memories (rag) features'	},
				rating:	{ name:'Rating features'					},
				design:	{ name:'Design features'					},
				ui:			{ name:'User interface features'	},
				reply:	{ name:'Reply cleaning features'	},
				imgs:		{ name:'Vision features'					},
				ollama:	{ name:'Ollama settings'					},
			},
			configGlobal: {
				version:						{ g:'ver',name:'Version',v:'1.9.10',def:'',d:'UI version, just for information and upgrades','f':'ro',qn:'ver',q:null,opt:false },
				themeWhite:					{ g:'design',name:'Invert colors',v:false,d:"Inverted colors, if you are weird person preferring white backgrounds, you may check this. But it looks scary, beware.",def:false,f:'cb',q:false,qn:'clrs',opt:false},

				raw:								{ g:'logic',name:'Raw mode',v:false,def:false,d:"Raw mode. Don't use it, unless you know what you are doing. The template can be edited in the respective configuration field. Please note: Ollama doesn't support token count api and doesn't cut the log in raw mode, therefore it's impossible to implement proper context size. In other words, once your log is longer than context window, things will break.",f:'cb',q:false,qn:'raw',opt:true },
				rawTmpl:						{ g:'logic',name:'Raw mode template',v:`{{img}}[img-{{imgIndex}}]{{/img}}

{{start}}<|start_header_id|>system<|end_header_id|>\n\n{{sys}}<|eot_id|>{{/start}}

{{user}}<|start_header_id|>user<|end_header_id|>\n\n{{img}}{{msg}}<|eot_id|>\n{{/user}}

{{assistant}}<|start_header_id|>assistant<|end_header_id|>\n\n{{msg}}<|eot_id|>\n{{/assistant}}

{{singleMsgMode}}{{img}}{{msg}}

{{/singleMsgMode}}

{{end}}<|start_header_id|>assistant<|end_header_id|>{{/end}}`,def:'\n{{img}}[img-{{imgIndex}}]{{/img}}\n{{start}}<|start_header_id|>system<|end_header_id|>\n\n{{sys}}<|eot_id|>{{/start}}\n{{user}}<|start_header_id|>user<|end_header_id|>\n\n{{msg}}<|eot_id|>\n{{/user}}\n{{assistant}}<|start_header_id|>assistant<|end_header_id|>\n\n{{msg}}<|eot_id|>\n{{/assistant}}\n{{singleMsgMode}}{{img}}{{msg}}\n\n{{/singleMsgMode}}\n{{end}}<|start_header_id|>assistant<|end_header_id|>{{/end}}',d:`Raw mode template. Template has six parts:
				
{{start}} your start of the template {{/start}}
Text between these will be used at the start of the template. message related variables are not accessible here, as no message is processed yet.

{{user}} your line for every user message {{/user}}
Once start text is inserted, it will loop over each message in the log. The text between these will be inserted for every message originating from a user character. In a single message mode it will wrap all messages joined by singleMsgMode template, in that case previous message data here is empty as it's the "first message" and current user data equals to the "replyTo" data.
				
{{assistant}} for every AI character message {{/assistant}}
Same but for every message originating from an AI character.

{{singleMsgMode}} for every message if single message mode enabled{{/singleMsgMode}}
If you have single message mode enabled in settings (chat logic), all messages are joined into one and then packed into "user" template above. Here you can define how each message will look like within single "user" container. If single message mode is off, it's not used.

{{end}} final part of the template {{/end}}
Once log message is over, this part will finish the template. Current message text is empty, current char data equals to replier, previous message is the last one in the log.

{{img}}[img-{{imgIndex}}]{{/img}}
When you add images they should be attached to a certain message. To do that a template [img-0] is usually used, where 0 is index of the image. For example, in llama.cpp (used by ollama) all the text _before_ [img-N] (down to previous [img-N]) is used as a prefix for the image. Therefore it makes sense to put it into the end of the message. However, there is a thing i believe is a bug, if you have certain symbols in the prefix, like ":", everything is broken. That is why it is easier to put the placeholder into beginning of the message right now. This placeholder will replace the {{img}} in the messages loop. In other parts it is not used. {{imgIndex}} is automatically replaced with the id of the image in array that is sent to the server.'. 

All 6 parts should be there even if some are empty. Please note, certain chat modes add messages to the end of chat log, to additionally instruct your model.

Template variables:

{{replierId}},{{replierName}
Id and name of the ai character that will generate new reply
	
{{replyToUserId}},{{replyToName}},{{replyToText}}
Id, name and text of the message AI will generate a reply to. Depending on the setting "Prevent ReplyTo template to refer to own msg" it might be last message in the chat, or last message in the chat not belonging to the character that will reply.
	
{{replyToTextRaw}}
Same, but without mods (like: "Name:", rating marks, etc), it's message text "as is"
	
{{sys}}
System prompt
	
{{charId}},{{charName}},{{msg}},{{msgRaw}}
Respective data of a particular message in the log that is processed
	
{{charIdPrev}},{{charNamePrev}},{{msgPrev}},{{msgRawPrev}}
Same but for previous message in the log

{{img}}
Replaced by the image template above to attach an image to a message
	
When there is no appropriate data, the value is empty. Variable names case sensitive.

				`,f:'tb',q:false,qn:'rawTmpl',opt:false },
				rawLog:							{ g:'logic',name:'Raw mode log',v:false,def:false,d:"To ease understanding of what's going on, you can enable this to see the template construction steps in the browser console.",f:'cb',q:false,qn:'rawLog',opt:false },

				trinity:						{ g:'logic',name:'Trinity: thinking/action reply mechanism',v:true,def:true,d:"A big problem with regular chats is that model posts thoughts and actions in the same reply and other characters can read these, even when they are not supposed to know the thoughts of another person. Also, often models omit to write their thinking which is the most curious part in replies for me, or they write thinking part but omit the action part. This is the solution to overcome these, coming at a cost of a little slow down in generation. Model is instructed to produce thoughts/feelings and actions separately, then these are stored in a way that other ai characters see only the actions part, while you see all of these. If you switch it off in the middle of a chat, chat log will use the full messages as usually. Please note, usual mode and trinity modes have separate data, so editing in one mode doesn't change data stored in another mode. P.S. It's called trinity because originally i also experimented with separating emotions but it didn't add anything interesting to the chat, so i removed it.",f:'cb',q:true,qn:'3ty',opt:true },
				trinityReqTh:				{ g:'logic',name:'Request to be sent to generate thoughts',v:'Now, in-character of {{replierName}} with above in mind, write only what you think and feel (up to 100 words) about """{{replyToText}}""", nothing else, no comments, no notes, no dialogues, only the thoughts.',def:'Now, in-character of {{replierName}} with above in mind, write only what you think and feel (up to 100 words) about """{{replyToText}}""", nothing else, no comments, no notes, no dialogues, only the thoughts.',d:"This is the instruction sent for model to generate the thinking/feeling reaction towards last text. {{replierName}} is replaced with the name of the character that speaks and {{replyToText}} is replaced with the text of the message it replies to (it's required because otherwise model might be confused what to reply about, considering there might be various instructions injected into chat log)",f:'ta',q:false,qn:'3tyTh',opt:false },
				trinityReqA:				{ g:'logic',name:'Request to be sent to generate actions',v:'Now, {{replierName}}, in-character with your system prompt and with things you said above, react with actions/words (if you will) at """{{replyToText}}""", up to 100 words.',def:'Now, {{replierName}}, in-character with your system prompt and with things you said above, react with actions/words (if you will) at """{{replyToText}}""", up to 100 words.',d:"This is the instruction sent for model to generate the outer reaction towards last text. {{replierName}} is replaced with the name of the character that speaks and {{replyToText}} is replaced with the text of the message it replies to (it's required because otherwise model might be confused what to reply about, considering there might be various instructions injected into chat log)",f:'ta',q:false,qn:'3tyA',opt:false },
				trinityChancesTh:		{ g:'logic',name:'Chances to see thoughts of AI',v:0.5,def:0.5,d:"This sets the chance for model to produce the internal thoughts in addition to actions. Originally i had this at 100% but models repeat things too much, so i got an idea to show their thinking only at times. Number should between 0 and 1. 0 means you will never see the thoughts, 1 means you will always see them. 0.3 means 1/3 of replies will have it. As the chances are random, it's only approximate probability, while even with low chances you may get several thoughtful replies in a line.",f:'',q:false,qn:'3ThCh',opt:true },
				trinityOwCOnOff:		{ g:'logic',name:'On switching off trinity overwrite data with that from trinity',v:false,def:false,d:"If you use trinity generated data is duplicated into non-trinity mode. However, you might edit the replies as you chat, then data in original version is outdated. This will overwrite data in normal mode with everything you have in trinity mode, every time when you disable trinity. Note, reverse process is impossible, so edits in normal mode is not copied to trinity because we don't know what is thoughts and what is action there. It's off by default, because you could use main mode as default one with edits and then switching trinity on/off would erase all of your changes in normal mode.",f:'cb',q:false,qn:'3tyOW',opt:false },
				
				rooms:							{ g:'logic',name:'Use single prompt to send the chat',v:false,def:false,d:"If true, all messages are concatenated and sent to AI as one big prompt, AI will take all the chat as a single input prompt generated by user. If it's off, chat is sent as a set of messages, then AI can see which messages were created by AI and which ones by user. Which one is better depends on the model.",f:'cb',q:false,qn:'sngl',opt:true},
				otherAiAsUser:			{ g:'logic',name:'Other AI personages are "users" for AI',v:true,d:"When multi-message mode is used to send chat log to AI (that is single-message format is off) mark messages of other AI characters as created by the user. If you have 3 personages, only the current character's messages are marked for AI as AI generated ones. Experimental thing, i think the reaction will be model dependant.",def:true,f:'cb',q:false,qn:'ai usr',opt:true},
				sysNick:						{ g:'logic',name:'System nick instructing model',v:'World',d:"Sometimes we inject special messages into the stuff sent to AI. For example, rating instructions. To do that we need to have some name of the user sending it. We could do it on behalf of AI but it's less flexible. This is the nick of that 'special person' that injects hidden messages for AI.",def:'World', f:'',q:false,qn:'s-nick',opt:false },
				noAiReplyToSelf:		{ g:'logic',name:'Prevent replying of ai to self',v:true,d:"Sometimes it may happen that last message belongs to ai and you expect it to write more. If you just send an empty message, and before that there was always strict order of user/ai turns, AI will try to keep the pattern and reply on behalf of a user, ignoring its system prompt. If you have 'instruction' or 'trinity' it has way less chances to happen as there are additional messages instructing AI how to reply. But if you don't have these, it might be very irritating. To fix that, this will add a message from the system user 'World', it will ask model to continue in accordance with the system prompt. Then Ai will answer for itself with a much higher chances.",def:true,f:'cb',q:false,qn:'aiNoSlfRp',opt:true },
				noReplyToSelf:			{ g:'logic',name:'Prevent ReplyTo template to refer to own msg',d:"Templating in trinity and raw modes has 'ReplyTo' placeholder which refers to last message in the log. But sometimes it might be the own message of an AI, to prevent AI to react to its own last message, mark this. Then it will search for last message belonging to someone else and use it as 'ReplyTo' content. If there is none, it will be empty.",def:true,f:'cb',q:false,qn:'rpToNoSlf',opt:true },
				namesAdd:						{ g:'logic',name:'Add names',v:true,def:true,d:"If you have more than one character talking, the model can not understand well which of the messages belong to itself and which are not, despite the system prompt. To fix this, each message gets a name prefix before being sent to the model. Usually it produces much more adequate behavior during chats, even with 1 character. If you don't need that, you can switch it off here.",f:'cb',q:false,qn:'nmAdd',opt:true },
				emptyToSth:					{ g:'logic',name:'Replace empty messages with text',v:false,def:false,d:"If you just hit enter, it creates an empty message. By default it will be ignored and not sent, however with this 'on' empty message internally will be converted into some text, like 'Continue'. You can specify it in the settings as well.",f:'cb',q:false,qn:'emp2Sth',opt:true },
				emptyToTxt:					{ g:'logic',name:'Text to replace empty messages with',v:'Continue',def:'Continue',d:"If you just hit enter, it creates an empty message. By default it will be ignored and not sent, however if you have 'Replace empty message with text' setting on, it will replace it with this text internally. Original log is unchanged, so every time you change this, all empty messages will get new content within new request.",f:'',q:false,qn:'emp2Txt',opt:false },

				//didn't work well, hidden
				aiIsYou:						{ g:'logic',name:'Ai is named "You"',v:false,def:false,d:"If Ai character changes name during the story, it confuses model. This will always you 'You' as model's name, which should help model to undersand which messages belong to it, despite the changes in name of its character.",f:'cb',q:false,qn:'aiYou',opt:true,hidden:true },

				stories:						{ g:'stories',name:'Stories: separate context memory per character',v:false,d:"In all of the other UI i know (on the moment of writing this) characters see all of the chat history. I came up with a new idea, with this feature every personage can have each own context within the chat. For example, you may talk to a character A and do various things. Then you can introduce character B and that character will not know anything about things you did with character A. Every message is marked with the list of characters that can see it. You define it when you send the message for both your message and AI's one. You can see the 'access list' under every message and change it. The chat log is automatically filtered when you choose your and ai chars for the next messages. You can change the filter mode under the chat log at the right. Obvious usage for this can be: two different stories intersecting at some point, where one group plans something or does something and another doesn't know about it. A classic scenario of talking on the phone. Or when character 'thinks' and you don't want other characters to know these thoughts, you can with one click remove them from the message's access list. In other words, it makes it possible to simulate real stories and there is no more need to persuade AI that it shouldn't be aware of something in the chat log :). It comes at a cost of more complicated interface. I've spent a lot of time, much more than coding, on coming up with this interface, to make it as convenient as possible and intuitive. It's still harder than usual one but i believe it's a good one and trust me, as obvious as it seems when you see it, it wasn't easy to form the idea into UI :). Turning this off will disable all existing limits and all characters will see everything.",def:false,f:'cb',q:false,qn:'strz',opt:true },
				storiesUI:					{ g:'stories',name:'Show stories UI',v:false,d:"Show or hide stories interface without disabling it under the hood. If you wish it to work but don't want to see it all the time, just disable it here. If you turn it on, it will automatically turn on the stories feature as well, to prevent the confusion. Stories feature is separate context per character, every message can have its own list of characters that can 'know/see' it.",def:false,f:'cb',q:true,qn:'strz-ui',opt:false },

				rag:								{ g:'rag',name:'Use memories (rag)',v:'true',d:'You can add unlimited memories to your characters by inserting it into rag field (Shift+F4, Shift+F5) but sometimes it causes repeatitive answers as AI tends to like replying in likeness to that data. Also, you may wish to turn it off if you do not have a second instand of Ollama running, as it would wipe the cache at every usage and getting new replies would be slow. Normally, you need to run second Ollama for embeddings calculations and configure it with URL for embeddings, then it shall work very fast.',def:true,f:'cb',q:true,qn:'rag',opt:true },
				ragUAmount:					{ g:'rag',name:'Number of personal memories (rag lines) to use',v:3,d:"Seaching in the memory of a character (rag) returns all of its content by separate paragraphs (lines) sorted by relevance, but the model can't remember everything, so we can't feed model with all that info. We have to choose only a certain number of top relevant (hopefully) lines found in memories. This value defines how many top relevant memory lines we will feed to the model before it replies.",def:3,f:'',q:false,qn:'ragUAmnt',opt:true },
				ragGAmount:					{ g:'rag',name:'Number of public knowledge (rag lines) to use',v:2,d:"Seaching in a public knowledge (rag) accesible to all characters returns all of its content by separate paragraphs (lines) sorted by relevance, but the model can't remember everything, so we can't feed model with all that info. We have to choose only a certain number of top relevant (hopefully) lines found in knowledge. This value defines how many top relevant lines we will feed to the model before it replies.",def:3,f:'',q:false,qn:'ragGAmnt',opt:true },
				ragMinSmlr:					{ g:'rag',name:'Minimum required similarity value for rag',v:0.45,d:"When you use memories/knowledge (rag) each line of your data stored there is returned with certain index of similarity, that is, how similar it is to your prompt. We return only N top most relevant entries, but even so they might be not relevant at all if memories have just nothing alike. In that case you can filter these off by setting minimal requires similarity level here. I set a default value to 0.45 to filter out most obvious unrelated stuff, but to be honest it can't be predefined as different embedding models have different scales, so you might need to check this yourself by looking at 'Remembered' section of memories panel during your chat. It also depends on how well you write the data for character memories, if you don't have enough generic synonyms there, the relevance will be slow. But in any case, here it is for you to use if needed. If it's empty, it's not used.",def:'0.45',f:'',q:false,qn:'ragMinSmlr',opt:true },
				ragPast:						{ g:'rag',name:'Number of past chat messages for similarity search in memories (rag)',v:2,d:"Using a single message to search in memories is fine with documents but is totally not enough for chats. Imagine your last message is just 'what?!' and nothing is found in rag relevant to that. To fix this, you can set how many last messages are going to be used for searching for something similar. But don't set it high as there is a limit to how much embedding model can make sense of. 2-3 messages is the best, i believe. 2 would mean your prompt + the last message from chat.",def:2,f:'',q:false,qn:'ragpast',opt:true },
				ragShuffle:					{ g:'rag',name:'Shuffle found top memories randomly',v:false,d:"To add randomness you can shuffle found top memories before adding them to AI's 'head'. It may make replies more random but at the cost of longer wait for a side-reply, as model will have to recalculate longer text each time instead of just using cache from the last attempt.",def:true,f:'cb',q:false,qn:'ragShfl',opt:true },

				hideEmptyOwn:				{ g:'ui',name:'Hide own empty replies',v:true,def:1,d:'Hide own empty replies (the ones where you just clicked enter). Setting this to false can be useful if you wish to branch a conversation at a turn of your empty reply. Otherwise these just irritate.','f':'cb',q:true,qn:'no emp',opt:false },
				showEmptyOwnSide:		{ g:'ui',name:'Force show own empty replies when there are side-replies',v:true,def:true,d:`Show own empty replies if there are alternative side-replies available, even if hideEmptyOwn is true. Otherwise you wouldn't be able to see prev/next branches if you've sent an empty message, because there would be no 'crossroads' message shown.`,'f':'ro',opt:false },
				setsQ:							{ g:'ui',name:'Show quick settings',v:true,d:"Shows fields for quick access to settings that you often mayy change. You can configure which one are in the list in settings.",def:true,f:'cb',q:null,opt:false },
				fKeys:							{ g:'ui',name:'Enable F1-F10 keyboard keys for menu',v:true,d:"Allows you to access the bottom menu functions with F1-F10 keys of your keyboard. You can disable it if you don't want to lose 'F5' for page reloading, etc",def:true,f:'cb',q:false,qn:'Fs',opt:false },
				tokensCount:				{ g:'ui',name:'Show token counts reported by ollama',v:false,d:'Show the count of tokens in messages. As it\'s broken in Ollama, disabled by default. Stores tokens per model as these differ.',def:false, f:'cb',q:false,qn:'tkns',opt:false },
				setsDescrShow:			{ g:'ui',name:"Show descriptions for configuration values",v:true,d:"Enables showing descriptions for each parameter below parameter's name, otherwise shows only as a tooltip.",def:true,f:'cb',q:null,opt:false},

				imgsLastOnly:				{ g:'imgs',name:'Send last message images only',v:true,d:"If this is checked, only the images added to your last (current) prompt are sent to AI. Otherwise all images from the chat history are sent. It's implemented as sending all images takes a lot of time for AI to re-evaluate them, also, when you use a single-message mode for the chat, there is no way to embed images into the middle of conversation and they all are perceived as the last ones. To avoid these rakes i've set this to 'true' by default.",def:true,f:'cb',q:false,qn:'imgLast',opt:true },

				emojiNo:						{ g:'reply',name: 'Auto-remove emojis',v:false,def:false,d:"Erase emojis from model's output",f:"cb",q:false,qn:'noemj',opt:false },
				resClean:						{ g:'reply',name:'Auto-clean reply from junk',v:true,d:"Should the reply be auto-cleaned of 'Name: ' and other known garbage.",def:true,f:'cb',q:false,qn:'cln',opt:false },
				resBufCleanSize:		{ g:'reply',name:'Buffer size before printing reply',v:10,d:"Buffer size that should be filled before it starts showing your the reply. It's needed to prevent jerking of the reply when we clean it from the litter of names and other marks.",def:10,f:'',q:null,opt:false },

				bgImg:							{ g:'design',name:'Background image',d:"You can load background image. If you use inverted colors scheme, you've to load an image with inverted colors ;)",def:'',f:'file',q:null,opt:false,unload:true,sess:false,v:'data:image/jpeg;base64,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'},
				bgFixed:						{ g:'design',name:'Fix background image position',v:true,d:"You can make the background image fixed or repeated vertically, as you like more. If this one is disabled, it's repeated. To make image look seemless in this case you can vertically mirror it at stitch to the bottom of your original image.",def:true,f:'cb',q:'bgFix',opt:false},
				msgFontSize:				{ g:'design',name:'Font size of the message text',v:'14px',d:'Font size of the message text. As it modifies the inline style and not the css itself, it might be slow on big chats and slow computers.',def:'14px',f:'',q:null,opt:false},
				taFontSize:					{ g:'design',name:'Font size of the input text areas',v:'14px',d:'Font size of the text in prompt, instr and system prompt text areas.',def:'14px',f:'',q:null,opt:false},
				chatHeight:					{ g:'design',name:'Height of the chat log',v:'',d:"If you prefer a fixed chat log height with a scroller inside, set this to the desired height of your chat log. The valus is in pixels, use only a number, like '300'.",def:'',f:'',q:'logHeigh',opt:false},

				url: 								{	g:'url',name:'URL',v:"http://127.0.0.1:11434",def:'http://127.0.0.1:11434',d:'URL of the Ollama service',q:null,opt:false,sess:true},
				urlEmb: 						{	g:'url',name:'Embeddings instance URL',v:"http://127.0.0.1:11434",def:'http://127.0.0.1:11434',d:"URL of the Ollama service to use for embeddings calculations. It can be the same but in that case every such request clears cache and causes prompt re-evaluation, so caching doesn't work with rag. I recommend running a second instance of Ollama on another port to handle embeddings.",q:null,opt:false,sess:true},

				instrWithSideRating:{ g:'rating',name:'Stil use "instr" for side-replies when side-rating is on ',v:true,d:"Shoud your instruction (instr) be used when you request side-message with rated examples (ctrl+right). Instruction may interefere with the examples as AI gets confused with what you want from it, there are bad examples, good examples and also an instruction for new reply, not mentioning the context. You may switch this off. It has effect only when you request for rated side-replies, otherwise this setting is not used.",def:true, f:'cb',q:false,qn:'s-rate',opt:false },
				badExForSideReply:	{ g:'rating',name:'Use that many -ed side replies for new ones',v:3,d:'When you ask for one more side message from AI clicking ">", you just get a reply generated on the context above. But if you click "ctrl+right", your rated messages are shown to AI as examples. However, showing many negative ones may have the opposite effect as AI just starts copying them. This number defines how many random bad messages from your last turn should be given to AI as an example of how it shouldn\'t talk. Also, setting this high will result in a serious reduction of context window memory. 0 means disable.',def:3,f:'',q:false,qn:'b-ex',opt:false },
				goodExForSideReply:	{ g:'rating',name:'Use that many +ed side replies for new ones',v:3,d:'Same as above, but for messages with good rating. Unlike with bad messages it is ok to have a lot of these but remember it eats the context memory. Unless you have unlimited vram, don\'t set this high. 0 means disabled.',def:3, f:'',q:false,qn:'g-ex',opt:false },
				replyWithRating:		{	g:'rating',name:'Use rating to instruct model',v:true,d:"Should attempt to instruct model to use the existing rated messages as style examples for replies. Some models react well, some do not. If you didn't rate any answers in the current branch, nothing is changed in the prompt, so if you don't use the rating and do not wish to pollute the prompt, no need to switch it off.",def:true, f:'cb',q:false,qn:'rate',opt:true },
			},
			settingsGlobal: {
				options: {
					temperature:		{g:'ollama',v:'',t:'n',def:0.8,d:'The temperature of the model. Increasing the temperature will make the model answer more creatively. (Default: 0.8)',q:true,qn:'temp',opt:true},
					num_ctx:				{g:'ollama',v:'',t:'n',def:2048,d:'Sets the size of the context window used to generate the next token. (Default: 2048)',q:true,qn:'ctx',opt:true},
					top_k:					{g:'ollama',v:'',t:'n',def:40,d:'Reduces the probability of generating nonsense. A higher value (e.g. 100) will give more diverse answers, while a lower value (e.g. 10) will be more conservative. (Default: 40)',q:true,opt:true},
					top_p:					{g:'ollama',v:'',t:'n',def:0.9,d:'Works together with top-k. A higher value (e.g., 0.95) will lead to more diverse text, while a lower value (e.g., 0.5) will generate more focused and conservative text. (Default: 0.9)',q:true,opt:true},
					num_thread:			{g:'ollama',v:'',t:'n',def:'',d:'Sets the number of threads to use during computation. By default, Ollama will detect this for optimal performance. It is recommended to set this value to the number of physical CPU cores your system has (as opposed to the logical number of cores).',q:false,qn:'thr',opt:true},
					repeat_last_n:	{g:'ollama',v:'',t:'n',def:64,d:'Sets how far back for the model to look back to prevent repetition. (Default: 64, 0 = disabled, -1 = num_ctx)',q:true,qn:'rep_l',opt:true},
					repeat_penalty:	{g:'ollama',v:'',t:'n',def:1.1,d:'Sets how strongly to penalize repetitions. A higher value (e.g., 1.5) will penalize repetitions more strongly, while a lower value (e.g., 0.9) will be more lenient. (Default: 1.1)',q:true,qn:'rep_p',opt:true},
					mirostat:				{g:'ollama',v:'',t:'n',def:0,d:'Enable Mirostat sampling for controlling perplexity. (default: 0, 0 = disabled, 1 = Mirostat, 2 = Mirostat 2.0)',q:false,qn:'m-t',opt:true},
					mirostat_eta:		{g:'ollama',v:'',t:'n',def:0.1,d:'Influences how quickly the algorithm responds to feedback from the generated text. A lower learning rate will result in slower adjustments, while a higher learning rate will make the algorithm more responsive. (Default: 0.1)',q:false,qn:'m-eta',opt:true},
					mirostat_tau:		{g:'ollama',v:'',t:'n',def:5,d:'Controls the balance between coherence and diversity of the output. A lower value will result in more focused and coherent text. (Default: 5.0)',q:false,qn:'m-tau',opt:true},
					num_gqa:				{g:'ollama',v:'',t:'n',def:'',d:'The number of GQA groups in the transformer layer. Required for some models, for example it is 8 for llama2:70b',q:false,qn:'gqa',opt:true},
					num_gpu:				{g:'ollama',v:'',t:'n',def:'',d:'The number of layers to send to the GPU(s). On macOS it defaults to 1 to enable metal support, 0 to disable.',q:false,qn:'gpu',opt:true},
					stop:						{g:'ollama',v:[''],t:'as',def:'',d:'Sets the stop sequences to use. When this pattern is encountered the LLM will stop generating text and return. Multiple stop patterns may be set by specifying multiple separate stop parameters in a modelfile. Each input here means one stop match',f:'mis',q:null,opt:false},
					tfs_z:					{g:'ollama',v:'',t:'n',def:1,d:'Tail free sampling is used to reduce the impact of less probable tokens from the output. A higher value (e.g., 2.0) will reduce the impact more, while a value of 1.0 disables this setting. (default: 1)',q:false,opt:true},
					num_predict:		{g:'ollama',v:'',t:'n',def:128,d:'Maximum number of tokens to predict when generating text. (Default: 128, -1 = infinite generation, -2 = fill context)',qn:'prdct',q:false,opt:false},
					seed:						{g:'ollama',v:'',t:'n',def:0,d:'Sets the random number seed to use for generation. Setting this to a specific number will make the model generate the same text for the same prompt. (Default: 0)',qn:'seed',q:false,opt:true},
				},
				req: {
					model:					{g:'ollama',v:{l:computed(()=>this.models),v:''},t:'sel',def:0,d:'Model that will generate the reply',f:'sel',q:true,qn:'mdl',opt:false,sess:'v'},
					keep_alive:			{g:'ollama',v:900,t:'n',def:"300",d:'Time to keep model cached in memory, a number in seconds, any negative number will keep the model loaded in memory, 0 will unload the model immediately after generating a response.',q:false,qn:'k-alv',opt:false},
					modelEmb:				{g:'ollama',v:{l:computed(()=>this.modelsEmb),v:''},t:'sel',def:0,d:'Model that will generate the embeddings for rag search',f:'sel',q:false,qn:'mdl-emb',opt:false,sess:'v'},
				}
			},
			stream:	true,
			nick: {
				s:-1,
				n:{
					u:'',
					a:'',
					s:'',
				}
			},
			amountNicks: { u:0,a:0,t:0,s:1,idNext:0 },
			nicks: {
				'-1':	{	t:'s',n:computed(()=>this.config.sysNick.v),id:'-1'	},
			},
			msgUserListOn:{},
			opt:					{'v':{},model:0,run:false,cancel:false},
			rag:					{},
			turn:					0,
			cancel:				0,
			working:			0,
			workingRag:		0,
			connection: 	0,
			connectionErr:'',
			modelPull: 		'stablelm2',
			mpull: 				[],
			ctrl: 				0,
			log:					0,
			chatHeight:		'300',
			imgs:					[],
			inited:				0,
			branchMoving:	false,
			memNew: {
				working:	0,
				cancel:		0,
				sys:[],
				parts: {},
				sys:[
					{
						sys:`Replies should be strictly in the format: "<memory>generated memory</memory>". Your goal is to create the requested amount of a random yet consistent memories of a given person from the input data. Be creative and deep in psychology. It should be consistent with the data provided. Each memory should include the person's name. Each memory should be phrased in a first person. Each memory should have a lot of synonyms. Each one of the created memories should strictly be in this format: "<memory>generated memory</memory>".`,
						req:[{
							req:'Input data:\n{PARAMS}',
							t:	'Initial request'
						},{
							req:'Ready to generate.',
							t:	`Model's "reply" before specific requests`,
						},{
							req:'Now generate {AMOUNT} memories about: """{TOPIC}""". Consistent with everything above. clearly state the age in each memory. Format should be: "<memory>generated memory</memory>',
							t:	'Topic specific requests'
						}]
					}
				],
			},
			charNew:			{
				step:			0,
				stepShow:	0,
				working:	0,
				cancel:		0,
				u:				null,
				sys:[
					{
						sys:`This is for a computer game plot, so it's okay. You reply in the following strict format only: "<parameter_name>parameter value</parameter_name>".\nYour task is to create a set of new random yet fully consistent parameters defining a new person, combining each and all of the following key personal qualities: {COREPARAMS}.\nParameters to create (you have to do all of the parameters):\n{PARAMS}`,
						req: [{
								req:`please create a new system prompt strictly in the required format. Use these presets: {PARAMS}`,
								t:	"initial request",
							},{
								req:`Please use the data above and generate the following parameters:\n{PARAMS}`,
								t:	"follow up request if something was missing",
							}
						]
					},{
//					sys:`Your goal is to take input data and creatively rewrite it in a free form as a system prompt for the character.\nThe character's personality can vary from evil-terrible to great-saint but should clearly match each and every one of the key qualities defined in the input data.\nTake special care to make sure all of the key qualities are reflected throughout the system prompt you make.\nAs the first line of generated system prompt it should clearly tell "You are: name", throughout the text use second person addressing only.\nSecond paragraph devote to key qualities of the person.\nWhole text should have only factual information from the data provided, nothing else.\nThe size of a resulting text should be around 10000 symbols.\nIn the end of system prompt make up a description of character's psychological conflict in character's psyche using the contradictions in input data.\nBe sure to use each and every detail from the input data precisely.\nPlease put the whole resulting system prompt into "<prompt></prompt>" tag.`,
						sys:`Your goal is to take input data and creatively rewrite it in a free form as a system prompt for the person.\nThe person's personality can vary from evil-terrible to great-saint but should clearly match each and every one of the key qualities defined in the input data.\nTake special care to make sure all of the key qualities are reflected throughout the system prompt you make.\nAs the first line of generated system prompt it should clearly tell "You are: name", throughout the text use second person addressing.\nSecond paragraph devote to key qualities of the person.\nWhole text should have only factual information from the data provided, nothing else.\nThe size of a resulting text should be around 10000 symbols.\nIn the end of system prompt make up a description of person's psychological conflict in person's psyche using the contradictions in input data.\nBe sure to use each and every detail from the input data precisely.\nPlease put the whole resulting system prompt into "<prompt></prompt>" tag.`,
						req:[{
							req:'Key qualities: {COREPARAMS}\nOther parameters:\n{PARAMS}',
							t:	'Initial request'
						}],
					},{
						sys:`Replies should be strictly in the format: "<memory>generated memory</memory>". Your goal is to create the requested amount of a random yet consistent memories of a given person from the input data. Be creative and deep in psychology. It should be consistent with the data provided. Each memory should include the person's name. Each memory should be phrased in a first person. Each memory should have a lot of synonyms. Each one of the created memories should strictly be in this format: "<memory>generated memory</memory>".`,
						req:[{
							req:'Input data:\n{PARAMS}',
							t:	'Initial request'
						},{
							req:'Ready to generate.',
							t:	`Model's "reply" before specific requests`,
						},{
							req:'Now generate {AMOUNT} memories about: """{TOPIC}""". Consistent with everything above. clearly state the age in each memory. Format should be: "<memory>generated memory</memory>',
							t:	'Topic specific requests'
						}]
					}
				],
				parts: {},
				paramsDef: {
					epoch:						{ph:'Future intergalactict empire'},
					location:					{ph:'Holy feline empire'},
					name:							{ph:''},
					race:							{ph:'Cat daemons'},
					ethnicity:				{ph:'Siamese'},
					gender:						{ph:''},
					age:							{ph:'888'},
					face:							{ph:''},
					look:							{ph:''},
					voice:						{ph:''},
					height:						{ph:''},
					weight:						{ph:''},
					hobby:						{ph:''},
					habits:						{ph:''},
					relationships:		{ph:''},
					character:				{ph:''},
					psychotype:				{ph:''},
					temperament:			{ph:''},
					dreams:						{ph:''},
					fears:						{ph:''},
					likes:						{ph:''},
					dislikes:					{ph:''},
					preferences:			{ph:''},
					'current attire':	{ph:''},
					'specific gestures':	{ph:''},
					belongings:						{ph:''},
					'other details':			{ph:''},
				},
				paramsCore: [
					{n:'postive',pnl:'toxic',pnr:'charming',min:0,max:11,v:0,p:'',b:'',vp:'',vh:''},
					{n:'constructive',pnl:'destructive',pnr:'constructive',min:0,max:11,v:0,p:'',b:'',vp:'',vh:''},
					{n:'honest',pnl:'lying/deceitful/lieful',pnr:'honest',min:0,max:11,v:0,p:'',b:'',vp:'',vh:''},
				]
			},
			cardSave: { nicks:{},msgs:[this.cardSaveMsgsTmpl()],loading:false }
		}
	},
	computed: {
		config() {
			const u=this.userS('a');
			if(u==null) return this.configGlobal;
			if(this.nicks[u].sets) return this.nicks[u].config;
			return this.configGlobal;
		},
		settings() {
			const u=this.userS('a');
			if(u==null) return this.settingsGlobal;
			if(this.nicks[u].sets) return this.nicks[u].settings;
			return this.settingsGlobal;
		},
		branchac() {
			return this.turns[this.turn].branches[this.branch(this.turn)];
		},
	},
	created() {
		window.addEventListener('beforeunload',this.close);
	},
	mounted() {
		(async()=>{
			this.w('mounting');
			this.inited=2;

			this.charNew.parts=this.charNewTmpl(this.charNew),
			this.memNew.parts	=this.memNewTmpl(this.memNew),

			this.groupAdd('Every1',[]);

			await this.userAdd('u','User',{});
			await this.userAdd('a','AI',{});
			await this.userAdd('u','World',{});

			this.groupAdd('1st set',[0,1,2]);
			this.group=1;

			for(const k in this.settings.options) {
				if(!this.settings.options[k].hasOwnProperty('name')) this.settings.options[k]["name"]=k;
			}
			for(const k in this.settings.req) {
				if(!this.settings.req[k].hasOwnProperty('name')) this.settings.req[k]["name"]=k;
			}

			this.rag['g']=this.ragStrct();
			for(const u in this.nicks) {
				this.rag[u]=this.ragStrct();
			}

			this.bgSet(this.config.bgImg.v);
			this.bgFix(this.config.bgFixed.v);

			this.charCreateReset(this.charNew);

			let def={};
			for(const k in this.$data) {
				this.copy(this.$data,def,k);
			} this.def=def;
			
			this.sessLoad();
			this.urlTest().then(res=>{
				this.inited=1;
			});

			window.addEventListener("keyup",(event)=>{
				this.ctrl=((event.ctrlKey||event.metaKey)?this.ctrl:0);
			});
			window.addEventListener("keydown",(event)=>{
				if(this.opt.run) return;
				
				this.ctrl=((event.ctrlKey||event.metaKey)?1:0);
				
				const k=event.keyCode;
				this.w(`keycode detected: ${k}`);

				if(this.config.fKeys.v&&k>=112&&k<122) { //>
					if(!event.shiftKey) {
						if			(k===112) { this.pToggle('howto') 	}
						else if (k===113) { this.save() 						}
						else if (k===114) { this.click('loadlabel')	}
						else if (k===115) { this.pToggle('sys') 		}
						else if (k===116) { this.pToggle('instr') 	}
						else if (k===117) { this.list() 						}
						else if (k===118) { this.pToggle('pull')		} 
						else if (k===119) { this.prune() 						} 
						else if (k===120) { this.pToggle('sets') 		} 
						else if (k===121) {
							this.quit()
						}
					} else {
						if			(k===120) { this.optToggle() 						}
						else if (k===113) { this.cardSaveToggle() 			}
						else if (k===114) { this.click('loadcard')			}
						else if (k===115) { this.pToggle('ragG') 				}
						else if (k===116) { this.pToggle('ragU') 				}
						else if (k===118) { this.pToggle("charNew")			}
						else if (k===119) { this.clear() 								}
					}
					event.preventDefault();
					return;
				}
			
				if(k==27&&this.working==1) {
					this.cancel=1;
					if(this.charNew.working==1) this.charNew.cancel=1;
					if(this.memNew.working==1) 	this.memNew.cancel=1;
					return;
				}

				if((document.activeElement.tagName=='TEXTAREA'&&document.activeElement.value.length)||this.turn===0) return;
				if(document.activeElement.tagName=='INPUT') {
					return;
				}

				if(document.activeElement.className.includes('msgText')) {
					if(event.key==='Enter'&&!event.shiftKey) {
						document.activeElement.blur();
					}
					return;
				}

				if(k==38) {
					this.turnUp();
					return;
				} else if(k==40) {
					this.turnDown(event.shiftKey?1:0);
					return;
				}

				if(k===39) {
					this.listmsgs(1,this.turn,this.msga(this.turn));
				} else if (k===37) {
					this.listmsgs(0,this.turn,this.msga(this.turn));
				}
				if(k===46) {
					this.msgDelNext(...this.tbma(this.turn));
				}
			});
			
			this.w('mounted')
		})();
	},
	provide() {
		return {
			config: this.config,
			nicks: this.nicks,
			groups: this.groups,
			nick: this.nick,
			group: this.group,
			amountNicks: this.amountNicks,
		}
	},
	watch: {
		'config.themeWhite.v'(v) {
			if(v) {
				document.getElementById('html').style.filter='invert(100%) hue-rotate(180deg)';
			} else {
				document.getElementById('html').style.filter='invert(0%) hue-rotate(0deg)';
			}
		},
		'settings.req.model.v.v'(v) {
			this.w(`changed model ${v}, updating defs in settings`);
			if(!this.models.length) return;
			if(this.models[v].ctx) {
				this.settings.options.num_ctx.def=`${this.models[v].ctx} in modelfile for ${this.models[v].n}`;
			} else {
				this.settings.options.num_ctx.def='2048';
			}
		},
		'settings.options.stop.v': {
			handler(v) {
				if(!v) return;
				if(v[v.length-1]!=='') v.push('')
				for(let i=0;i<(v.length-1);i++) { //>
					if(v[i]==='') {
						v.splice(i,1);
						i--;
					}
				}
			},
			deep:true,
		},
		'ctrl'(v) {
			this.w(`ctrl: ${v}`);
		},
		'context': {
			handler (v) {
				//this.turnLastFilteredGo();
			},
			deep:true
		},
		'config.stories.v'(v) {
			this.config.storiesUI.v=v;
		},
		'config.storiesUI.v'(v) {
			if(v) this.config.stories.v=v;
		},
		'config.bgImg.v'(v) {
			this.bgSet(v);
		},
		'config.bgFixed.v'(v) {
			this.bgFix(v);
		},
		'config.urlEmb.v'(v) {
			this.w('updating rag status as emb url changed');
			this.embed('test');
		},
		'charNew.parts.mem.custom': {
			handler(v) {
				if(!v) return;
				if(v[v.length-1].v.length!=0) v.push({q:1,v:'',c:''});
				for(let i=0;i<(v.length-1);i++) { //>
					v[i].q=(v[i].q+'').trim(); if(!/^(?:\d{1,4}|)$/.test(v[i].q)) v[i].q=1;
					if(v[i].v==='') this.memSetsDel(this.charNew,i);
				}
				this.memCount(this.charNew.parts);
			},
			deep:true,
		},
		'charNew.parts.params': {
			handler(v) {
				if(!v) return;
				if(v.length==0||v[v.length-1].n.length!=0) v.push({n:'',nph:'new custom param',ph:'desired val or empty for random',v:'',c:'',memq:'',memt:''});
				const rgname	=new RegExp('^\s*name\s*$','i');

				for(let i=0;i<(v.length-1);i++) { //>
					if(v[i].n==='') v.splice(i,1);
					const p=v[i];
					p.memq=(p.memq+'').trim(); if(!/^(?:\d{1,4}|)$/.test(p.memq)) p.memq=1;
					if(p.memq!=''&&p.memq>0&&p.c.length) {
						p.memt=`${p.n}: ${p.c}`;
					} else {
						p.memt='';
					}
					if(rgname.test(p.n)) {
						//this.w(`found name param: ${p.c}`);
						this.charNew.parts.name=v[i];
					}
				}
				this.memCount(this.charNew.parts);
			},
			deep:true,
		},
		'memNew.parts.mem.custom': {
			handler(v) {
				if(!v) return;
				if(v[v.length-1].v.length!=0) v.push({q:1,v:'',c:''});
				for(let i=0;i<(v.length-1);i++) { //>
					if(v[i].v==='') this.memSetsDel(this.memNew,i);
					v[i].q=(v[i].q+'').trim(); if(!/^(?:\d{1,4}|)$/.test(v[i].q)) v[i].q=1;
				}
				this.memCount(this.memNew.parts);
			},
			deep:true,
		},
		'cardSave.msgs': {
			handler(v) {
				if(!v) return;
				if(v[v.length-1].content.length!=0) v.push(this.cardSaveMsgsTmpl());
				for(let i=0;i<(v.length-1);i++) { //>
					if(v[i].content==='') v.splice(i,1);
				}
			},
			deep:true,
		},
		'config.trinity.v'(v) {
			if(!v&&this.config.trinityOwCOnOff.v) {
				this.w('Overwriting data with trinity stuff');
				for(const t of this.turns) {
					for(const b of t.branches) {
						for(const m of b.msgs) {
							this.msgContentSet(m,false,this.msgContent(m,true,-1),false);
						}
					}
				}
			}
		}
	},
	methods: {
		tbmId(t,b,m) {
			return `${t}_${b}_${m}`;
		},
		msgRole(m) {
			//this.w({msgRole:m});
			return this.nicks[m.nId].t;
		},
		cardSaveMsgsTmpl() {
			return {content:'',u:''};
		},
		cardSaveToggle(u) {
			this.pToggle('cardSave');
		},
		cardSaveDo() {
			this.w({cardSave:this.cardSave});
			let card={ver:0.1,type:'card',chars:[],msgs:[]},name='card.';
			for(const u in this.cardSave.nicks) {
				let tmp={};
				tmp.id		=u;
				tmp.n			=this.nicks[u].n;
				tmp.t			=this.nicks[u].t;
				tmp.system=this.nicks[u].system;
				tmp.instr	=this.nicks[u].instr;
				tmp.mem		=this.rag[u].t;
				tmp.knlg	=this.rag.g.t;
				card.chars.push(tmp);
				name+=tmp.n+'-';
			}
			if(!card.chars.length) return;
			for(const m of this.cardSave.msgs) {
				if(!m.content.length||m.u==='') continue;
				this.w({p:this.cardSave.nicks.hasOwnProperty(m.u),n:this.cardSave.nicks[m.u]});
				if(!this.cardSave.nicks.hasOwnProperty(m.u)||!this.cardSave.nicks[m.u]) continue;
				card.msgs.push({content:m.content,nId:m.u});
			}
			
			name=name.slice(0,-1);
			this.w({SavingCard:card});
			this.saveDl(card,name);
		},
		async cardLoad(d) {
			this.w({loadedCard:d});
			this.cardSave.loading=true;
			try {
				d=JSON.parse(atob(d.replace(/^data:\w+\/\w+;base64,/,'')));
			} catch(e) {
				this.w(`couldn't parse card ${e}`);
				alert(`Couldn't parse card.\n${e}`);
				this.cardSave.loading=false;
				return;
			}
			this.w({card:d});
			if(d.type!='card') {
				alert("It's not a card");
				this.cardSave.loading=false;
				return;
			}
			const pbak=this.pState.sysinstr;
			this.pState.sysinstr=false;
			let ids={};
			for(const u of d.chars) {
				if(u.t!='a'&&u.t!='u') continue;
				if(u.n.length			>32)					continue;
				if(u.system.length>1024*100)		continue;
				if(u.instr.length	>1024*100)		continue;
				if(u.mem.length		>1024*10000)	continue;
				if(u.knlg.length	>1024*10000)	continue;
				let id=await this.userAdd(u.t,u.n,{system:u.system,instr:u.instr,mem:u.mem,knlg:u.knlg});
				this.userGroupAdd(this.group,id);
				ids[u.id]=id;
			}

			if(d.msgs.length) {
				this.turn=0;
				for(let mey=0;mey<d.msgs.length;mey++) { //>
					const m	=d.msgs[mey];
					if(!ids.hasOwnProperty(m.nId)) {
						this.w('Error: for some reason messag links to a non-existing user');
						continue;
					}
					const u	=ids[m.nId];
					const ut=this.nicks[u].t;
					const un=(d.msgs.length-1)>mey?ids[d.msgs[mey+1].nId]:null;

					if((this.turns.length-1)<=this.turn) { //>
						this.turnnew(this.turn,u,this.group);
						let b=this.brancha(this.turn);
						b.msgs[b.msg]=this.msgTmpl(u,m.content,this.group);
					} else {
						this.turn++;
						this.msgNew(this.turn,u,un,m.content,this.group);
					}
					this.msgaStatusSet(this.turn,'done');
				}
				this.branchu(this.turn);
			}
			this.cardSave.loading=false;
		},
		sessLoad() {
			let sess=localStorage.getItem('sess');
			this.w({load_session:sess});
			try {
				sess=JSON.parse(sess);
				this.w({loaded_session:sess});
				if(sess==null) return;
				for(const s in sess) {
					for(const p in sess[s]) {
						this.sessRestoreParam(sess,s,p);
					}
				}
			} catch(e) {
				this.w(`couldn't parse session ${e}`);
			}
		},
		sessRestoreParam(sess,s,p) {
			let l={
				cfg:	this.configGlobal,
				opt:	this.settingsGlobal.options,
				req:	this.settingsGlobal.req,
				root:	this.$data
			};
			this.w(`sess restore ${s} ${p}: ${sess[s][p]}`);
			if(s==='root') {
				l[s][p]=sess[s][p];
			} else if(!l[s][p].sess) {
				return;
			} else if(l[s][p].sess==='v') {
				l[s][p].v.v=sess[s][p];
			} else {
				l[s][p].v=sess[s][p];
			}
			this.w({sess_restored:l[s]});
			//if(typeof o[p].v==="object") { o[p].v.v=sess } else { o[p].v=sess }
		},
		sessStoreParam(sess,o,p) {
			if(!o[p].sess) return;
			//const v=o[p].v;
			//sess[p]=(typeof v==="object")?v.v:v;
			if(o[p].sess==='v') {
				sess[p]=o[p].v.v;
			} else {
				sess[p]=o[p].v;
			}
		},
		sessSave() {
			if(this.inited!=1) return;
			let sess={};
			let store=[
				{ l:this.configGlobal,p:'cfg' },
				{ l:this.settingsGlobal.options,p:'opt' },
				{ l:this.settingsGlobal.req,p:'req' }
			];
			for(const s of store) {
				sess[s.p]={};
				for(const p in s.l) {
					this.sessStoreParam(sess[s.p],s.l,p);
				}
			}

			sess['root']={};
			for(let s of ['models','modelsEmb']) {
				(sess.root[s]=this[s]);
			}
			
			this.w({sessStore:sess});

			localStorage.setItem('sess',JSON.stringify(sess));
		},
		close() {
			this.sessSave();
		},
		delAtWork(o) {
			if(o.working) {
				alert("Can't do while working");
				return 0;
			}
			return 1;
		},
		charNewSystemReset(o,id) {
			if(!this.delAtWork(o)) return;
			o.parts.system[id].sys=o.sys[id].sys;
		},
		charNewReqReset(o,id,rid) {
			if(!this.delAtWork(o)) return;
			o.parts.system[id].req[rid].req=o.sys[id].req[rid].req;
		},
		memSetsDel(o,id) {
			if(!this.delAtWork(o)) return;
			o.parts.mem.custom.splice(id,1);
		},
		memParsedDel(o,id) {
			if(!this.delAtWork(o)) return;
			o.parts.m.splice(id,1);
		},
		memGenParsedReset(o,f) {
			if(!f&&!this.delAtWork(o)) return;
			o.parts.m		=[];
			o.parts.tmp	=this.msgTmpl('-1',null,0);
		},
		charNewParamsDel(p) {
			if(!this.delAtWork(this.charNew)) return;
			if(this.charNew.parts.params[p].n=='name'&&!confirm(`Are you sure you wish to delete "name" parameter? Its value is used as the name in system prompt, in memories and at adding generated character to the system. If you delete it, system prompt will get something strange as name and the rest will use an empty value.`)) return;
			this.charNew.parts.params.splice(p,1);
		},
		async charCreateAuto() {
			if(this.working||this.charNew.working) return;
			this.charNew.parts.auto.working=this.charNew.working=this.working=1;
			this.charNew.parts.auto.amount=(this.charNew.parts.auto.amount+'').trim();
			if(!/^\d{1,4}$/.test(this.charNew.parts.auto.amount)) this.charNew.parts.auto.amount=1;
			this.w(`starting doing: ${this.charNew.parts.auto.amount} characters`);
			for(let i=1;i<=this.charNew.parts.auto.amount;i++) { //>
				this.charNew.parts.auto.at=i;
				if(this.charNew.cancel) break;
				this.w(`doing char: ${i}`);
				this.charNew.stepShow=this.charNew.step=0;
				for(let k=0;k<=3;k++) { //>
					if(this.charNew.cancel) break;
					this.w(`doing char ${i}, step: ${k}`);
 					await this.charCreateDo(k);
					this.scroll('charNew',1);
					this.charNew.stepShow=this.charNew.step;
				}
			}
			this.charNew.parts.auto.at=0;
			//this.pToggle('charNew');
			this.charNew.parts.auto.working=this.charNew.working=this.working=this.cancel=this.charNew.cancel=0;
		},
		async charCreate(m) {
			if(this.working||this.charNew.working) return;
			this.charNew.working=this.working=1;
			
			await this.charCreateDo(m);
			
			//this.charNew.stepShow=this.charNew.step;
			this.charNew.working=this.working=this.cancel=this.charNew.cancel=0;
		},
		async charCreateDo(m) {
			let ms=[],req='';
			let rgparams	=new RegExp('\{PARAMS\}','si');
			let rgcparams	=new RegExp('\{COREPARAMS\}','si');
			let aid=this.userS('a');
			
			this.charNew.stepShow=this.charNew.step=m+1;
			
			if(m==0) {
				this.w("first step of character creation");
				for(const p of this.charNew.parts.params) {
					p.c='';p.memt='';
				}
				for(const p of this.charNew.parts.paramsCore) {
					this.charNewCoreParamCh(p);
				}
				
				let ps='',xmpl='',sys,paramsCount=0;
				
				let rgcv=this.charNewCoreParams2p();
				for(const r of rgcv) {
					ps+=`<${r.p}>${r.vh} ${r.p}</${r.p}>`;
				}
				
				for(let i of this.charNew.parts.params) {
					if(i.n===''||i.n==null) continue;
					this.w(`checking param ${i.n}`);
					paramsCount++;
					xmpl+=`<${i.n}>${i.n} value</${i.n}>\n`;
					if(i.v==='') continue;
					ps+=`<${i.n}>${i.v}</${i.n}>\n`;
				}
				
				if(!paramsCount) {
					alert('You have to define at least 1 parameter to generate');
					this.charNew.step=0;
				} else {
					this.w(`presets: ${ps}`);
					sys=this.charNew.parts.system[0].sys.replace(rgparams,xmpl).replace(rgcparams,rgcv.map(c=>`"${c.vh}"`).join(", "));
					req=this.charNew.parts.system[0].req[0].req.replace(rgparams,ps);

					this.charNew.parts.tmp=this.msgTmpl('-1',null,0);
					
					this.chatFinalPush(ms,{
						nId:			-1,
						nick:			this.nicks[-1].n,
						content:	req,
						rating:		'',
						images:		[],
					});					
					
					let i=0;
					while(i++<=10)  { //>
						if(this.charNew.cancel==1) break;

						await this.chatSend({
							msg:				this.charNew.parts.tmp,
							finalTurn:	ms.length-1,
							final:			ms,
							extra:			[false],
							sys:				sys,
							rooms:			false,
							raw:				false,
							func:				this.charNewParse,
							d:					null,
							nicks:			this.chatMsNicks({aId:-1,uId:-1}),
						});
						//if(i<3) this.charNew.parts.params[i].c='';
						let parsedCount=0,parseds='',ready={};req='';
						for(const p of this.charNew.parts.params) {
							if(p.n==null||p.n==='') continue;
							this.w(`checking param ${p.n}..`);
							if(p.c!=null&&p.c.length>0) {
								parsedCount++;
								this.w(`..found`);
								if(!ready[p.n]) parseds+=`<${p.n}>${p.c}</${p.n}>\n`;
								ready[p.n]=1;
							} else {
								this.w(`..absent`);
								req+=`<${p.n}>generated value</${p.n}>\n`;
							}
						}
						if(!Object.keys(ready).length) continue;

						this.chatFinalPush(ms,{
							nId:			aid,
							nick:			this.nicks[aid].n,
							content:	parseds,
							rating:		'',
							images:		[],
						});
						
						if(parsedCount==paramsCount) break;
						req=this.charNew.parts.system[0].req[1].req.replace(rgparams,req);
						this.chatFinalPush(ms,{
							nId:			-1,
							nick:			this.nicks[-1].n,
							content:	req,
							rating:		'',
							images:		[],
						});
					}
					
					this.charNew.step=2;
				}
			} else if(m==1) {
				let paramsCount=0,kq='',ps='';

				let rgcv=this.charNewCoreParams2p();
				this.w({ranges:rgcv});
				kq=rgcv.map(c=>`"${c.vh}"`).join(", ");
				
				for(const p of this.charNew.parts.params) {
					if(p.n==null||p.n===''||p.c==='') continue;
					ps+=` ${p.n}: ${p.c}\n`;
					paramsCount++;
				}
				this.w(`found ${paramsCount} parameters`);
				
				if(!paramsCount) {
					alert('You have to define at least 1 parameter to generate');
					this.charNew.step=0;
				} else {
					this.charNew.parts.sysKq	='';
					this.charNew.parts.sys		='';
					this.charNew.parts.tmp		=this.msgTmpl('-1',null,0);
					
					this.chatFinalPush(ms,{
						nId:			-1,
						nick:			this.nicks[-1].n,
						content:	this.charNew.parts.system[1].req[0].req.replace(rgcparams,kq).replace(rgparams,ps),
						rating:		'',
						images:		[],
					});					
					
					let i=0;
					const rgsys=new RegExp(`<prompt>([^<]+?)</prompt>`,'si');
					while(i++<10) { //>
						if(this.charNew.cancel==1) break;
						await this.chatSend({
							msg:				this.charNew.parts.tmp,
							finalTurn:	ms.length-1,
							final:			ms,
							extra:			[false],
							sys:				this.charNew.parts.system[1].sys,
							rooms:			false,
							raw:				false,
							func:				null,
							d:					null,
							nicks:			this.chatMsNicks({aId:-1,uId:-1}),
						});
						this.w(`got system prompt reply: ${this.charNew.parts.tmp.content}`);
						const tmp=rgsys.exec(this.charNew.parts.tmp.content);
						if(!tmp||!tmp[1]||tmp[1].trim().length<1000) continue; //>
						this.charNew.parts.sys=tmp[1].trim();
						this.w(`got parsed system prompt: ${this.charNew.parts.sys}`);
						break;
					}

					i=1; this.charNew.parts.sysKq=`Your key qualities:\n${rgcv.map(c=>` ${i++}. ${c.vh}`).join("\n")}\n\n`;
					
					if(this.charNew.parts.sys.length) {
						//this.charNew.parts.sys=`Your key qualities:\n${rgcv.map(c=>` ${i++}. ${c.vh}`).join("\n")}\n\n${this.charNew.parts.sys}\n\n`;
						this.charNew.parts.sys=`${this.charNew.parts.sys}\n\n`;
						this.charNew.parts.sys+=`Specific details of ${this.charNew.parts.name.c}:\n`+this.charNew.parts.params.filter(p=>p.n!=null&&p.n!='').map(p=>` ${p.n}: ${p.c}`).join('\n');
						this.charNew.step=3;
					}
				}
			} else if(m==2) {
				this.charNew.parts.tmp=this.msgTmpl('-1',null,0);
				
				await this.memGen(this.charNew,this.charNew.parts.system[2],this.charNew.parts.sys);
				
				this.w({memories:this.charNew.parts.m});
				
				this.charNew.step=4;
			} else if(m==3) {
				const id=await this.userAdd('a',(this.charNew.parts.name.c??''),{
					system: this.charNew.parts.sysPre+this.charNew.parts.sysKq+this.charNew.parts.sys,
				});
				this.charNew.parts.copy.sysPrompt=1;
				
				this.charNew.parts.u=id;
				this.charNew.parts.copy.userAdd=id;
				
				this.userGroupAdd(this.group,id);
				this.charNew.parts.copy.add2group=1;
				
				this.groups[this.group].sel.a=id;
				this.charNew.parts.copy.select=1;

				await this.memGen2rag(this.charNew,id);
				this.charNew.parts.copy.embedding=1;

				this.charNew.step=5;
				this.charNew.stepShow=5;
			}
			
			if(this.charNew.step<3) { //>
				this.charNew.parts.sysKq	='';
				this.charNew.parts.sys		='';
			}
			if(this.charNew.step<4) { //>
				this.charNew.parts.m2do=[];
				this.charNew.parts.m=[];
			}
			if(this.charNew.step<5) { //>
				this.charNew.parts.u=null;
				this.charNew.parts.copy={};
			}
			
			this.charNew.parts.tmp='';
		},
		charNewCoreParamCh(r) {
			this.charNewCoreParamsCalc(r);
		},
		charNewCoreParamsCalc(r) {
			let p2w={
				100:'ultimately, totally',
				80:'most of the time',
				60:'very much, casually',
				40:'occasionaly',
				20:'rarely, a bit',
			},l={};r.c=r.v;
			if(r.c==0) {
				r.c=this.rand(1,11);
				this.w(`setting ${r.n} to random val: ${r.c}`);
			}
			if(r.c>6) {
				r.b	=1;
				r.p	=r.pnr;
				r.vp=(r.c-6)*20;
				r.vh=`${p2w[r.vp]} ${r.p} person`;;
			} else if (r.c<6) { //>
				r.b	=-1;
				r.p	=r.pnl;
				r.vp=(6-r.c)*20;
				r.vh=`${p2w[r.vp]} ${r.p} person`;
			} else {
				r.b	=0;
				r.p	=`${r.pnl}-${r.pnr}`;
				r.vp=0;
				r.vh=`not ${r.pnl} nor ${r.pnr} person`;
			}
			this.w({coreparamcalc:r});
			return r;
		},
		charNewCoreParams2p() {
			let rgcv=[...this.charNew.parts.paramsCore];
			rgcv.sort((a,b)=>(a.b>b.b?1:-1));
			this.w({rgcv:rgcv});
			return rgcv;
		},
		charCreateReset(o,m) {
			this.w('create reset');
			if(!this.delAtWork(o)) return;
			
			if(m&&!confirm("Are you sure you wish to delete all data in the current generation?")) return;
			this.w({'resetting charNew':o});
			o.step			=0;
			o.stepShow	=0;
			o.parts			=this.charNewTmpl(o);
			for(const k in o.paramsDef) {
				//this.w(`copy params ${k}`);
				o.parts.params.push({
					n:	k,
					ph:	o.paramsDef[k].ph,
					h:	o.paramsDef[k].h,
					v:	'',
					c:	'',
					memq: '',
					memt: ''
				});
			}
			for(const k in o.paramsCore) {
				//this.w(`copy core params ${k}`);
				this.copy(o.paramsCore,o.parts.paramsCore,k);
			}
		},
		charNewTmpl(o) {
			const mt=[
				{q:5,t:'good childhood memories'},
				{q:5,t:'bad childhood memories'},
				{q:5,t:'memories of last years'}
			];
			let t={
				auto: {
					amount: 1,
					working: 0,
					at: 0,
					total: 0,
				},
				u:			null,
				name:		'',
				copy:		{},
				sys:		'',
				sysKq:	'',
				sysPre:	`Never speak in third person about yourself! Use ONLY first person when you speak of yourself or your actions!\n\n`,
				params: [],
				paramsCore: [],
				system: [],
				req: [],
				...this.memTmpl(mt)
			};
			t.memCount.push({l:'params',t:'Parameter generated memories',tref:'params',q:0,qp:'memq',qv:'memt'});
			for(const s in o.sys) {
				this.copy(o.sys,t.system,s);
			}
			this.memCount(t);
			return t;
		},
		async memGen2rag(o,u) {
			if(!o.parts.m.length) return;
			if(this.rag[u].t.length) this.rag[u].t+='\n\n';
			this.rag[u].t+=`A memory of ${this.nicks[u].n}: `+o.parts.m.join(`\n\nA memory of ${this.nicks[u].n}: `);
			await this.ragU(u);
			this.memGenParsedReset(this.memNew,0)
		},
		async memGen4rag(u) {
			let o=this.memNew;
			if(o.working) return;
			if(o.parts.memCountT.total==0) {
				alert("You have to add at least one topic for memory generation");
				return;
			}
			this.working=o.working=1;
			let data=this.nicks[u].system;
			if(this.memNew.parts.wMemories&&this.rag[u].t!=null&&this.rag[u].t.length) {
				data=`Description of ${this.nicks[u].n}: """${data}"""\n\nIt also should be consistent with these existing memories of ${this.nicks[u].n}: """${this.rag[u].t}"""`;
			}
			this.w({data:data});
			await this.memGen(o,o.parts.system[0],data);
			
			this.cancel=o.cancel=this.working=o.working=0;
		},
		async memGen(o,sys,udata) {
			let ms=[];
			let rgparams	=new RegExp('\{PARAMS\}','si');
			const rgtopic	=new RegExp(`\{TOPIC\}`,'gsi');
			o.parts.m2do	=[];
			let aid=this.userS('a');
			this.memGenParsedReset(o,1);
				
			this.chatFinalPush(ms,{
				nId:			-1,
				nick:			this.nicks[-1].n,
				content:	sys.req[0].req.replace(rgparams,udata),
				rating:		'',
				images:		[],
			});
			this.chatFinalPush(ms,{
				nId:			aid,
				nick:			this.nicks[aid].n,
				content:	sys.req[1].req,
				rating:		'',
				images:		[],
			});
			
			this.w({ms:ms});
			
			for(const m of o.parts.memCount) {
				for(const mc of this.memLnkDeref(o.parts,m.l)) {
					if(mc[m.qv]==null||mc[m.qv]==''||mc[m.qp]==null||mc[m.qp]=='') continue;
					o.parts.m2do.push(this.charNewMemTopicTmpl(mc[m.qp],mc[m.qv]));
				}
			}
			this.w({memories2do:o.parts.m2do});
			for(const mc of o.parts.m2do) {
				if(o.cancel==1) break;
				if(mc.v==''||mc.v==null) continue;
				if(!/^\d{1,4}$/.test(mc.q)) mc.q=3;
				await this.memGenDo(ms,o.parts.tmp,mc.q,3,sys.req[2].req.replace(rgtopic,mc.v),o,sys.sys);
			}
			this.w({memories:this.charNew.parts.m});
		},
		async memGenDo(ms,m,q,by,req,obj,sys) {
			let i=0,remains=0,startpos=obj.parts.m.length,done=0,lastpos=obj.parts.m.length;
			const rgAm=new RegExp('\{AMOUNT\}','si');
			while(i++<10) { //>
				if(obj.cancel==1) break;
				
				done		=obj.parts.m.length-startpos;
				remains	=q-done;
				this.w(`starting cycle: required: ${q}, done: ${done}, remains: ${remains}, lastpos: ${lastpos}`); //>
				if(remains<=0) break; //>
				
				this.chatFinalPush(ms,{
					nId:			-1,
					nick:			this.nicks[-1].n,
					content:	req.replace(rgAm,remains>by?by:remains),
					rating:		'',
					images:		[],
				});
				
				await this.chatSend({
					msg:				m,
					finalTurn:	ms.length-1,
					final:			ms,
					extra:			[false],
					sys:				sys,
					rooms:			false,
					raw:				false,
					func:				this.memParse,
					d:					obj,
					nicks:			this.chatMsNicks({aId:-1,uId:-1}),
				});

				if(lastpos!=obj.parts.m.length) {
					const tmp=obj.parts.m.slice(lastpos).map(mem=>`<memory>${mem}</memory>`).join('\n');
					this.chatFinalPush(ms,{
						nId:			this.userS('a'),
						nick:			this.nicks[this.userS('a')].n,
						content:	tmp,
						rating:		'',
						images:		[],
					});
					lastpos=obj.parts.m.length;
				} else {
					ms.pop();
				}
			}
		},
		memNewTmpl(o) {
			let m={
				u: null,
				system:	[],
				...this.memTmpl([])
			}
			for(const s in o.sys) {
				this.copy(o.sys,m.system,s);
			}
			this.memCount(m);
			this.w({'adding new mem tmpl':m})
			return m;
		},
		memTmpl(topics) {
			//don't use this. for data here
			let m={
				m:			[],
				k:			[],
				mem:		{
					custom:	[],
				},
				memCount: [],
				memCountT: {total:0},
				mem2do: [],
				wMemories: false,
			};
			for(const ml in m.mem){
				m.memCount.push({l:'mem.custom',t:'Custom topic memories',tref:'mems',q:0,qp:'q',qv:'v'});
			}
			for(const t of topics) {
				m.mem.custom.push(this.charNewMemTopicTmpl(t.q,t.t));
			}
			m.mem.custom.push(this.charNewMemTopicTmpl(1,''));
			return m;
		},
		charNewMemTopicTmpl(q,v) {
			return {q:q,v:v,c:''};
		},
		memLnkDeref(o,l) {
			let ml=o;
			//this.w({deref:o,l:l});
			for(const i of l.split('.')) {
				if(!/^[a-zA-Z0-9]{1,32}$/.test(i)) continue;
				ml=ml[i];
			}
			return ml;
		},
		memCount(o) {
			let used={total:0};
			for(let m of o.memCount) {
				used[m.tref]=0;
				for(const mi of this.memLnkDeref(o,m.l)) {
					//this.w({'check val of mem':mi,qv:m.qv,qp:m.qp});
					if(mi[m.qv]==null||mi[m.qv]==''||mi[m.qp]==null||mi[m.qp]=='') continue;
					//this.w({'recalculating mem':mi[m.qp]});
					used[m.tref]+=mi[m.qp]*1;
				}
				m.q=used[m.tref];
				used.total+=used[m.tref];
				//this.w({'memories':m,name:m.t});
			}
			o.memCountT=used;
			//this.w({'memories':o.memCount,total:o.memCountT});
		},
		memParse(c,o) {
			let rgmem=new RegExp(`<memory>(.+?)</memory>`,'gsi');
			let tmp;
			while(tmp=rgmem.exec(c)) {
				//this.w({parsing:tmp});
				if(tmp==null||!tmp[1].trim().length) continue;
				tmp[1]=tmp[1].trim();
				if(tmp[1]=='generated memory') continue;
				let exists=0;
				for(const m of o.parts.m) {
					if(m===tmp[1]) {
						exists=1;
						break;
					}
				}
				if(!exists) {
					o.parts.m.push(tmp[1]);
					this.w(`found: ${tmp[1]}`);
				}
			}
		},
		charNewParse(c) {
			let rg={};
			for(let p of this.charNew.parts.params) {
				//this.w(`extracting: ${p.n}`);
				rg[p]=new RegExp(`<${p.n}>([^<]+?)</${p.n}>`,'si');
				const res=rg[p].exec(c);
				if(res&&res.length>0) {
					if(p.c.length) continue;
					p.c=res[1].trim();
					//this.w(`found ${p.n}: ${p.c}`);
				}
			}
			//this.w({parts:this.charNew.parts.params});
		},
		quit() {
			if(confirm("Are you sure you wish to quit the game?")) {
				window.close();
				alert("You wish.");
			}
		},
		groupCh(id) {
			this.w(`changing group to ${id} ${this.groups[id]}`);
			this.group=id*1;
			//this.turnLastFilteredGo();
		},
		w(a) {
			if(!this.log) return;
			this.wDo(a);
		},
		wDo(a) {
			//console.log(a);
			if(typeof a==='object') {
				let tmp=JSON.stringify(a,null,2);
				console.log(tmp??a);
			} else if(Array.isArray(a)) {
				let tmp=JSON.stringify(a,null,2);
				console.log(tmp??a);
			} else {
				console.log(a);
			}
		},
		click(id) {
			const c=new MouseEvent('click',{view:window,bubbles:true,cancelable:true});
			document.getElementById(id).dispatchEvent(c);
		},
		tokensTotal(m,model) {
			if(!this.config.tokensCount.v) return;
			
			return this.tokens(m,model,'tp')+this.tokens(m,model,'tr');
		},
		tokens(m,model,id) {
			//this.w(`connection=${this.connection} this.model=${JSON.stringify(this.settings.req.model.v.v)} models=${JSON.stringify(this.models,null,2)}`)
			if(model==null) model=this.models[this.settings.req.model.v.v].n;
			return m[id][model];
		},
		pToggleDo(id,v) {
			if(v==undefined) v=!this.pState[id];
			this.w(`toggling ${id} to ${v}`);
			this.pState[id]=v;
		},
		async pToggle(id,v) {
			this.pToggleDo(id,v);
			await nextTick();
			let to=0;
			if(id=='howto'||id=='sets') to=1;
			if(id=='sys'||id=='instr') id='sysinstr';
			this.scroll(id,1);
		},
		optToggle() {
			if(this.pState['opt']) {
				this.pToggle('opt');
				return;
			}
			this.opt.count={t:0,d:0};
			this.opt.res={};
			for(const m in this.settings.req.model.v.l) {
				this.w(`creating tune params for model ${m}`);
				if(!this.opt['v'].hasOwnProperty('m')) this.opt[m]={v:{},k:'',times:1};
				for(const j of [this.config,this.settings.options,this.settings.req]) {
					for(const key in j) {
						this.w(`filling in opt ${key}`);
						const i=j[key];
						if(!i.opt) continue;
						if(this.opt[m]['v'].hasOwnProperty(key)) continue;
						this.opt[m]['v'][key]={start:'',end:'',step:'',v:'',use:false,rnd:''};
					}
				}
				//this.opt.res[m]={v:[],k:[],count:0};
			}
			this.pToggle('opt');
		},
		msgFilter(turn,b,m) {
			return this.msgFilterDo(this.turns[turn].branches[b].msgs[m]);
		},
		msgFilterDo(msg) {
			if(!this.config.stories.v) {
				return 0;
			} else if(!this.context[0]&&!this.context[1]&&!this.context[2]) {
				return 1;
			} else if(!this.context[0]) {
				const u=this.userS("u"),a=this.userS("a");
				if(this.context[3]&&this.context[1]&&this.context[2]) {
					if(!msg.nicks[u]&&!msg.nicks[a]) return 1;
					if(!(msg.nicks[a]&&this.context[1])||!(msg.nicks[u]&&this.context[2])) return 1;
				} else {
					if(!msg.nicks[u]&&!msg.nicks[a]) return 1;
					if(!(msg.nicks[a]&&this.context[1])&&!(msg.nicks[u]&&this.context[2])) return 1;
				}
			}
			return 0;
		},
		msgSkipped(turn,b,m) {
			if(this.hideMsg(turn,b,m)) 		return 1;
			if(this.msgFilter(turn,b,m)) 	return 1;
			return 0;
		},
		hideMsg(turn,b,m) {
			if(turn==0) return 1;
			const t		=this.turns[turn];
			const msg	=t.branches[b].msgs[m];

			if(this.msgRole(msg)!=="u") return 0;
			if(!this.config.hideEmptyOwn.v) return 0;
			if(this.config.showEmptyOwnSide.v&&this.msgTotal(turn,b)>1) return 0; //force showing.
			if(this.msgSide(msg)) return 0;
			if(!this.msgEmpty(turn,b,m)) return 0;
			return 1;
		},
		listmsgs(m,turn,msg) {
			const role=this.msgRole(msg);
			this.w(`listing ${m} - turn ${turn}, m: ${m}, ctrl: ${this.ctrl} role: ${role}`);
			if(this.opt.run) return 0;
			if(this.userS('u')==null||this.userS('a')==null) return 0;
			if(m==1&&this.ctrl&&role==='a') m=2;
			if(m==2&&role==='u') m=1; //for right mouse click
			
			if			(m==0) {	this.msgMvLeft(turn)						}
			else if (m==1) {	this.msgMvRight(turn,0,true)		}
			else if (m==2) {	this.msgMvRight(turn,1,true)		}
		},
		optChUse(m,k) {
			const p=['start','end','step'];
			let found=0;
			const o=this.opt[m].v[k];
			for(let P of p) {
				if(o[P].length) found++;
			}
			o.use=(found==p.length?true:false);
		},
		optimizeCancel() {
			if(this.working) this.cancel=true;
			this.opt.cancel=true;
		},
		async optimizeRun() {
			if(this.turn<2) { //>
				alert('You need to have a chat log, before you may start this. It creates side-replies, so it needs to have some content for AI to create alternative versions of replies to it.');
				return;
			}
			if(this.msgRole(this.msga(this.turn))==='u') {
				alert('You need to stop at the AI reply in your chat log, right now last message in the chat log belongs to you.');
				return;
			}
			const b=this.branchac; if(b.msg!=b.msgs.length-1) b.msg=b.msgs.length-1;
			this.opt.run=true;
			let menus=[0,0];
			if(this.pState['control']){ this.pToggleDo('control'); 	menu[2]=1 };
			if(this.pState['menu']) 	{ this.pToggleDo('menu'); 		menu[0]=1 };
			if(this.config.setsQ.v) 	{ this.config.setsQ.v=false;	menu[1]=1 };

			let opts={bak:{},v:{}};
			let ht={config:this.config,options:this.settings.options,req:this.settings.req}
			for(let m in this.settings.req.model.v.l) {
				this.w(`collecting combinations for model ${m} ${this.settings.req.model.v.l[m].tag}`)
				opts.v[m]=[];
				//let found=0;
				for(const i in ht) {
					for(const key in ht[i]) {
						if(!ht[i][key].opt) continue;
						if(!this.opt[m].v[key].use) continue;
						if(ht[i][key].f=='cb') {
							this.opt[m].v[key].start	=0;
							this.opt[m].v[key].end		=1;
							this.opt[m].v[key].step		=1;
							this.opt[m].v[key].rnd		='';
						} else {
							if(!/^\d{1,14}$/.test(this.opt[m].times)) {
								this.opt.run=false;
								alert(`Amount of replies per combination should be a sane value.`);
								scroll('optTimes');
								return;
							}
							if(!/^\d{0,16}$/.test(this.opt[m].v[key].rnd)) {
								this.opt.run=false;
								alert(`Field's ${ht[i][key].name} "Round up to N decimals" value ${this.opt[m].v[key].rnd} for model ${this.settings.req.model.v.l[m].n} is not a positive integer, please correct it.`);
								return;
							}
							for(const p of ['start','end','step']) {
								const val=this.opt[m].v[key][p];
								this.w(`checking params of ${key} ${p}=${val}`);
								if(!/^\d+(\.\d+)?$/.test(val)) {
									this.opt.run=false;
									alert(`Field's ${ht[i][key].name} ${p} value ${val} for model ${this.settings.req.model.v.l[m].n} is not numeric, please correct it.`);
									return;
								}
							}
							if(this.opt[m].v[key].step==0) {
								this.opt.run=false;
								alert(`Field's ${ht[i][key].name} step is set to zero, that would mean endless loop.`);
								return;
							}
						}
						opts['v'][m].push({
							key:key,
							lnk:ht[i][key],
							times:this.opt[m].times,
							...this.opt[m].v[key]
						});
						if(!opts.bak.hasOwnProperty(i)) opts.bak[i]={};
						if(!opts.bak[i].hasOwnProperty(key)) opts.bak[i][key]={lnk:ht[i][key],v:ht[i][key]['v']};
						this.w(`stored bak value: ${opts.bak[i][key]} for ${i} ${key}`);
					}
				}
				if(!opts.v[m].length) delete opts.v[m];
			}
			const t=this;
			let res=[];
			let ci=opts.length;
			async function optDo(p,i,opt,res,vals,idle) {
				t.w({index:i,p:p});
				const P=p[i];
				t.w({from:P.start,to:P.end,step:P.step});
				let v;
				for(let V=P.start*1;V<=P.end*1;V+=P.step*1) { //>
					if(P.rnd!=='') {
						v=t.rnd(V,P.rnd);
					} else {
						v=V;
					}
					t.w(`going with value ${p[i].key} ${v}`);
					P.lnk.v=v;
					vals[i]=v;
					if((p.length-1)>i) {  //>
						t.w(`this is (${i}) not the last level, going deeper`);
						await optDo(p,i*1+1,opt,res,vals,idle);
						continue;
					}
					if(t.opt.cancel) {
						t.w('cancelling opt');
						return;
					}
					opt.vals=vals;
					
					for(let tms=1;tms<=P.times;tms++) { //>
						opt.count.d++;
						if(idle) continue;

						t.w(`trying new iteration`);
						const coord=await t.msgMvRight(t.turn,0,true);
						t.w({coords:coord});
						let msg=t.turns[coord[0]].branches[coord[1]].msgs[coord[2]];
						const ct=t.msgContent(msg,t.config.trinity.v,-1);
						let found=0;
						for(let j=0;j<res.length;j++) { //>
							if(res[j]['c']!==ct) continue;
							res[j].ids.push(coord[2]);
							res[j].v.push([...vals]);
							found=1;
						}
						if(!found) res.push({c:ct,ids:[coord[2]],v:[[...vals]]});
					}
				}
			}
			this.w({valuesToTry:opts});

			this.opt.res={};
			for(const m in opts.v) {
				this.opt.res[m]={v:[],k:[],count:0};
				for(const i of opts.v[m]) { this.opt.res[m].k.push(i.lnk) }
			}
			
			function optsRestore(opts) {
				for(const i in opts.bak) {
					for(const k in opts.bak[i]) {
						t.w(`restoring in ${i} bak value of ${k} to ${opts.bak[i][k].v}`);
						opts.bak[i][k].lnk.v=opts.bak[i][k].v;
					}
				}
			}
			
			this.opt.vals	=[];
			this.opt.count={t:0,d:0};
			const modelbak=this.settings.req.model.v.v;
			
			for(const m in opts.v) {
				await optDo(opts.v[m],0,this.opt,this.opt.res[m].v,[],true);
			} this.opt.count.t+=this.opt.count.d; this.opt.count.d=0;
			
			for(const m in opts.v) {
				this.settings.req.model.v.v=this.opt.m=m;
				optsRestore(opts);
				await optDo(opts.v[m],0,this.opt,this.opt.res[m].v,[],false);
			} optsRestore(opts);
			
			this.w({opt:this.opt});
			this.settings.req.model.v.v=modelbak;
			this.opt.cancel	=false;
			this.opt.run		=false;

			if(menu[0]) this.pToggleDo('menu');
			if(menu[1]) this.config.setsQ.v=true;
			if(menu[2]) this.pToggleDo('control');
			await nextTick();
			this.scroll('optRes',true);
		},
		rnd(n,d) {
		  return Number(Math.round(n+'e'+d)+'e-'+d);
		},
		rand(min,max) {
			return Math.floor(Math.random()*(max-min+1))+min;
		},
		
		//db methods
		prune() {
			if(
				confirm("Are you sure you wish to permanently erase everything but the currently selected branch of messages? Again, this will erase all the alternative chat records. Proceed?")
				&&
				confirm("Are you really sure?")
			) {
				for(const i in this.turns) {
					if(i==0) continue;
					this.w({'pruning':i,'turn':this.turns[i]});
					if(this.turns[i].branch===-1) {
						this.w(`erasing turns up to ${i}`);
						this.turns=this.turns.slice(0,i);
						break;
					}
					let tmp=this.brancha(i);
					this.turnBranchSet(i,0);
					this.turns[i].branches=[];
					this.turns[i].branches.push(tmp);
					tmp=this.msga(i);
					this.turns[i].branches[0].msg	=0;
					this.turns[i].branches[0].msgs=[tmp];
					this.turns[i].tree={};
					this.treeu(i);
					this.w(this.turns[i].branches);
				}
			}
		},
		clear() {
			if(
				confirm("Are you sure you wish to permanently erase all the chat log? Proceed?")
				&&
				confirm("Are you really sure you want to erase all the chat log?")
			) {
				this.turn=0;
				this.turns.splice(1);
			}
		},
		async load() {
			this.w('drop all changes since load');
			if(!confirm('Please do not trust files of other people, as they can inject something. The most obvious and easiest thing is to set your ollama url to something they control, so they can see your chat then. Another potential attack vector is some specially crafted prompt to exploit ollama, that can be in some of the fields sent to Ollama. In other words, load only your own chats. Load this file?')) return;
			this.connection=0; //to prevent partial updates to dom
			for(const i in this.def) {
				this.w(`restoring ${i}`)
				if(i=='def') continue;
				this.copy(this.def,this.$data,i)
			}
			
			const l=document.getElementById('load');
			let fr=new FileReader();
			let t	=this;
			let d;
			//as i do not copy structures per version, this upgrade is whacky :)
			//it may break if in future some structures get changed without updating this.
			//but so far it works and i don't want to make file bigger just with 
			//copying all these default tables per version.
			//if needed, then it has to be changed.
			
			async function parse(d) {
				if(!d) {
					t.w('parsing loaded file');
					d=JSON.parse(fr.result);
					delete d.def;
					delete d.inited;
					d.connection=0; //to prevent partial updates to dom
				} else {
					t.w(`recursive updating`);
				}
				t.w(d)
				//if(d.hasOwnProperty('nicks')) t.w({nicksd:d.nicks});
				//patch for 1.8 shift.
				if(t.$data.hasOwnProperty('configGlobal')) {
					t.config=t.configGlobal;
					t.settings=t.settingsGlobal;
					if(t.settingsGlobal.req.hasOwnProperty('model')) {
						t.model=t.settingsGlobal.req.model.v.v;
					}
				}
				let ver;
				if(d.hasOwnProperty('configGlobal')) {
					ver=d.configGlobal.version.v;
				} else if(d.hasOwnProperty('config')) {
					ver=d.config.version.v;
					t.def.config=computed(()=>t.def.configGlobal);
					t.def.settings=computed(()=>t.def.settingsGlobal);
				} else {
					ver=0;
					t.def.config=computed(()=>t.def.configGlobal);
					t.def.settings=computed(()=>t.def.settingsGlobal);
				}
				t.w(`new parser pass for ver: ${ver}`);
				
				if(ver==0) { //updating from version 0->1
					t.w('upgrading from version 0');
					
					t.copy(t.def,d,'configGlobal'); d.config=d.configGlobal; delete d.configGlobal;
					t.copy(t.def,d,'settingsGlobal'); d.settings=d.settingsGlobal; delete d.settingsGlobal;
					
					d.nicks={
						0:{	't':'u','n':d.nick,'id':0	},
						1:{	't':'a','n':d.nickai,'id':1	}
					};
					delete d.nick;
					delete d.nickai;
					t.updateAddParams(d,'nick');
					t.w({config:d.config})
					d.config.url.v=d.url;
					delete d.url;

					let tmp;
					tmp=d.system; delete d.system; d.system={'1':tmp};
					tmp=d.instr; delete d.instr; d.instr={'1':tmp};
					
					t.updateAddParams(d,'amountNicks');
					t.updateAddParams(d,'pState');
					
					for (const i in d.pState) {
						d.pState[i]=0;
					}
					delete d.sysHide;
					delete d.instrHide;
					delete d.pullHide;
					delete d.setingsHide;
					delete d.settings; //just delete old settings )
					t.copy(t.def,d,'settingsGlobal'); d.settings=d.settingsGlobal; delete d.settingsGlobal;
					d.config.version.v=1;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.1;
					//delete d.settings; //just delete old settings )
					t.copy(t.def,d,'settingsGlobal'); d.settings=d.settingsGlobal; delete d.settingsGlobal;
					d.config.version.v=1.1;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.1) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.2;
					t.updateAddParams(d,'config');
					for(const i in d.models) {
						if(d.models[i].n!=d.model) continue;
						d.model=i;
						break;
					}
					for(const t of d.turns) {
						for(const b of t.branches) {
							for(const m of b.msgs) {
								m.tp={};
								m.tr={};
							}
						}
					}
					let tmp={};
					t.w({'updating nicks':d.nicks});
					d.nicks['-1']				=t.nicks['-1'];
					d.amountNicks['s']	=t.amountNicks['s'];
					d.nick['s']					=t.nick.s;
					d.nick['n']['s']		=t.nick.n.s;
					t.w({'updated nicks':d.nicks,nick:d.nick,amountNicks:d.amountNicks})
					d.config.version.v=1.2;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.2) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.3;
					t.updateAddParams(d,'config');
					d.config.version.v=1.3;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.3) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.4;
					let tmp=t.msgTmpl(1,null,0); //just to get new fields
					for(let tu=1;tu<d.turns.length;tu++) { //>
						tu=d.turns[tu];
						//if(tu.role==='root') continue;
						for(const b of tu.branches) {
							if(!b.msgs.length) continue;
							for(const m of b.msgs) {
								for(const i in tmp) {
									if(m.hasOwnProperty(i)) continue;
									m[i]=tmp.i
								}
								m.status	=t.msgStatusId('done');
							}
						}
					}
					t.updateAddParams(d,'config');
					d.config.version.v=1.4;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.4) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.5;
					if(Array.isArray(d.settings.options.stop.v)) {
						t.settingsGlobal.options.stop.v=d.settings.options.stop.v;
					} else {
						t.settingsGlobal.options.stop.v=[d.settings.options.stop.v];
					}
					d.settings.options=t.settingsGlobal.options;
					t.w({testtt:d.settings.options});
					//if we change userAdd or structures this will need rewriting
					//clean current list
					for(const i in t.nicks) {
						if(i.id>1) delete t.nicks[i.id];
					}
					t.amountNicks['idNext']=2;
					//find max id in loaded.
					let maxId=1;
					for(const i in d.nicks) {
						d.nicks[i].del=0; //add del key
						if(i>maxId) maxId=i;
					}
					t.amountNicks['idNext']=maxId*1+1;
					let tmp=t.msgTmpl(1,null,0); //just to get new fields
					for(const tu of d.turns) {
						if(tu.role==='root') continue;
						for(const b of tu.branches) {
							if(!b.msgs.length) continue;
							for(const m of b.msgs) {
								let role;
								if(tu.role==='user') role='u'
								if(tu.role==='assistant') role='a';
								if(tu.role==='system') role='s';
								//set status done for all without of one
								if(!m.hasOwnProperty('status')) m.status=t.msgStatusId('done');
								if(m.status==null) m.status=t.msgStatusId('done');
								m.edited=0; //add edited key
								m.nId=null;
								//match name to ids
								for(const i in d.nicks) {
									if(m.nick===d.nicks[i].n) {
										m.nId=i;
										break;
									}
								}
								//if not found (deleted) add a deleted user
								if(m.nId==null) {
									//copy added deleted user to d
									t.nick['n'][role]=m.nick;
									await t.userAdd(role,m.nick,{});
									let id=t.amountNicks['idNext']-1;
									t.nicks[id].del=1;
									d.nicks[id]=t.nicks[id];
									m.nId=id;
								}
							}
						}
					}
					t.updateAddParams(d,'config');
					d.config.version.v=1.5;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.5) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.6;
					t.updateAddParams(d,'config');
					for(const i in d.config) { 
						if(!t.config.hasOwnProperty(i)) continue;
						for(const j of ['q','qn']) { d.config[i][j]=t.config[i][j] }
					}
					for(const i in d.settings.options) {
						for(const j of ['q','qn']) { d.settings.options[i][j]=t.settings.options[i][j] }
					}
					for(const i in d.settings.req) {
						for(const j of ['q','qn']) { d.settings.req[i][j]=t.settings.req[i][j] }
					}
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.6) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.7;
					t.w({n:d.nick});
					t.updateAddParams(d,'config');
					t.updateAddParams(d,'group');
					t.updateAddParams(d,'groupAddN');
					t.updateAddParams(d,'context');
					t.updateAddParams(d,'msgUserListOn');
					d.pState=t.pState;
					t.group=0;
					for(const u in t.nicks) {
						if(t.nicks[u].t=='s') continue;
						t.userDelDo(u);
						delete t.nicks[u];
					}
					t.w({'list of users before import':t.nicks,importing:d.nicks,sys:d.system});

					let tmp={system:{},instr:{},ids:{}};
					for(const u in d.nicks) {
						if(d.nicks[u].t=='s') continue;
						if(d.nicks[u].del) continue;
						const id=await t.userAdd(d.nicks[u].t,d.nicks[u].n,{});
						tmp.ids[u]=id;
						tmp.system[id]=d.system[u];
						tmp.instr[id]=d.instr[u];
						t.userGroupAdd(1,id);
					}
					d.system=tmp.system;
					d.instr=tmp.instr;
					d.groups=t.groups;
					d.nicks=t.nicks;
					d.group=1;
					d.amountNicks=t.amountNicks;
					
					for(const tu of d.turns) {
						for(const b of tu.branches) {
							if(!b.msgs.length) continue;
							for(const m of b.msgs) {
								m.nId=tmp.ids[m.nId];
								m.nicks={};
								for(const u in d.nicks) {
									if(d.nicks[u].t!='u'&&d.nicks[u].t!='a') continue;
									m.nicks[u]=true;
								}
								m.nicksArr=t.msgUserListAll({nicks:m.nicks});
							}
						}
					}
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.7) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.8;
					for(const u in d.nicks) {
						d.nicks[u].system	=d.system[u];
						d.nicks[u].instr	=d.instr[u];
						d.nicks[u].setsDo	=false;
						d.nicks[u].sets		=false;
					}
					delete d.system;
					delete d.instr;
					delete t.system;
					delete t.instr;
					
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.8) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.settings.req.model={};
					t.copy(t.settingsGlobal.req,d.settings.req,'model');
					d.settings.req.model.v.v=d.model;
					d.configGlobal=d.config;
					d.settingsGlobal=d.settings;
					delete d.config;
					delete d.settings;
					delete d.model;
					delete d.message;
					for(let m of d.models) {
						m.n=`${m.n} (${m.ps} ${m.q})`;
					}

					d.configGlobal.version.v=1.9;
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver==1.9) {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.2';

					for(const p in t.configGlobal) {
						t.w(`updating key ${p} in config`);
						if(!d.configGlobal.hasOwnProperty(p)) continue;
						d.configGlobal[p].opt=t.def.configGlobal[p].opt;
						d.configGlobal[p].def=t.def.configGlobal[p].def;
						for(let u in d.nicks) {
							u=d.nicks[u];
							if(!u.hasOwnProperty('config')) continue;
							u.config[p].def=t.def.configGlobal[p].def;
							u.config[p].opt=t.def.configGlobal[p].opt;
						}
					}
					for(const s of ['options','req']) {
						for(const p in t.def.settingsGlobal[s]) {
							t.w(`processing param ${p}`);
							if(!d.settingsGlobal[s].hasOwnProperty(p)) continue;
							if(!d.settingsGlobal[s][p].hasOwnProperty('name')) d.settingsGlobal[s][p].name=p;
						
							d.settingsGlobal[s][p].opt=t.def.settingsGlobal[s][p].opt;
							d.settingsGlobal[s][p].def=t.def.settingsGlobal[s][p].def;
							for(let u in d.nicks) {
								u=d.nicks[u];
								if(!u.hasOwnProperty('settings')) continue;
								u.settings[s][p].def=t.def.settingsGlobal[s][p].def;
								u.settings[s][p].opt=t.def.settingsGlobal[s][p].opt;
								if(!u.settings[s][p].hasOwnProperty('name')) u.settings[s][p].name=p;
							}
						}
					}
					t.updateAddParams(d,'pState');
					t.updateAddParams(d,'opt');
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.2") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.3';
					for(const m in d.opt) {
						for(const p in d.opt[m].v) {
							d.opt[m].v[p].rnd='';
						}
					}
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.3") {
					d.configGlobal.version.v='1.9.4';
					parse(d);
					return;
				} else if (ver=="1.9.4") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.5';

					t.updateAddParams(d,'configGlobal');
					t.updateAddParams(d,'pState');
					d.modelsEmb=[];
					t.copy(t.def.settingsGlobal.req,d.settingsGlobal.req,'modelEmb');
					d.rag={};
					for(let u in d.nicks) {
						d.rag[u]=t.ragStrct();
						u=d.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						t.copy(t.def.settingsGlobal.req,u.settings.req,'modelEmb');
						t.copy(t.def.configGlobal,u.config,'urlEmb');
						delete u.config.urlProxy;
					}
					delete d.configGlobal.urlProxy;
					delete d.proxy;
					
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.5") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.6';

					d.rag['g']=t.ragStrct();
					t.updateAddParams(d,'configGlobal');
					d.configGlobal.stories.d=t.def.configGlobal.stories.d;
					if(d.configGlobal.stories.v) {
						d.configGlobal.storiesUI.v=true;
					} else {
						d.configGlobal.stories.v=true;
						d.configGlobal.storiesUI.v=false;
					}
					
					for(let u in d.nicks) {
						if(!d.rag.hasOwnProperty(u)) d.rag[u]=t.ragStrct();
						u=d.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						t.copy(t.def.configGlobal,u.config,'ragMinSmlr');
						t.copy(t.def.configGlobal,u.config,'storiesUI');
						t.copy(t.def.configGlobal,u.config,'bgImg');
						t.copy(t.def.configGlobal,u.config,'bgFixed');
						t.copy(t.def.configGlobal,u.config,'chatHeight');
						t.copy(t.def.configGlobal,u.config,'imgsLastOnly');
						t.copy(t.def.configGlobal,u.config,'rag');
						t.copy(t.def.configGlobal,u.config,'ragGAmount');
						t.copy(t.def.configGlobal,u.config,'ragUAmount');

						u.config.stories.d=t.def.configGlobal.stories.d;
						if(u.config.stories.v) {
							u.config.storiesUI.v=true;
						} else {
							u.config.stories.v=true;
							u.config.storiesUI.v=false;
						}
					}
					
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.6") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.7';
					
					t.updateAddParams(d,'configGlobal');
					for(const p in t.def.configGlobal) {
						d.configGlobal[p].g=t.def.configGlobal[p].g;
					}
					for(const s of ['options','req']) {
						for(const p in t.def.settingsGlobal[s]) {
							d.settingsGlobal[s][p].g=t.def.settingsGlobal[s][p].g;
						}
					}
					
					for(let u in d.nicks) {
						u=d.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						t.copy(t.def.configGlobal,u.config,'ragPast');
						u.config.version.v='1.9.7';

						for(const p in t.def.configGlobal) {
							if(!u.config.hasOwnProperty(p)) {
								t.copy(t.def.configGlobal,u.config,p);
							} else {
								u.config[p].g=t.def.configGlobal[p].g;
							}
						}
						for(const s of ['options','req']) {
							for(const p in t.def.settingsGlobal[s]) {
								if(!t.def.settingsGlobal[s].hasOwnProperty(p)) {
									t.copy(t.def.settingsGlobal[s],u.settings[s],p);
								} else {
									u.settings[s][p].g=t.def.settingsGlobal[s][p].g;
								}
							}
						}
					}
					
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.7") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.8';

					t.updateAddParams(d,'pState');
					t.copy(t.def,d,'memNew');
					t.copy(t.def,d,'charNew');

					d.charNew.parts	=t.charNewTmpl(d.charNew);
					d.memNew.parts	=t.memNewTmpl(d.memNew);

					t.charCreateReset(d.charNew);

					for(const tr of d.turns) {
						br: for(const b of tr.branches) {
							let rated=0;
							for(const m of b.msgs) {
								if(m.rating!=null&&m.rating!=='') {
									rated=1;
									break;
								}
							}
							b.rated=rated?true:false;
						}
					}
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.8") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.8b';

					d.settingsGlobal.req.model.sess='v';
					d.settingsGlobal.req.modelEmb.sess='v';
					for(let u in d.nicks) {
						if(!u.hasOwnProperty('settings')) continue;
						u.settings.req.model.sess='v';
						u.settings.req.modelEmb.sess='v';
					}
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.8b") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.9';
					t.updateAddParams(d,'configGlobal');
					d.turns[0].branches[0].msgs[0].nId=-1;

					for(let u in d.nicks) {
						u=d.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						t.copy(t.def.configGlobal,u.config,'raw');
						t.copy(t.def.configGlobal,u.config,'trinity');
						t.copy(t.def.configGlobal,u.config,'trinityReqTh');
						t.copy(t.def.configGlobal,u.config,'trinityReqA');
						t.copy(t.def.configGlobal,u.config,'rawTmpl');
						t.copy(t.def.configGlobal,u.config,'rawLog');
						t.copy(t.def.configGlobal,u.config,'aiIsYou');
						t.copy(t.def.configGlobal,u.config,'noAiReplyToSelf');
						t.copy(t.def.configGlobal,u.config,'noReplyToSelf');
						t.copy(t.def.configGlobal,u.config,'namesAdd');
						t.copy(t.def.configGlobal,u.config,'trinityChancesTh');
						t.copy(t.def.configGlobal,u.config,'emptyToSth');
						t.copy(t.def.configGlobal,u.config,'emptyToTxt');
					}
					
					for(let turn=0;turn<d.turns.length;turn++) { //>
						if(turn==0) continue;
						const tr=d.turns[turn];
						for(const b of tr.branches) {
							for(const m of b.msgs) {
								m.content3={};
								t.msgContentSet(m,'a',m.content,false);
								if(turn!=0) {
									if(m.status==null&&(!m.side||m.side==0)) {
										m.status=t.msgStatusSetDo(m,'done');
									} else {
										t.msgStatusSetDo(m,t.msgStatusId2W(m.status));
									}
									for(const bp in tr.tree) {
										if(bp>=d.turns[turn-1].branches.length) {
											delete tr.tree[bp]
											continue;
										}
										for(const mp in tr.tree[bp]) {
											if(mp>=d.turns[turn-1].branches[bp].msgs.length) {
												delete tr.tree[bp][mp];
											}
										}
									}
								}
							}
						}
					}
				} else if (ver=="1.9.9") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.10';
					t.updateAddParams(d,'configGlobal');
					for(let u in d.nicks) {
						u=d.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						t.copy(t.def.configGlobal,u.config,'trinityOwCOnOff');
					}
				}
				
				t.w('adding new config vars');
				t.updateAddParams(d,'configGlobal');
				
				for(let i in d) {
					t[i]=d[i]
				}
				
				t.w('restore data links to computed vals');
				t.nicks[-1].n											=computed(()=>t.config.sysNick.v);
				t.settingsGlobal.req.model.v.l		=computed(()=>t.models);
				t.settingsGlobal.req.modelEmb.v.l	=computed(()=>t.modelsEmb);
				for(let u in t.nicks) {
					u=t.nicks[u];
					if(!u.hasOwnProperty('settings')) continue;
					u.settings.req.model.v.l		=computed(()=>t.models);
					u.settings.req.modelEmb.v.l	=computed(()=>t.modelsEmb);
				}
				t.w(`finished upgrading to version: ${t.configGlobal.version.v}`);
				
				t.working					=0; t.cancel=0;
				t.charNew.working	=0; t.charNew.cancel=0;
				t.memNew.working	=0; t.memNew.cancel=0;
				
				await t.urlTest(); //will do list
			}
			this.w(l.files[0])
			this.w(fr.addEventListener("load",async (event)=>{
				t.inited=2;
				await parse(d);
				t.inited=1;
			}));
			fr.readAsText(l.files[0]);
		},
		save() {
			let name='';
			main: for(const i in this.nicks) {
				name+=this.nicks[i].n+'-';
			}
			name='chat.'+name.slice(0,-1);
			
			this.saveDl(this.$data,name);
		},
		saveDl(d,n) {
			n=n.replace(/[^\w\d\. -]/gis,'');
			n=n.match(/^(.{1,32})/);
			n=n[1]??'something';
			n=`${n}.${Date().toString()}.json`;
			
			const blob						=new Blob([JSON.stringify(d)],{ type: "text/json" });
			const l								=document.createElement("a");
			l.download						=n;
			l.href 								=window.URL.createObjectURL(blob);
			l.dataset.downloadurl	=["text/json",l.download,l.href].join(":");

			l.dispatchEvent(
				new MouseEvent("click",{
					view: window,
					bubbles: true,
					cancelable: true,
				})
			);
			l.remove()
		},
		optResSave() {
			const name=`Optimize_results.${Date().toString()}.html`;
			const blob=new Blob(["<html>"+document.getElementById('css').outerHTML+"<body>"+document.getElementById('optRes').outerHTML+"</body></html>"],{ type: "text/html" });
			this.w({blob:blob});
			const l								=document.createElement("a");
			l.download						=name;
			l.href 								=window.URL.createObjectURL(blob);
			l.dataset.downloadurl	=["text/html",l.download,l.href].join(":");

			l.dispatchEvent(
				new MouseEvent("click",{
					view: window,
					bubbles: true,
					cancelable: true,
				})
			)
			l.remove()
		
		},
		async list() {
			this.inited=2;
			await this.listDo();
			this.inited=1;
		},
		async listDo() {
			if(this.working) {
				this.w('working right now, leaving');
				return;
			}
			this.working							=1;
			this.modelsLoading.inited	=0;
			this.modelsLoading.total	=0;
			this.modelsLoading.done		=0;
			this.w(`listing models`);
			
			await fetch(this.url()+"/api/tags",{
				"method": "GET",
			}).then(r=>{
				if(!r.ok) throw new Error(r.statusText);
				return r.text();
			}).then(async(r)=>{
				let res='';
				this.w(`parsing list reply`);
				try { res=JSON.parse(r) } catch (error) { console.error(`error: ${error}`) }
				let old={
					model:		[...this.models],
					modelEmb:	[...this.modelsEmb]
				};
				this.w({oldModels:old});
				this.models	=[]; this.modelsEmb	=[];
				this.w({modelsDL:res});
				let mdls=[];
				this.modelsLoading.inited	=2;
				this.modelsLoading.total	=Object.keys(res.models).length;
				
				for(const m of Object.keys(res.models).sort((a,b)=>{
					return res.models[a].name.localeCompare(res.models[b].name.toLowerCase());
				})) {
					let md=res.models[m];
					mdls.push({
						tag:	md.name,
						n:		`${md.name} (${md.details.parameter_size} ${md.details.quantization_level})`,
						mt:		md.modified_at,
						s:		md.size,
						ps:		md.details.parameter_size,
						q:		md.details.quantization_level,
						ctx:	null,
					});
					await this.modelData(mdls,mdls.length-1);
					this.w(`processed model ${md.name}`);
					this.modelsLoading.done++;
				}
				this.w('processed new models');
				for(const m of mdls) {
					if(m.emb) {
						this.modelsEmb.push(m);
					} else {
						this.models.push(m);
					}
				}
				
				if(!this.models.length) {
					this.w('no models found');
					this.working			=0;
					this.connection		=1;
					this.connectionErr='';
					this.pToggle('pull',1);
					return;
				}
				
				//this section had too many copy-pastes, one day it needs to be redone )).
				//but we can just wait 1-2 years till llm can do that, right? )
				//thank you, llm of the future! ))
				var horror={model:'models',modelEmb:'modelsEmb'};
				for(const i in horror) {
					if(!this.settingsGlobal.req[i].v.l.length) {
						this.settingsGlobal.req[i].v.v='';
						continue;
					}
					let m=this.settingsGlobal.req[i].v.v;
					let found=-1;

					if(!old[i].length) {
						this.w(`no old model list found for ${i}`);
					} else if(m>(old[i].length-1)) {
						this.w(`selected ${m} value ${m} for strange reason is larger than old array: ${old[i].length-1}`);
					} else if(m!=null&&m!=='') {
						this.w(`searching for previously selected models in new list ${i} ${m} ${old[i].length}`);
						this.w({old:old});

						for(let M=0;M<this.$data[horror[i]].length;M++) { //>
							if(old[i][m].n===this.$data[horror[i]][M].n) {
								found=M;
								this.w(`found matching model #${M} ${this.$data[horror[i]][M].n}`)
								break;
							}
						}
					} else {
						this.w(`no model selected globaly, skipping and setting the first one`);
					}
					
					if(found==-1) found=0; this.settingsGlobal.req[i].v.v=found;
					this.w(`globally set model ${this.$data[horror[i]][this.settingsGlobal.req[i].v.v].n}`);
				}
				
				for(const i in horror) {
					this.w(`setting ${i}`);
					for(let u in this.nicks) {
						u=this.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						if(!u.settings.req[i].v.l.length) {
							u.settings.req[i].v.v='';
							continue;
						}
						let found=-1;
						let us=u.settings.req[i].v;
						if(!old[i].length) {
							this.w(`no old model list found for ${i}`);
						} else if(us.v>(old[i].length-1)) {
							this.w(`selected ${i} value ${us.v} for strange reason is larger than old array: ${old[i].length-1}`);
						} else if(us.v!=null&&us.v!=='') {
							for(let m=0;m<this.$data[horror[i]].length;m++) { //>
								if(old[i][us.v].n===this.$data[horror[i]][m].n) {
									found=m;
									this.w(`found matching model #${m} for user ${u.n}`);
									break;
								}
							}
						}
						if(found==-1) found=0; us.v=found;
						this.w(`user ${u.n} set model ${this.$data[horror[i]][us.v].n}`);
					}
				}
				
				this.w({'models':this.models.length});
				this.connectionErr	='';
				this.connection			=1;
				this.cancel					=0;
				this.working				=0;
				
			}).catch((error)=>{
				this.cancel	=0;
				this.working=0;
				this.modelsLoading.inited=0;
				this.connectionErr=error.message;
				this.connection=0;
				this.w(`listing conneciton err: ${error.message}`);
				return;
			});
			this.modelsLoading.inited=1;
		},
		async modelData(mdls,id) {
			return fetch(this.url()+"/api/show",{
				"method": "POST",
				'body': JSON.stringify({ name:mdls[id].tag }),
			}).then(r=>{
				if(!r.ok) throw new Error(r.statusText);
				return r.text();
			}).then(r=>{
				let res='';
				try { res=JSON.parse(r) } catch (error) {
					console.error(`error: ${error}`)
				}
				this.w({'pulled model data':res});
				if(res.hasOwnProperty('parameters')) {
					this.w({'has parameters specified':res.parameters});
					let tmp=res.parameters.match(/.*num_ctx\s+(\d+)/);
					if(tmp&&tmp[1]) {
						this.w(`modelfile of ${mdls[id].n} has num_ctx: ${tmp[1]}`);
						mdls[id]['ctx']=tmp[1];
					}
				}
				if(res.details.hasOwnProperty('family')) {
					let tmp=res.details.family.match(/\bbert\b/i);
					mdls[id].emb=tmp==null?false:true;
					this.w(`${mdls[id].n} embedded status: ${mdls[id].emb}`);
				}
			}).catch((error)=>{
				this.connectionErr=error.message;
				this.connection=0;
				return;
			});
		},
		loadFile(n) {
			this.w(`loading file for ${n}`);

			const l=document.getElementById('load'+n);
			let fr=new FileReader();
			let t	=this;
			let d;
			async function parse(n,d) {
				t.w(`loading: ${n}`);
				if(n==='bgImg') {
					//fetch('/img.jpg').then((r)=>{
					//	return r.blob();
					//}).then((r)=>{
						//document.getElementById('bg').style.backgroundImage="url("++")";
						//this.bgImg=URL.createObjectURL(r);
					//});
					console.log('loading'+n);
					t.config.bgImg.v=d;//URL.createObjectURL(d);
					t.bgSet(t.config.bgImg.v);
				} else if (n==='img') {
					t.imgs.push(d.replace('data:','').replace(/^.+,/,''));
					t.w(`loaded images ${t.imgs.length}`);
				} else if (n==='card') {
					t.cardLoad(d);
				}
			}
			this.w(`file: ${l.files[0]}`);
			this.w(fr.addEventListener("load",function() { parse(n,fr.result) }))
			fr.readAsDataURL(l.files[0]);
			//fr.readAsBinaryString(l.files[0]);
		},
		bgFix(v) {
			if(v) {
				document.getElementById('body').style.backgroundAttachment='fixed';
			} else {
				document.getElementById('body').style.backgroundAttachment='scroll';
			}
		},
		bgSet(d) {
			document.getElementById('body').style.backgroundImage	=`url(${d})`;
			document.getElementById('body').style.backgroundSize	='100% auto';
			document.getElementById('body').style.backgroundRepeat='repeat-y';
		},
		pull() {
			this.working			=1;
			this.connectionErr='';
			
			fetch(this.url()+"/api/pull",{
				"method": "POST",
				"body": JSON.stringify({
					'name':	this.modelPull,
				})
			}).then(r=>{
				if(!r.ok) throw new Error(r.statusText);
				return r.body;
			}).then(r=>{
				this.w('dissecting response');
				const t				=this;
				const decoder	=new TextDecoder('utf-8');
				const reader	=r.getReader();
				let res='',buf='';
				this.mpull=[{status:''}];
				
				reader.read().then(function processText({done,value}) {
					if(done) {
						t.w({'Stream complete':res});
						t.cancel=0;
						return true;
					}
					if(t.cancel) {
						t.w('cancelling');
						reader.cancel();
						reader.releaseLock();
						t.cancel=0;
						return 'cancel';
					}
					buf					=decoder.decode(value);
					const chnks	=buf.trim().split('\n');
					//t.w(buf);

					for (const ch of chnks) {
						try { res=JSON.parse(ch) } catch (error) { t.w(`error: ${error}`) }
						if(res.hasOwnProperty('error')) {
							reader.cancel();
							reader.releaseLock();
							t.cancel=0;
							return res.error;
						}
						if(res.status!=t.mpull[t.mpull.length-1].status) {
							t.mpull.push({'status':res.status});
						}
						let p=t.mpull[t.mpull.length-1];
						if(res.status&&res.total) {
							p.total	=res.total;
							p.done	=res.completed;
							if(!p.done) {
								p.prcnt	=0
							} else {
								p.prcnt	=Math.floor(100/(p.total/p.done))
							}
						}
					}
					return reader.read().then(processText);
				}).then(r=>{
					t.w(`model pull attempt is finished, status ${r}`);
					t.working	=0;
					t.cancel	=0;
					if(r===true||r==='cancel') {
						t.connectionErr='';
						t.pToggle('pull',0);
						t.listDo();
					} else {
						t.connectionErr=r;
					}
				}).catch((error)=>{
					t.working=0;
					t.cancel=0;
					t.connectionErr=error.message;
					t.connection=0;
					return;
				});
			}).catch((error)=>{
				this.working=0;
				this.cancel=0;
				this.connectionErr=error.message;
				return;
			});
		},
		updateAddParams(d,p) {
			this.w(`updateAddParams for key ${p}`);
			if(!d.hasOwnProperty(p)) {
				this.w(`loaded file doesn't have whole section ${p}, importing`);
				d[p]=this['def'][p];
				return;
			}
			for(let i in this['def'][p]) {
				this.w(`checking property ${i}`)
				if(d[p].hasOwnProperty(i)) {
					this.w(`skipping param ${i}, already exists in loaded file`);
				} else {
					this.w(`adding param ${i} to loaded file`);
					d[p][i]=this['def'][p][i]
				}
			}
		},
		shuffle() {
			return ([...arr], n = 1) => {
				let m = arr.length;
				while (m) {
					const i = Math.floor(Math.random() * m--);
					[arr[m], arr[i]] = [arr[i], arr[m]];
					return arr.slice(0, n);
				};
			}
		},

		//rag methods
		loadRag() {
			this.w('starting loading rag');

			const l=document.getElementById('loadRag');
			let fr=new FileReader();
			let t	=this;
			let d;
			async function parse(d) {
				t.w({parsing:d});
				for(const l of d.split('\n')) {
					t.w(`embedding ${l}`)
					t.rag[-1].v.push(await t.embed(l));
				}
			}
			this.w(`file: ${l.files[0]}`);
			this.w(fr.addEventListener("load",function() { parse(fr.result) }))
			fr.readAsText(l.files[0]);
		
		},
		ragStrct() {
			return {
				v:				[],
				t:				'',
				doing:		false,
				done:			0,
				total:		0,
				last:			[],
				modelEmb:	'',
				err:			null
			};
		},
		async ragU(u) {
			if(u==null) return;
			if(!this.settings.req.modelEmb.v.l.length) {
				alert("Can not update memories (rag) as you've not downloaded any models for embeddings. Please pull at least one embedding model, like 'nomic-embed-text' or anything else with 'embed' in its name. Also, don't forget to run a second instance of Ollama on a different port and to configure 'Embeddings URL' in settings by pointing it to that URL. This way your prompts will not slow down when you use 'memories'. I will switch off your rag setting for now, to prevent showing you this message next time. Enjoy.");
				this.ragDisable(1);
				return;
			}
			this.workingRag	=true;
			this.w(`updating rag for user ${u}`);

			let r=this.rag[u],p=[]; const old=r.v;
			r.modelEmb=this.settings.req.modelEmb.v.l[this.settings.req.modelEmb.v.v].tag;
			r.v=[];
			txt: for(let l of this.rag[u].t.split('\n')) {
				l=l.trim(); if(!l.length) continue;
				for(const o of old) {
					if (o[1]===l) {
						this.w(`using existing embedding for ${l}`);
						r.v.push(o);
						continue txt;
					}
				}
				p.push(l);
			}
			r.done=0; r.total=p.length; r.doing=true;
			this.w(`rag paragraphs: ${p.length}`);
			for(let P=0;P<p.length;P++) { //>
				const e=await this.embed(p[P]);
				if(!e.length) continue;
				r.v.push(e);
				r.done=P+1;
			}
			r.doing					=false;
			this.workingRag	=false;
		},
		cosine(A,B) {
			let dotproduct=0,mA=0,mB=0;

			this.w(`cosine ${A.length} ${B.length}`);
			for(let i=0;i<A.length;i++) {//>
				dotproduct+=A[i]*B[i];
				mA+=A[i]*A[i];
				mB+=B[i]*B[i];
			}
			mA=Math.sqrt(mA); mB=Math.sqrt(mB);

			let s=dotproduct/(mA*mB);
			this.w(`cosine ${dotproduct} ${mA} ${mB}`)
		
			return s;
		},
		async embed(txt) {
			if(txt==null||!txt.length||!this.settings.req.modelEmb.v.l.length) return;
			let opt						={};
			opt['model']			=this.settings.req.modelEmb.v.l[this.settings.req.modelEmb.v.v].tag;
			opt['prompt']			=txt.trim();
			this.w({opt:opt});
			const t=this;
			
			let r,d;
			try {
				r=await fetch(t.config.urlEmb.v+"/api/embeddings",{
					"method": "POST",
					"body": 	JSON.stringify(opt)
				});
				if(!r.ok) throw new Error(r.statusText);
			} catch(err) {
				t.w(`Error: ${err}`);
				t.rag.err=`${err}`;
				return [];
			}
			t.rag.err=null;
			d=await r.json();
			t.w(`embed received ${d.embedding}`);
			return [d.embedding,txt];
		},

		//group methods
		//user methods
		userGroupDel(g,i) {
			if(g==0&&!confirm(`This is the list of all users, if you delete character "${this.nicks[i].n}", it will be gone permanently. The messages will stay but not the character. Are you sure you wish to delete this character?`)) {
				return;
			}
			this.userGroupDelDo(g,i);
		},
		userGroupDelDo(g,i) {
			if(!this.groups[g].u[i]) return 0;
			this.w(`removing user ${i} from group ${g}`)
			const n=this.nicks[i];
			if(this.groups[g].sel[n.t]==i) {
				this.w(`user is the selected one in the group, removing.`);
				for(const j in this.groups[g].u) {
					this.w(`comparing nick ${j} with ${i}`);
					if(j==i||this.nicks[j].t!=n.t) continue;
					this.w(`found matching role user "${this.nicks[j].n}" with id ${j} in group ${g}`);
					this.groups[g].sel[n.t]=j;
					break;
				}
				if(this.groups[g].sel[n.t]==i) {
					this.w(`we have not found any other user of this type in the group, setting selected one to null`);
					this.groups[g].sel[n.t]=null;
				}
			} else {
				this.w(`user ${i} is not selected one`);
			}
			for(const u in this.groups[g].u) {
				delete this.groups[g].u[u][i];
			}
			
			this.groups[g].an[n.t]--;
			this.groups[g].an['t']--;
			delete this.groups[g].u[i];
		},
		userDel(i) {
			if(confirm(`Are you Really sure you wish to completely delete "${this.nicks[i].n}"? It won't affect the existing chat but will delete the nick and its system and instruction messages.`)) {
				this.userDelDo(i)
			}
		},
		userDelDo(i) {
			const t=this.nicks[i].t;
			for(const g in this.groups) {
				this.userGroupDelDo(g,i);
			}
			this.amountNicks['t']--;
			this.amountNicks[t]--;
			this.nicks[i].del=1;

			for(const t of this.turns) {
				for(const b of t.branches) {
					for(const m of b.msgs) {
						delete m.nicks[i];
						m.nicksArr=this.msgUserListAll({nicks:m.nicks}); //caches are so caches.
					}
				}
			}
		},
		userGroupAdd(g,u) {
			if(u==null) return;
			this.w(`adding user ${u} to group ${g}`);
			const t=this.nicks[u].t;
			this.groups[g].an['t']++;
			this.groups[g].an[t]++;
			this.groups[g].u[u]={};
			for(const i in this.groups[g].u) {
				this.groups[g].u[u][i]=true;
				this.groups[g].u[i][u]=true;
			}
			if(this.groups[g].sel[t]===null) {
				this.groups[g].sel[t]=u;
			}
		},
		groupDel(g) {
			if(this.groups.length<=1) { //>
				alert('Can not delete the only group.');
				return;
			}
			for(const i in this.groups) {
				if(i==g) continue;
				this.group=i*1; //yep
				break;
			}

			this.w(`new chosen group is ${this.group}`);
			for(const u in this.groups[g].u) {
				this.userGroupDel(g,u);
			}
			this.groups.splice(g,1);
		},
		async userAdd(t,n,d) {
			const id=this.amountNicks['idNext']++;
			this.amountNicks['t']++;
			this.amountNicks[t]++;
			this.nicks[id]		={ t:t,n:n,'id':id,del:0,system:(d.system??''),instr:(d.instr??''),sets:false,setsDo:false };
			this.nick['n'][t]	='';
			this.rag[id]=this.ragStrct();
			this.userGroupAdd(0,id);

			if(d.hasOwnProperty('mem')&&d.mem.length) {
				this.rag[id].t=d.mem;
				await this.ragU(id);
			}
			if(d.hasOwnProperty('knlg')&&d.knlg.length) {
				this.rag.g.t+='\n'+d.knlg;
				await this.ragU('g');
			}
			
			this.w({user:this.nicks[id],d:d});
			return id;
		},
		userVis(t,id) {
			//this.w(`checking vis of ${id}`);
			const u=this.nicks[id];
			//this.w(`checking vis of ${id} ${u.n}: ${u.del}`);
			if(t!==u.t) return 0;
			if(u.del==1) return 0;
			//if(!this.groups[this.group]) return 0;
			//if(!this.groups[this.group].u[u.id]) return 0;
			return 1;
		},
		userCh(t,v) {
			this.w(`userch ${t}`);
			if(t==='u') {
				this.w('chosen user nick has changed, let us update side msg if it is open and turns');
				//this.turnLastFilteredGo();
				const tbm=this.tbma(this.turn);
				if(this.msgSide(this.msga(this.turn))) this.msgSideNickUpdate(...tbm);
			}
		},
		userAiCh(v) {
			this.w('chosen ai nick has changed, let us update turns');
			//this.turnLastFilteredGo();
		},
		userTypeCh(u) {
			const t	=this.nicks[u].t;
			const tn=(t=='u'?'a':'u');
			this.nicks[u].t=tn;
			//sigh, these had to be auto but..
			for(const g in this.groups) {
				if(!this.groups[g].u[u]) continue;
				this.groups[g].an[t]--;
				this.groups[g].an[tn]++;
				if(this.groups[g].sel[t]==u) {
					for(const j in this.groups[g].u) {
						if(this.userVis(t,j)) {
							this.groups[g].sel[t]=j;
							break;
						}
					}
					if(this.groups[g].sel[t]==u) this.groups[g].sel[t]=null
				}
				if(this.groups[g].sel[tn]==null) this.groups[g].sel[tn]=u;
			}
			if(t==='u') {
				this.w(`searching for side msgs of a user`);
				this.msgSideWipe(u);
			}
			this.amountNicks[t]--;
			this.amountNicks[tn]++;
		},
		msgSideWipe(u) {
			//used when user changes type or when we move/copy branches,
			//to prevent adding branch after the side message, which is supposed to be always last.
			for(let t=1;t<this.turns.length;t++) { //>
				for(let b=0;b<this.turns[t].branches.length;b++) { //>
					let mdel=[];
					for(let m=0;m<this.turns[t].branches[b].msgs.length;m++) { //>
						const msg=this.msgGet(t,b,m);
						if((u==null||msg.nId==u)&&this.msgSide(msg)) {
							this.w(`found a sidemsg ${t}/${b}/${m}: deleting`);
							this.branchDel(t,b,m)
							m--;
						}
					}
				}
			}
		},
		async msgDelNext(t,b,m) {
			if(t<1) return; //>
			const msg=this.msgGet(t,b,m);
			if(this.working==1&&msg.working) return;
			
			const role=this.msgRole(msg);
			if(role=='a'&&this.turns[t].branches[b].msgs.length==1) {
				await this.msgMvRight(t,0,true);
			}
			this.branchDel(t,b,m);
		},
		branchMerge(t,b,m,t2,b2,mdel) {
			if(!this.delAtWork(this.$data)) return;
			this.msgSideWipe(null);
			this.branchMv(t,b,m,t2,b2);
			this.branchDel(t2,b2,mdel);
			this.turns[t2].branches[b2].msg=this.turns[t2].branches[b2].msgs.length-1;
		},
		branchMv(t,b,m,t2,b2) {
			if(!this.delAtWork(this.$data)) return;
			this.w(`Moving branch ${t}/${b}/${m} -> ${t2}/${b2}`);
			this.msgSideWipe(null);
			let branch={msgs:[]};
			this.branchCopy(branch,t+1,b,m);
			let tmp=[]; this.copy(this.turns[t].branches[b].msgs,tmp,m);
			this.turns[t2].branches[b2].msgs.push(tmp[m]);
			let m2=this.turns[t2].branches[b2].msgs.length-1;
			this.turns[t2].branches[b2].msg=m2;
			if (branch.nested) this.branchAdd(branch.nested,t2+1,b2,m2);
			this.w({turns:this.turns});
			this.branchDel(t,b,m);
			this.turns[t2].branches[b2].msg=this.turns[t2].branches[b2].msgs.length-1;
			this.branchu(0);
		},
		branchAdd(n,t,bp,mp) {
			this.w({branchAdd:'start',turn:t,n:n,bp:bp,mp:mp});
			this.msgSideWipe(null);

			this.branchu(0); //dirty patch

			if((t+1)>this.turns.length) {
				this.turnnew(t-1,-1,this.group);
				this.turns[t].branches=[];
			}
			let b=this.turns[t].branches.length;
			this.turns[t].branches.push(n.branch);
			let br=this.turns[t].branches[b];
			this.treeuDo(this.turns[t].tree,bp,mp,b);
			//this.branchu(t);
			this.w({turn:t,bp:bp,mp:mp,b:b,newTree:this.turns[t].tree})
			for(let m=0;m<br.msgs.length;m++) { //>
				if(!br.msgs[m].hasOwnProperty('nested')) {
					continue;
				}
				this.branchAdd(n.branch.msgs[m].nested,t+1,b,m);
				delete br.msgs[m].nested;
			}
		},
		branchCopy(msg,t,bp,mp) {
			this.w(`moving branch: t:${t}, bp:${bp}, mp: ${mp}`);
			if(this.turns[t]==undefined) return;
			const tree=this.turns[t].tree;
			if(tree==undefined) return;

			if(!tree.hasOwnProperty(bp)||!tree[bp].hasOwnProperty(mp)) return;
			msg.nested={}; let n=msg.nested;

			let b=this.turns[t].tree[bp][mp];
			let tmp={};	this.copy(this.turns[t].branches,tmp,b);
			n.branch=tmp[b];
			for(let i=0;i<n.branch.msgs.length;i++) { //>
				let m=n.branch.msgs[i];
				this.branchCopy(m,t+1,b,i);
			}
		},
		branchDel(t,bp,mp) {
			if(!this.delAtWork(this.$data)) return;
			this.w({branchDel:'start',t:t,bp:bp,mp:mp});

			this.branchDelNext(t+1,bp,mp);
			//we need to delete the message at this turn,
			//so in the next one we will shift index ids, if the next turn exists.
			if(this.turns[t+1]!=undefined) this.treeDelShift(this.turns[t].branches[bp].msgs.length-1,this.turns[t+1].tree[bp],mp);
			
			if(this.turns[t].branches[bp].msgs.length>(mp+1)) {
				this.turns[t].branches[bp].msg=mp;
			} else if (mp>0) {
				this.turns[t].branches[bp].msg=mp-1;
			} else {
				//empty turn
			}
			
			this.turns[t].branches[bp].msgs.splice(mp,1);
			//if the branch is empty, let's delete the branch
			if(!this.turns[t].branches[bp].msgs.length) {
				//but for this we need first to find the parent branch/msg ids, to update the next turns index
				let pb,pm;
				for(const i in this.turns[t].tree) {
					for(const j in this.turns[t].tree[i]) {
						if(this.turns[t].tree[i][j]==bp) {
							pb=i;pm=j;
							break;
						}
					}
				}
				//del current emptied branch and shift everything below.
				this.branchDelNext(t,pb,pm);
			}
			
			//delete the turn if it was emptied.
			this.branchDelTurnDel(t);
			
			this.branchu(t);
		},
		branchDelNext(t,bp,mpo) {
			if(this.turns[t]==undefined) return;
			
			this.w(`deleting branch: t:${t}, bp:${bp}`);

			let del=[];
			
			for(const mp in this.turns[t].tree[bp]) {
				//for the first nested level we delete only 1 nested branch of the parent branch/msg, 
				//as other nested branches are tied to other parent messages that are still there.
				//but for the rest of levels we delete all nested branches for all parent messages as the whole tree gets deleted.
				if(mpo!=null&&mp!=mpo) continue;
				let b=this.turns[t].tree[bp][mp];

				this.branchDelNext(t+1,b,null);
				
				del.push(b);
				if(this.turns[t].branch==b) this.turns[t].branch=-1;
			}

			//process from end to beginning, so branch indexes to delete are not changed by deletions
			del.sort((a,b)=>b-a);
			this.w({delBranch:del});
			for(let d=0;d<del.length;d++) { //>
				let b=del[d];
				this.branchDelDo(t,b);
			}
			//del the turn if it was emptied.
			this.branchDelTurnDel(t);

			this.branchu(t);
		},
		branchDelTurnDel(t) {
			if(t>=this.turns.length) return;

			if(this.turns[t].branches.length==0) {
				this.w({turndel:'no branches',turn:t,brLen:this.turns[t].branches.length});
				this.turns.splice(t);
				return true;
			}
			let count=0;
			for(const b of this.turns[t].branches) {
				count+=b.msgs.length;
				//this.w({turndelcount:'goes', msgsl:b.msgs.length,turn:t,b:b})
			}

			if(!count) {
				this.w({turndel:'no msgs',turn:t,brLen:this.turns[t].branches.length,msgs:count});
				this.turns.splice(t);
			}

			return count==0?true:false
		},
		branchDelDo(t,b) {
			this.w(`Deleting all local branches at ${t}: parent branch ${b}`);
			this.treeDelShiftLocal(t,b);
			this.treeDelShiftNested(t,b);
			this.turns[t].branches.splice(b,1);
		},
		treeDelShiftNested(t,b) {
			this.w(`Tree del shift at turn ${t} ${t+1}>=${this.turns.length}`);
			if((t+1)>=this.turns.length) return;
			this.w(`Doing tree del shift at turn ${t}`);
			this.treeDelShift(this.turns[t].branches.length-1,this.turns[t+1].tree,b);
		},
		treeDelShiftLocal(t,b) {
			//we have deleted a local branch, now the values pointing to the rest of them are wrong
			//lets go and shift them.
			this.w({treelocaldel:this.turns[t].tree});
			for(const i in this.turns[t].tree) {
				for(const j in this.turns[t].tree[i]) {
					if(this.turns[t].tree[i][j]>b) {
						this.turns[t].tree[i][j]--;
					} else if (this.turns[t].tree[i][j]==b) {
						delete this.turns[t].tree[i][j];
					}
				}
			}
			this.w({treelocaldeldone:this.turns[t].tree});
		},
		treeDelShift(total,tree,i) {
			//we have deleted parent element - branch or message, now the index is wrong
			//let's go over the index and shift keys linking parent elemets to local branches.
			this.w(`The element #${i} is ${total-i} positions from the end`);
			if(tree==undefined) {
				this.w(`tree index doesn't exist`);
				return;
			}
			this.w({treedel:tree,e:i+1,l:total});
			delete tree[i];
			let ps=Object.keys(tree).filter(k=>k>i).sort((a,b)=>a-b);
			this.w({parentIdsToShift:ps});
			//for(let e=i*1+1;e<=total;e++) { //>
			for(const e of ps) { //>
				this.w(`Updating index tree ${e} -> ${e-1}`);
				tree[e-1]=tree[e];
				delete tree[e];
			}
			this.w({treedeldone:tree})
		},
		groupAdd(n,u) {
			if(!n.length) {
				alert('Please, give it a name');
				return;
			}
			this.groups.push(this.groupTmpl(n,u));
			for(const i of u) {
				this.userGroupAdd(this.groups.length-1,i);
			}
			this.group=this.groups.length-1;
		},
		groupTmpl(n,u) {
			let g={u:{},sel:{u:null,a:null,s:null},an:{u:0,a:0,s:0,t:0}};
			g.n	=n;
			return g;
		},
		groupPrev() {
			if(this.group>0) this.group--;
		},
		groupNext() {
			if(this.group<(this.groups.length-1)) this.group++; //>
		},
		userS(t) {
			const u=this.userSelected(t);
			//this.w(`returning select user ${t}=${u}`);
			return u;
		},
		userSelected(t) {
			if(!this.groups[this.group]) return null;
			return this.groups[this.group]['sel'][t];
		},
		copy(o,on,k) {
			//this.w({parsing:o})
			if(o[k]==null) {
				on[k]=null
			} else if(Array.isArray(o[k])) {
				on[k]=[];
				//this.w(`copying arr ${k}`);
				for(const i in o[k]) { this.copy(o[k],on[k],i) }
			} else if(typeof o[k]==='object') {
				on[k]={};
				//this.w(`copying object ${k}`);
				for(const i in o[k]) { this.copy(o[k],on[k],i) }
			} else {
				//this.w(`copying val ${k}`);
				on[k]=o[k];
			}
		},
		userSetsPerAi(id) {
			if(id==null) return;
			const u=this.nicks[id];
			console.log(`personal sets sets for ${id}: ${u.setsDo}`)
			if(u.setsDo) {
				if(!u.hasOwnProperty('settings')) {
					u.config							={...this.configGlobal};
					u.settings={};
					u.settings['req']			={...this.settingsGlobal.req};
					u.settings['options']	={...this.settingsGlobal.options};
					this.copy(this.$data,u,'settingsGlobal');
					this.copy(this.$data,u,'configGlobal');
					u.settings=u.settingsGlobal; 	delete u.settingsGlobal;
					u.config	=u.configGlobal; 		delete u.configGlobal;
					u.settings.req.model.v.l=computed(()=>this.models);
					u.settings.req.modelEmb.v.l=computed(()=>this.modelsEmb);
				}
			}
			u.sets=u.setsDo;
		},
		
		//turn methods
		tbma(t) {
			return [t,this.branch(t),this.brancha(t).msg];
		},
		async turnUp() {
			event.preventDefault();

			if(this.turn<=1) return; //>
			const start=this.turn;

			let atVisible=!this.msgSkipped(...this.tbma(this.turn));
			while(!atVisible&&this.turn>1) {
				this.turn--;
				atVisible=!this.msgSkipped(...this.tbma(this.turn));
			}
			if(start!==this.turn) return;
			this.turn--;
			while(this.msgSkipped(...this.tbma(this.turn))&&this.turn>1&&atVisible) {
				this.w(`we went up one message at turn ${this.turn} but it's hidden, let's go higher`)
				atVisible++;
				this.turn--;
			}
			this.w(`stop at turn ${this.turn}`);
			await nextTick();
			this.scroll(null,0);
		},
		async turnDown(m) {
			event.preventDefault();

			const last=this.turnLast(this.turn);
			let lastv=null;
			
			if(m) {
				this.turn=last;
				await nextTick();
				this.scroll(null,0);
				return;
			}
			
			if(!this.turnNotLast(this.turn)) return;
			
			lastv=this.turn;
			let t=this.turn+1;
			while(t<=last) { //>
				this.w(`trying next turn ${t}`);
				if(!this.msgSkipped(...this.tbma(t))) {
					lastv=t;
					break;
				}
				t++;
			}
			if(t>last) t=last;
			//this.turn=lastv; //it was a different logic attempt but interface was not good
			this.turn=t;
			
			await nextTick();
			this.scroll(null,0);
		},
		turnLastFilteredGo() {
			this.turnDown(1)
		},
		turnNotLast(t) {
			if(t>=(this.turns.length-1)) return null;
			if(this.turns[t+1].branch==-1) return null;
			return 1;
		},
		turnOff(t) {
			this.turnBranchSet(t,-1);
		},
		turnwhose(turn) {
			//sets the legacy turn.role which should not be used anymore
			this.w(`searching for whose turn is at ${turn}`);
			let prev	=this.turns[turn-1];
			let ai		=prev.role=='user'?1:0;
			this.w(`new turn type is ai: ${ai}`);
			return ai;
		},
		turnnew(turn,u,g) {
			turn++;
			this.w(`generating new turn #${turn}`);
			if(this.turns[turn]) {
				this.w(`next turn is already there, skipping creation of the turn`);
			} else {
				this.w(`the turn ${turn} doesn't exist, let's create it`);
				let ai=this.turnwhose(turn);
				this.turns.push({
					'role':	(ai?'assistant':'user'), //should not be used anymore
					'branches':[],
					'branch':0,
					'tree':{},
				});
				this.turns[this.turns.length-1].tree[this.turns[turn-1].branch]={};
			}
			this.turn=turn;
			this.w(`set turn to ${turn}`);
			this.w(`initialize the first branch at turn ${turn}`);
			this.branchNew(turn,u,g);
			this.w({'current turn':this.turns[turn]});
		},
		turnBranchSet(t,b) {
			this.turns[t].branch=b;
		},
		turnLast(t) {
			const start=t;
			while(this.turns[t]&&this.turns[t].branch!==-1) {
				t++;
			}
			this.w(`turn last ${t} turn start ${start}`)
			return t-1;
		},
		turnRole(t) {
			//should not be used anymore
			return this.turns[t].role;
		},
		
		send(e,m,i) {
			if(e.key==='Enter'&&e.shiftKey) {
				return;
			}
			this.chat(m,i,true);
		},
		
		//branch methods
		branchNew(turn,u,g) {
			this.w(`adding new branch at ${turn}`)
			if(!this.turns[turn]) return;
			const prev	=this.turns[turn-1];
			this.w(`prev branch: ${prev.branch}`);

			const prevm =prev.branches[prev.branch].msg;
			let bnew		=0;
			let b				='';
			if(!this.turns[turn].tree[prev.branch]) bnew=1;
			if(!bnew) {
				b			=this.turns[turn].tree[prev.branch][prevm];
				bnew	=(b&&this.turns[turn].branches[b])?0:1;
			}
			if(!bnew) {
				this.w(`branch for the msg ${prevm} in turn ${turn} already exists: ${b}`);
			} else {
				this.w(`creating new branch at turn ${turn}`)
				this.turns[turn].branches.push(this.branchTmpl(turn,u,g));
				b=this.turns[turn].branches.length-1;
			}
			this.turnBranchSet(turn,b);
			this.w(`new branch id: ${b}`);
			this.w({'created branch in turn':turn,'branch':this.turns[turn].branches[this.turns[turn].branch]});
			if(bnew) this.treeu(turn);
		},
		branchTmpl(turn,u,g) {
			this.w(`adding branch to turn ${turn}`);
			return { rated:false,msg:0,msgs:[this.msgTmpl(u,null,g)] }
		},
		branch(turn) {
			return this.turns[turn].branch
		},
		brancha(turn) {
			//console.trace();
	    return this.turns[turn].branches[this.branch(turn)];
		},
		branchNested(turn) {
			this.w(`searching for nested branch at ${turn} for parent active message`);
			const prev=turn-1;
			const bprev=this.branch(prev);
			const tr	=this.turns[turn].tree[bprev]; //tree[prev branch id]
			this.w({'index value for parent branch':bprev,'tr':tr});
			if(!tr) return [null,null];
			const bn=tr[this.brancha(prev).msg]; //prev turn's branch/msg -> this branch id
			this.w(`index value of a local branch for the active message in parent branch: ${bn}`);
			if(bn==undefined) return [null,null];
			return [bn,this.turns[turn].branches[bn]];
		},
		branchu(turn) {
			this.w(`updating active branches for turn ${turn}`);
			let turnIncomplete=this.turns.length;
			for(let i=turn+1;i<this.turns.length;i++) {//>
				this.w(`processing turn ${i}`);
				let [bn,b]=this.branchNested(i);
				if(bn==undefined||!this.msgInited(i,bn,b.msg)) {
					turnIncomplete=i;
					this.w({'leaving updating, setting turn':turnIncomplete,'branch':b,bn:bn});
					break;
				}
				this.w(`updating turn: ${i}, branch ${this.turns[i].branch} -> ${bn} (content: ${b.msgs[b.msg].content3.a})`);
				this.turnBranchSet(i,bn);
			}
			
			for(let i=turnIncomplete;i<this.turns.length;i++) {//>
				this.w(`dropping branch for turn ${i}`);
				if(this.turns[i].branch==-1) break; //optimization, tho probably we don't even have to mark everything below? just 1.. 
				this.turnOff(i);
			}
			this.turn=turnIncomplete-1;
			this.w(`branchu sets turns to ${this.turn}`);
		},
		treeu(turn) {
			this.w(`updating index tree at ${turn}`);
			let prev=this.turns[turn-1];
			this.treeuDo(this.turns[turn].tree,prev.branch,prev.branches[prev.branch].msg,this.turns[turn].branch);
		},
		treeuDo(tree,bp,mp,b) {
			this.w(`Creating tree index for parents: ${bp}, ${mp}, local: ${b}`);
			if(!tree[bp]) tree[bp]={};
			tree[bp][mp]=b;
		},
		
		
		//msg methods
		msgTmpl(u,c,g) {
			this.w(`adding message template for ${u}`);
			let nicks={};
			if(g!=null) {
				for(const i in this.groups[g].u[u]) {
					if(!this.groups[g].u[u][i]) continue;
					this.w(`adding user ${i} to visible list`);
					nicks[i]=true;
				}
			}
			nicks[u]=true;
			return {
				content:	(c!=undefined?c:null),
				content3: {
					e:			null,
					th:			null,
					a:			(c!=undefined?c:null)
				},
				'nick':			this.nicks[u].n,
				'nId':			u,
				'tp':				{},
				'tr':				{},
				'rating':		null,
				status:			this.msgStatusId('new'),
				edited:			null,
				nicks: 			nicks, //for easier access
				nicksArr:		this.msgUserListAll({nicks:nicks}) //to avoid sorting every time chat is updated
			}
		},
		msgNew(turn,u,u2,c,g) {
			this.w(`adding new message to turn ${turn}, u:${u}, u2:${u2}, c:${c}, g:${g}`);
			let b=this.brancha(turn)
			let m=this.msgTmpl(u,c,g);
			
			if(b.msgs[b.msg].status==null) {
				b.msgs[b.msg]=m;
			} else {
				b.msgs.push(m);
			}
			b.msg=this.msgTotal(turn,this.branch(turn))-1;
			if(u2!=null) {
				this.w(`Attention, skipping creation of a pair message, because second user id is not specified. Can be normal for loading cards only right now.`)
				this.branchNew(turn+1,u2,g);
			}
		},
		msgGet(t,b,m) {
			return this.turns[t].branches[b].msgs[m];
		},
		msgWaiting(m) {
			if(m.status==null)	return 1;
			if(m.status==0)			return 1;
			return 0;
		},
		msgTotal(t,b) {
			return this.turns[t].branches[b].msgs.length;
		},
		msgEmpty(t,b,m) {
			const msg=this.msgGet(t,b,m);
			//this.w({msg:msg});
			return this.msgEmptyDo(msg);
		},
		msgEmptyDo(msg) {
			if(msg.images&&msg.images.length) return 0;
			if(!this.config.trinity.v) {
				if(msg.content==null) return 1;
				if(!msg.content.length) return 1;
			} else {
				let count=0,total=0;
				for(const s in msg.content3) {
					total++;
					if(msg.content3[s]==null||!msg.content3[s].length) count++;
				}
				if(count===total) return 1;
			}
			return 0;
		},
		msgMvLeft(t) {
			let b=this.brancha(t);
			if(b.msg==0) return;
			b.msg--;
			this.branchu(t);
			this.turn=t;
			this.msgSideNickUpdate(...this.tbma(t));
		},
		async msgMvRight(t,wSideRating,aw) {
			this.w(`moving right at turn ${t}, siderating: ${wSideRating}`);
			let b=this.brancha(t);
			if(!this.msgLast(t,this.turns[t].branch)&&!wSideRating) {
				this.w(`it's not the last message: {b.msg}`);
				b.msg++;
				this.branchu(t);
				this.turn=t;
				this.msgSideNickUpdate(...this.tbma(t));
				return;
			}
			//add new message
			if(this.working) {
				this.w('working right now, leaving');
				return 0;
			}
			if(this.msgSide(this.msga(t))) return;
			let res;
			if(!aw) {
				this.chat((wSideRating?3:2),t,aw);
			} else {
				res=await this.chat((wSideRating?3:2),t,aw);
			}
			return res;
		},
		msgSide(msg) {
			if(msg.side==1) return 1;
			return 0;
		},
		msgLast(t,b) {
			let br=this.turns[t].branches[b];
			if(br.msg>=(this.msgTotal(t,b)-1)) return 1;
			return 0;
		},
		msgIndex(t,b) {
			return this.turns[t].branches[b].msg;
		},
		msgaStatusSet(t,s) {
			let tmp=this.tbma(t);
			this.msgStatusSet(...tmp,s);
		},
		msgStatusSet(t,b,m,s) {
			let msg=this.msgGet(t,b,m);
			this.msgStatusSetDo(msg,s);
		},
		msgStatusSetDo(m,s) {
			m.status=this.msgStatusId(s);
			this.w(`set status: ${m.status} ${s}`);
			let status={waiting:0,loading:0,done:0,error:0,working:0};
			if(this.msgWaiting(m)) {
				status.waiting=1;
			} else if (m.status==3){
				status.loading=1;
			} else if (m.status==1){
				status.done=1;
			} else if (m.status==4){
				status.error=1;
			}
			if(m.status==0||m.status==3||m.status==5||m.status==6||m.status==7||m.status==null) {
				status.working=1;
			}

			for(const i in status) {
				m[i]=status[i];
			}
		},
		msgStatusId2W(m) {
			if(m==null)				return 'new';
			if(m==0)					return 'waiting';
			if(m==1)					return 'done';
			if(m==2)					return 'cancel';
			if(m==3)					return 'loading';
			if(m==4)					return 'error';
			if(m==5)					return 'embedding prompt';
			if(m==6)					return 'embedding search';
			if(m==7)					return 'templating';
			throw new Error(`unknown status ${m}`);
		},
		msgStatusId(m) {
			if(m==='new') 							return null;
			if(m==='waiting') 					return 0;
			if(m==='done') 							return 1;
			if(m==='cancel') 						return 2;
			if(m==='loading') 					return 3;
			if(m==='error') 						return 4;
			if(m==='embedding prompt')	return 5;
			if(m==='embedding search') 	return 6;
			if(m==='templating') 				return 7;
			throw new Error(`unknown status ${m}`);
		},
		msgEditable(m) {
			if(m.status==1||m.status==2||m.status==4) return true;
			return false;
		},
		msgInited(t,b,m) {
			let msg=this.msgGet(t,b,m);
			//this.w(`msginited: ${t}/${b}/${m}: status=${msg.status}`);
			return msg.status!=this.msgStatusId('new');
		},
		msgSideNickUpdate(t,b,m) {
			//as we store non-normalized links, we have to update manually.
			const msg=this.msgGet(t,b,m);
			if(!this.msgSide(msg)) return 0;
			if(this.msgRole(msg)!=='u') return 0;
			this.w(`it's an unsent user side message, let's update the nick`);
			this.msgNickSet(t,b,m,this.userS("u"));
		},
		msgNickSet(t,b,m,u) {
			const msg=this.msgGet(t,b,m);
			msg.nick=this.nicks[u].n;
			msg.nId	=u;
		},
		scroll(id,top) {
			this.w(`scroll to ${id}`);
			let to=top?"start":"end";
			try {
				if(!id) {
					if(this.config.chatHeight.v!=''&&this.config.chatHeight.v>0) document.getElementById('chatLogEnd').scrollIntoView({ behavior:'smooth',block:to,inline:"nearest" });
					document.getElementById('prompt').scrollIntoView({ behavior:'smooth',block:to,inline:"nearest" });
				} else {
					document.getElementById(id).scrollIntoView({ behavior:'smooth',block:to,inline:"nearest" });
				}
			} catch(e) {
				this.w(`couldn't find id to scroll to: ${id}`)
			}
		},
		msgRating(i,m,v) {
			if(m.rating==v) {
				m.rating=null;
			} else {
				m.rating=v;
			}
			let brated=0;
			for(let j of this.msgsa(i)) {
				if(j.rating!=null&&j.rating!=='') {
					brated=1;
					break;
				}
			}
			this.brancha(i).rated=brated?true:false;
			this.w(`branch is rated=${this.brancha(i).rated}`);
		},
		msga(turn) {
			const b=this.brancha(turn);
			return b.msgs[b.msg];
		},
		msgsa(turn) {
			return this.brancha(turn).msgs;
		},
		msgUserAdd(msg,u,id) {
			msg.nicks[u]=true;
			msg.nicksArr=this.msgUserListAll({nicks:msg.nicks}); //re-sort
			this.w(`delete add user list ${id}`)
			delete this.msgUserListOn[id];
		},
		msgUserDel(msg,u) {
			if(!confirm(`Are you sure you wish to delete character ${this.nicks[u].n} from the access list of this message? If you do that, this character will not see the message anymore.`)) return 0;
			delete msg.nicks[u];
			msg.nicksArr=this.msgUserListAll({nicks:msg.nicks}); //re-build to remove erased one
		},
		msgUserListAvail(msg,t,g) {
			let users=[];
			for(const u in this.groups[g].u) {
				//this.w(`${this.userVis(t,u)} ${!msg.nicks.hasOwnProperty(u)}`)
				if(this.userVis(t,u)&&!msg.nicks.hasOwnProperty(u)) {
					users.push(u);
				}
			}
			//this.w({'available users':users});
			return users.sort((a,b)=>(this.nicks[a].n.localeCompare(this.nicks[b].n)));
		},
		msgUserListAllAvail(msg,g) {
			let users=[];
			users.push(...this.msgUserListAvail(msg,"u",g));
			users.push(...this.msgUserListAvail(msg,"a",g));
//			this.w(`${users}`);
			return users;
		},
		msgUserList(msg,t) {
			let users=[];
			for(const u in msg.nicks) {
				this.w(`checking if ${u} ${t} is visible the msg list`);
				if(this.userVis(t,u)&&msg.nicks[u]) users.push(u);
			}
			return users.sort((a,b)=>(this.nicks[a].n.localeCompare(this.nicks[b].n)));
		},
		msgUserListAll(msg) {
			let users=[];
			users.push(...this.msgUserList(msg,"u"));
			users.push(...this.msgUserList(msg,"a"));
			this.w(`list all users of the message: ${users}`);
			return users;
		},
		msgC3ToC(m) {
			m.content=this.msgC3To1(m);
		},
		msgC3To1(m) {
			let c='';
			for(const s in m.content3) {
				if(m.content3[s]!=null&&m.content3[s].length) c+=m.content3[s]+'\n\n';
			}
			return c.trim();
		},
		msgContentAdd(m,trinity,c,owContent) {
			if(!trinity) {
				m.content+=c;
				if(owContent) m.content3.a+=c;
			} else {
				m.content3[trinity]+=c;
				if(owContent) this.msgC3ToC(m);
			}
		},
		msgContentSet(m,trinity,c,owContent) {
			if(!trinity) {
				m.content=c;
				if(owContent) m.content3.a=c;
			} else {
				m.content3[trinity]=c;
				if(owContent) this.msgC3ToC(m);
			}
		},
		msgContent(m,trinity,u) {
			if(!trinity) {
				return m.content;
			}
			
			//no access to anything else
			if(this.nicks[u].t==='a'&&u!=m.nId) return m.content3.a;
			
			if(trinity===true||trinity==1) {
				return this.msgC3To1(m);
			} else {
				return m.content3[trinity];
			}
		},

		//chat methods
		async chat(m,turn,aw) {
			if(event!=null) event.preventDefault();
			if(this.working||this.workingRag) {
				this.w('can not do chat, working already');
				return;
			}
			this.working=1;
			this.w(`chat mode: ${m} turn: ${turn}`);
			let prompt=this.prompt.trim();
			let rag=this.config.rag.v;
			const uid=this.userS("u"),aid=this.userS("a");
			
			if(!turn) {
				turn=this.turn;
				this.w(`turn is not defined, getting current one: ${turn}`);
				const msg=this.msga(turn);
				if(this.msgRole(msg)==='u') {
					this.w('we are at the user turn, so let us check if it is a side message or not');
					if(!this.msgSide(msg)) {
						this.w("it's not a side message and the current turn belongs to a user.");
						//this.w("it's not a side message and the current turn belongs to a user, can't send two user turns in line");
						//alert("You can not reply to your own message");
						//this.working=0;
						//return;
					} else if(this.turnNotLast(turn)) {
						this.w(`it's not the last turn, let's convert this to a side message request`);
						this.chatUserSide(turn,prompt,uid,aid);
					}
				} else {
					this.w("it's a reply to AI turn, let's see if we need to make it a side message or a first one");
					if(this.turnNotLast(turn)) {
						this.w(`it's not the last turn, let's convert this to a side message request`);
						this.turn=turn=turn+1;
						this.chatUserSide(turn,prompt,uid,aid);
					}
				}
			}
			let ms=[],final;
			const side=this.msgSide(this.msga(turn));
			this.w(`chat at turn ${turn}`);
			this.w(`reply by user ${uid} (${this.nicks[uid].n})`);
			let tbm=[];
			
			if(m===1) {
				this.w('user is sending new msg');
				if(side) {
					this.w(`it's a user side message, turn--`);
					turn--;
				} else {
					this.w("create a next turn/branch");
					this.turnnew(turn,uid,this.group);
				}
				
				turn++;
				let b=this.brancha(turn);
				//empty message was already created with the branch creation,
				//either at new turn creation or with the parent side message creation.
				b.msgs[b.msg]=this.msgTmpl(uid,prompt,this.group);
				this.msgaStatusSet(turn,'done');
				this.prompt='';
				this.turnnew(turn,aid,this.group);
				tbm=this.tbma(turn+1);
				ms=await this.chatForAi({ turn:turn,uId:uid,aId:aid,sideReplyWRating:0,msg:this.msgGet(...tbm) });
				turn++;
			} else if (m===2||m===3) {
				this.w('user is asking for a new side message');
				this.prompt='';
				//we will get the message type according to the current one.
				//if it's user, we will get next user message, if it's ai, we will get ai one.

				if(this.msgRole(this.msga(turn))==='u'||turn==1) {
					this.chatUserSide(turn,null,uid,aid);
					this.working=0;
					return;
				} else {
					this.msgNew(turn,aid,uid,null,this.group);
					this.branchu(turn);
					tbm=this.tbma(turn);
					this.w(`user is asking for a new ai message, mode=${m}`);
					ms=await this.chatForAi({ turn:turn-1,uId:uid,aId:aid,sideReplyWRating:(m===3?1:0),msg:this.msgGet(...tbm) });
				}
			}
			
			if(aw) {
				await this.chatSend(ms);
				this.w('finished waiting for chatsend');
			} else {
				this.chatSend(ms);
				this.w('not waiting for chatsend');
			}

			this.working=0;
			if(!this.opt.run) this.scroll(null,0);
			
			return tbm;
		},
		async chatSend(ms) {
			let m=ms.msg;
			let opt						=this.chatOptions();
			opt['stream']			=this.stream;
			opt['raw']				=ms.raw;
			
			//opt['messages']		=msgs;
				
			const t=this;
			const rrtp		=new RegExp(`${t.rgEsc(t.chatRatingMod(1,''))}`,'g');
			const rrtm		=new RegExp(`${t.rgEsc(t.chatRatingMod(0,''))}`,'g');
			const rn			=new RegExp('^\\s*(?:as )?'+t.rgEsc(m.nick)+':[\\s\\r\\n]*','gim');
			const remoji	=new RegExp('[\\p{Extended_Pictographic}\\p{Emoji_Modifier_Base}\\p{Emoji_Presentation}]*','gum');
			let tmp;

			trt: for(let trt of ms.extra) {

				if(Array.isArray(trt)) {
					if(trt[1]==null) continue trt;
					ms.final.push(trt[1]);
					trt=trt[0];
				} else {
					trt=false;
				}
				
				const endpoint={
					chat:{
						url:	"/api/chat",
						param:'messages',
						resp:	['message','content']
					},
					generate: {
						url:	"/api/generate",
						param:'prompt',
						images: 'images',
						resp:	['response']
					}
				};

				const ep=ms.raw?'generate':'chat';
				
				const final=t.chatAiMs2Tmpl(ms);
				opt[endpoint[ep].param]=final.prompt;

				if(final.images.length) {
					if(!endpoint[ep].hasOwnProperty('images')) {
						this.w(`Don't know how to use images for endpoint ${ep}!`)
					} else {
						opt[endpoint[ep].images]=final.images;
						for(const im in final.images) {
							//opt[endpoint[ep].param]+=` [img-${im}] `
						}
					}
				}
				
				t.w({body:opt});
				t.msgStatusSetDo(m,'waiting');
				let res='',buf='',r='',bufValue=''; t.msgContentSet(m,trt,'',true);
				
				try {
					r=await fetch(t.url()+endpoint[ep].url,{
						"method": "POST",
						"body": 	JSON.stringify(opt)
					});
					if(!r.ok) throw new Error(r.statusText);
				} catch(err) {
					t.w(`error: ${err}`);
					t.connectionErr=`${err}`; //weird but lol
					t.connection=0;
					t.cancel		=0;
					this.msgContentSet(m,trt,`${err}`,true);
					t.msgStatusSetDo(m,'error');
					return 'error';
				};

				const reader	=r.body.getReader();
				const decoder	=new TextDecoder('utf-8');
				let errorJson	=false;

				main: while(true) {
					const {done,value}=await reader.read();
					t.w('dissecting response');
					
					if(done) {
						t.msgContentAdd(m,trt,buf,true);
						t.w({'Stream complete':res});
						//there is a bug when ollama might not send anything for prompt_eval_count
						if(res.hasOwnProperty('eval_count')) m.tr[t.models[t.settings.req.model.v.v].n]+=res.eval_count;
						if(res.hasOwnProperty('prompt_eval_count')) m.tp[t.models[t.settings.req.model.v.v].n]+=res.prompt_eval_count;
						//t.cancel=0;
						break;
					}
					
					if(t.cancel) {
						t.w('cancelling');
						errorJson=false;
						t.msgContentAdd(m,trt,buf,true);
						reader.cancel();
						reader.releaseLock();
						break;
					}
    
					bufValue+=decoder.decode(value);

					errorJson=false;
					const splitter='\n',parsed=[];
					const chnks=bufValue.split(splitter);
					t.w({cnks:chnks})

					for (let CH=0;CH<chnks.length;CH++) { //>
						let ch=chnks[CH];
						if(!ch.length) continue;

						try { 
							parsed.push(JSON.parse(ch));
							this.w({bv:bufValue,chl:ch.length,ch:ch});
							bufValue=bufValue.substr(ch.length+1);
							this.w({bvCutten:bufValue});
							this.w(`parsed a new chunk of ${ch.length} bytes`);
						} catch (error) {
							console.error(error);
							this.w({error:`error parsing json ${error}, chunk ${CH} let's try to get next part of the data and try again.`,chunk:ch});
							t.w({bufValLenAtRetry:bufValue.length,bf:bufValue});
							errorJson=error;
							break;
						}
					}
					this.w(`parsed a ${parsed.length} chunks, processing`);
					//bufValue='';
					for(let res of parsed) {
						let rf=res;
						for(const p of endpoint[ep].resp) { rf=rf[p] }

						buf+=rf;
						
						//t.w(`${buf} ${rn}`)
						buf=buf.replace(rrtp,'').replace(rrtm,'').replace(rn,'');
						if(t.config.emojiNo.v) buf=buf.replace(remoji,'');
						m.trm++;
						if(m.status==0) {
							if(t.config.resClean.v) {
								if(buf.length<t.config.resBufCleanSize.v) {//>
									t.w(`accumulating buffer at start ${buf}`);
									//return reader.read().then(processText);
									continue;
								}
							}
							t.msgStatusSetDo(m,'loading');
						}
						t.msgContentAdd(m,trt,buf,true);
						if(ms.hasOwnProperty('func')&&ms.func!=null) {
							ms.func(m.content,ms.d);
						}
						buf='';
					}
				}

				//t.cancel=0;
				let content=t.msgContent(m,trt,m.nId);
				if(t.config.resClean.v) {
					content=content.trim().replace(rrtp,'').replace(rrtm,'').replace(rn,'');
				}
				if(t.config.emojiNo.v) {
					content=content.replace(remoji,'');
				}
				t.msgContentSet(m,trt,content,true);

				if(errorJson!=false) {
					t.w({'error':errorJson});
					t.connectionErr=`${errorJson}`; //weird but lol
					t.connection=0;
					t.msgContentAdd(m,trt,errorJson,true);
					break trt;
				}

				if(trt!=false) this.chatFinalPush(ms.final,{
					nId:			m.nId,
					nick:			ms.nicks.l[m.nId].n,
					content:	this.msgContent(m,trt,m.nId),
					rating:		'',
					images:		[],
				});
				//t.chatAiMsTmpl(content,'assistant',m.nId,m.nick,'',null,content)

				if(t.cancel) break;
			}
			t.w(`chat received`);

			//t.working=0;
			if(t.connection==0) {
				t.msgStatusSetDo(m,'error');
			} else if(t.cancel) {
				t.msgStatusSetDo(m,'cancel');
			} else {
				t.msgStatusSetDo(m,'done');
			}
			t.cancel=0;
		},
		chatForAiConfig(h) {
			const cfgParams=['trinity','stories','replyWithRating','rag','instrWithSideRating','raw','namesAdd','aiIsYou','otherAiAsUser','imgsLastOnly','rawLog','rawTmpl','noAiReplyToSelf','rooms','trinityReqTh','trinityReqA','trinityChancesTh','noReplyToSelf','emptyToSth','emptyToTxt'];
			for(const p of cfgParams) {
				if(h.hasOwnProperty(p)) continue;
				h[p]=this.config[p].v;
			}
		},
		storiesMsgVisible(m,aId) {
			if(m.nId!=this.nick['s']&&!m.nicks[aId]) return false;
			return true;
		},
		ragDisable(m) {
			this.config.rag.v=false;
			if(!m) return;
			for(const nick in this.nicks) {
				if(!this.nicks[nick].hasOwnProperty('settings')) continue;
				this.nicks[nick].config.rag.v=false;
			}
		},
		chatMsNicks(h) {
			let nicks={l:{},ai:h.aId,uid:h.uId};
			for(let n in this.nicks) {
				nicks.l[n]={ n:this.nicks[n].n,id:n,t:this.nicks[n].t };
			}
			return nicks;
		},
		async chatForAi(h) {
			this.chatForAiConfig(h);
			let ms={},add=[],sh=this.shuffle();

			this.w(`building list of chat for ai ${h.aId} ${this.nicks[h.aId].n}, up to ${h.turn}`);
			this.w({data:h});

			let adds={
				rag:[],
				instr:'',
				nredo:[],
				predo:[],
				wRating:'',
				wSideRating:'',
			};

			if(this.imgs.length) {
				this.w(`The prompt has ${this.imgs.length} images, let's add.`);
				this.msga(h.turn).images=[];
				for(const img of this.imgs) {
					this.msga(h.turn).images.push({c:img,s:0});
				}
				this.imgs=[];
			} else { this.w(`no images in the prompt`) }
			
			
			let final=[],ratingUsed=0;
			for(let i=1;i<=h.turn;i++) { //>
				let msg=this.msga(i);
				let content=this.msgContent(msg,h.trinity,h.aId).trim();
				if(content===''&&h.emptyToSth) {
					this.w(`Replacing empty msg #${i} from ${this.nicks[msg.nId].n} with ${h.emptyToTxt}`);
					content=h.emptyToTxt;
				}
				if(content===''&&!h.emptyToSth) {
					this.w(`skipping empty msg #${i} from ${this.nicks[msg.nId].n}`);
					continue;
				}
				if(h.stories&&!this.storiesMsgVisible(msg,h.aId)) {
					this.w(`Skipping msg #i due to stories`);
					continue;
				}
				let images=(msg.hasOwnProperty('images')&&msg.images.length)?msg.images.map(img=>img.c):[];
				let rating='';
				if(msg.rating!=null&&msg.rating!==''&&msg.nId==h.aId) {
					rating=msg.rating;
					if(!ratingUsed) {
						this.w(`found a set rating: ${msg.rating}`)
						ratingUsed++;
					}
				}
				this.chatFinalPush(final,{
					nId:			msg.nId,
					nick:			msg.nick,
					content:	content,
					rating:		rating,
					images:		images,
				});
			}
			const finalTurn=final.length-1;
			
			this.w(`We got ${finalTurn+1} chat log messages, now let's process additional parts`);
			
			if(h.replyWithRating) {
				if(ratingUsed) {
					this.w('rating is used');
					adds.wRating=1;
				} else {
					this.w("rating is enabled but not used, skipping");
				}
			} else { this.w(`Rating is disabled in config`) }
			
			this.rag[h.aId].last=[];
			this.rag['g'].last=[];
			if(h.rag) {
				this.w("rag is enabled");
				if(!this.settings.req.modelEmb.v.l.length) {
					alert("You have enabled memories (rag) feature but you've not downloaded any models for embeddings. Please pull at least one embedding model, like 'nomic-embed-text' or anything else with 'embed' in its name. Also, don't forget to run a second instance of Ollama on a different port and to configure 'Embeddings URL' in settings by pointing it to that URL. This way your prompts will not slow down when you use 'memories'. I will switch off your rag setting for now, to prevent showing you this message next time. Enjoy.");
					this.ragDisable(1);
				} else {
					this.w(`searching in rag`);
					let ragp=1;
					if(!/^(\d{1,14})$/.test(this.config.ragPast.v)) {
						this.config.ragPast.v=this.config.ragPast.def;
						alert(`You have a bad configured value for the ${this.config.ragPast.name} parameter, resetted it to: ${this.config.ragPast.v}`);
					}
					ragp=this.config.ragPast.v;
					this.w(`rag past messages to use: ${ragp}`);
					let rags=[];
					if(ragp>0) {
						for(let i=finalTurn;i>=0;i--) {
							rags.push(final[i].content);
							ragp--;
							if(ragp==0) break;
						}
					}
					this.w({'rag search content':rags});
					
					if((this.rag['g'].t.length+this.rag[h.aId].t.length)==0) {
						this.w('global and user rags are empty, skipping rag');
					} else if(rags.length==0) {
						this.w('rag prompt is empty, skipping rag');
					} else {
						this.msgStatusSetDo(h.msg,'embedding prompt');
						let e=await this.embed(`please find top related content to: """${rags.join("\n")}"""`); //
						this.msgStatusSetDo(h.msg,'embedding prompt');
						if(!e.length) {
							alert("You have enabled memories (rag) feature but the embedding url returns an error. Please fix the issue and re-enabled rag. For now the rag is going to be disabled.");
							this.ragDisable(0);
						} else {
							const memb=this.settings.req.modelEmb.v.l[this.settings.req.modelEmb.v.v].tag;
							let rv={g:[]}; rv[h.aId]=[];
							let ra	={};
							let min ='';
							if(/^\d{1,14}(:?\.\d{1,14})?$/.test(this.config.ragMinSmlr.v)) {
								min=this.config.ragMinSmlr.v;
							} else if(this.config.ragMinSmlr.v!==''&&this.config.ragMinSmlr.v!=null) {
								alert("You have a wrong value for 'Minimum required similarity value', ignoring it");
							}
							this.w(`lowest similarity configured is: ${min}`);
							
							ra[h.aId]	=/^\d{1,14}$/.test(this.config.ragUAmount.v)?this.config.ragUAmount.v:2;
							ra['g']	=/^\d{1,14}$/.test(this.config.ragGAmount.v)?this.config.ragGAmount.v:2;
							
							this.msgStatusSetDo(h.msg,'embedding search');

							for(const r of ['g',h.aId]) {
								if(memb!=this.rag[r].modelEmb) {
									this.w(`embedding model has changed from ${this.rag[r].modelEmb} -> ${memb}, let's re-evaluate rag`);
									this.rag[r].v=[];
									await this.ragU(r);
								}
								for(let i=0;i<this.rag[r].v.length;i++) { //>
									const R		=this.rag[r].v[i];
									const cos	=this.cosine(R[0],e[0]);
									this.w(`got cos=${cos} for ${e[1]}=${R[1]}`);
									if(min!==''&&cos<min) { //>
										this.w(`Similarity is lower than defined ${cos}<${this.config.ragMinSmlr.v}`); //>
										continue;
									}
									rv[r].push({i:i,cos:cos});
								}
								this.w({rv:rv});
								if(rv[r].length) {
									const upto=rv[r].length>ra[r]?ra[r]:rv[r].length;
									this.w(`rag amount: ${ra[r]}, rag upto: ${upto}`);
									rv[r]=rv[r].sort((a,b)=>(a.cos>b.cos?-1:1)).slice(0,upto);
									this.w({ragtouse:rv[r]});
									if(this.config.ragShuffle.v) {
										this.w('shuffling the rag results as requested in config');
										rv[r]=sh(rv[r],upto);
									} else {
										this.w('shuffling is disabled, using rag as is');
									}
									for(const R of rv[r]) {
										this.rag[r].last.push({
											t:this.rag[r].v[R.i][1],id:R.i,
											cos:R.cos
										});
										adds.rag.push(this.rag[r].v[R.i][1]);
									}
								}
								this.w({'rag last of user':r,is:this.rag[r].last});
							}
						}
					}
				}
				this.msgStatusSetDo(h.msg,'templating');
			} else { this.w(`memories are disabled in config`) }

			if(this.nicks[h.aId].instr.length) {
				this.w(`we have instr text, let's see if we should add it: sideReply=${h.sideReplyWRating}, allow instr with side-rating:${h.instrWithSideRating}`);
				if(
							(h.sideReplyWRating&&h.instrWithSideRating)
						||(!h.sideReplyWRating)
				) {
					this.w(`can use instr`);
					adds.instr=this.nicks[h.aId].instr;
				} else {
					this.w(`instr is not appliable`);
				}
			} else { this.w('instr is empty') }
			
			if(h.sideReplyWRating) {
				this.w("processing rated sideReply rating");
				let good=[],bad=[];

				for(const m of this.msgsa(h.turn+1)) {
					if(h.stories&&!this.storiesMsgVisible(m,h.aId)) continue;
					if(m.nId!=h.aId) continue;
					if			(m.rating==1) { good.push(this.msgContent(m,h.trinity,h.aId)) }
					else if	(m.rating==0) { bad.push(this.msgContent(m,h.trinity,h.aId))  }
				}
				
				let exQ=this.config.badExForSideReply.v
				if(bad.length&&exQ>0) {
					for(const i of sh(bad,exQ)) {
						adds.nredo.push(i);
					}
				}
				
				exQ=this.config.goodExForSideReply.v;
				if(good.length&&exQ>0) {
					for(const i of sh(good,exQ)) {
						adds.predo.push(i);
					}
				}
				this.w("finished taking sidereply examples");
			} else { this.w(`not a rated sideReply, skipping sideReply rating`) }
			
			this.w({adds:adds});
			this.w('starting templating the adds');
			
			ms.msg			=h.msg;
			ms.finalTurn=finalTurn;
			ms.extra		=[];
			ms.sys			=this.nicks[h.aId].system??'';
			ms.rooms		=h.rooms;
			ms.raw			=h.raw;
			ms.nicks		=this.chatMsNicks(h);
			ms.mods			={
				replyWithRating:h.replyWithRating,
				namesAdd:				h.namesAdd,
				aiIsYou:				h.aiIsYou,
				otherAiAsUser:	h.otherAiAsUser,
				imgsLastOnly:		h.imgsLastOnly,
				noReplyToSelf:	h.noReplyToSelf,
				emptyToSth:			h.emptyToSth,
				emptyToTxt:			h.emptyToTxt,
			};

			const logRaw=h.rawLog;
			if(ms.raw) {
				if(logRaw) this.wDo(`Raw mode is enabled`);
				let tmpl={start:'',user:'',assistant:'',end:'',img:'',singleMsgMode:''};
				for(const s in tmpl) {
					let rg	=new RegExp(`{{${s}}}(.*?){{/${s}}}`,'s');
					let tmp	=h.rawTmpl.match(rg);
					if(tmp!=null&&tmp.length>1) {
						tmpl[s]=tmp[1];
						if(logRaw) this.wDo(`Found template part ${s}: ${tmpl[s]}`);
					} else {
						alert(`Haven't found a part of raw template: {{${s}}} {{/${s}}}, turning off raw mode for this request.`);
						ms.raw=false;
						if(logRaw) this.wDo(`Have not found template part ${s}, stopping.`);
						break;
					}
				}
				ms.rawTmpl=tmpl;
				if(logRaw) this.wDo({rawModeTemplate:ms.rawTmpl});
			} else {
				if(logRaw) this.wDo(`Raw mode is disabled`);
			}
			
			let msgs={u:[],s:[],f:{}};
			if(adds.rag.length) {
				msgs.u.push(`(in my mind i search for something relevant: """${adds.rag.join('\n')}""")`);
			}
			if(adds.nredo.length) {
				msgs.u.push(
					`in my reply i shall avoid messages like these: ${
						adds.nredo.map(arr=>'"""'+arr+'"""').join(', ')
					}`
				);
				adds.wSideRating=1;
			}
			if(adds.predo.length) {
				msgs.u.push(`Here are ready reply ideas in my head, i'll improvise keeping their logic, style and mood: ${adds.predo.map(arr=>'"""'+arr+'"""').join(", ")}`);
				adds.wSideRating=1;
			}
			if(adds.instr.length) {
				msgs.u.push(`Main thing on my mind: """${adds.instr}"""`);
			}
			if(adds.wRating==1) {
				const posr=this.chatRatingMod(1,''),negr=this.chatRatingMod(0,'');
				msgs.s.push(`Task: Messages with ${negr} are bad, imitate ${posr} messages in style, size, manner. Do not use ${posr} and ${negr} in your own messages.`);
			}
			this.w({ulen:msgs.u});
			if(finalTurn>=0) {
				//as we inject last message in these, we need to process it according to the rules
				//we process other messages.
				// but we don't want any mods here apart from name, if it's enabled.
				//i need to move it to chattmpldo now
				let htmp={}; for(const k in ms) { this.copy(ms,htmp,k) };
				htmp.mods={namesAdd:h.namesAdd};
				const replyTo=this.chatTmplDo(finalTurn,htmp,final[finalTurn]);
				
				if(!h.trinity) {
					if(msgs.u.length||msgs.s.length) {
						msgs.s.push(`Now, with above in mind react to """{{replyToText}}""", 1 in-character reaction only`);
					}
				} else {
					let chance=h.trinityChancesTh+'';
					if(!chance.match(/^(?:[01]|0.\d{1,14})$/)) {
						chance=this.config.trinityChancesTh.def;
						alert(`Wrong trinity thoughts chance set: ${h.trinityChancesTh}, reverting to: ${this.config.trinityChancesTh.def}`);
						this.config.trinityChancesTh.v=this.config.trinityChancesTh.def;
					}
					if((chance*1)>Math.random()) {
						this.w(`Chances for thinking were high :)`);
						msgs.f.th	=h.trinityReqTh;
					} else {
						this.w(`Chances for thinking were low :)`);
					}
					msgs.f.a	=h.trinityReqA;
				}
			}
			for(const m of msgs.u) {
				this.chatFinalPush(final,{
					nId:			h.aId,
					nick:			this.nicks[h.aId].n,
					content:	m,
					rating:		'',
					images:		[],
				});
			}
			for(const m of msgs.s) {
				this.chatFinalPush(final,{
					nId:			this.nick['s'],
					nick:			this.nicks[this.nick['s']].n,
					content:	m,
					rating:		'',
					images:		[],
				});
			}
			//add.push(this.msgTmpl(this.nick['s'],msgs.s.join("\n"),null));

			this.w(`added adds, now ${final.length} messages`);
			this.w({final:final});
			
			if(Object.keys(msgs.f).length) {
				for(let i of ['th','a']) { //'e',
					if(!msgs.f.hasOwnProperty(i)) continue;
					this.w(`adding final: ${i} ${msgs.f[i]}`);

					this.chatFinalPush(ms.extra,{
						nId:			this.nick['s'],
						nick:			this.nicks[this.nick['s']].n,
						content:	msgs.f[i],
						rating:		'',
						images:		[],
					});
					ms.extra[ms.extra.length-1]=[i,ms.extra[ms.extra.length-1]];
				}
			} else {
				ms.extra.push(false);
				if(h.noAiReplyToSelf&&finalTurn>=0) {
					//i used to keep the u/ai turn based order, but not anymore
					//yes, it will confuse ai's at times, but this way there is more user control
					//with trinity it's not needed as it states who should reply
					//otherwise instruction says it
					//otherwise model will be confused most likely.
					//so ideally, if the last message with extras is ai's, we need to add this.
					let fl=final.length-1;
					if(final[fl].nId==h.aId) {
						this.w(`No ai reply to self is enabled, it's not trinity and last msg is the same ai that will reply, let's add last msg to prevent it to reply to self.`);
						this.chatFinalPush(final,{
							nId:			this.nick['s'],
							nick:			this.nicks[this.nick['s']].n,
							content:	'continue in accordance with your system prompt, do not mention this message.',
							rating:		'',
							images:		[],
						});
					}
				}
			}
			
			ms.final=final;

			this.w({ms:ms});
			return ms;
		},
		chatFinalPush(final,h) {
			let tmp={
				nId:			null,
				nick:			null,
				content:	null,
				rating:		null,
				images:		[],
			};
			for(let i in tmp) {
				if(!h.hasOwnProperty(i)) {
					throw new Error(`can't find property ${i} for final msgs array!`);
				}
				tmp[i]=h[i];
			}
			final.push(tmp);
		},
		ucFirst(str) {
			return str?str[0].toUpperCase()+str.substr(1):'';
		},
		rawTmplReplace(d,txt) {
			this.w({rawData:d,txt:txt});
			for(const r in d) {
				const rg=new RegExp('{{'+r+'}}','gs');
				txt=txt.replace(rg,d[r]);
			}
			return txt;
		},
		chatAiMs2Tmpl(ms) {
			let final=[],tmp,res=[],d={},imgs=[],logRaw=this.config.rawLog.v,fl,ftRaw,ft;
			
			for(const i in ms.final) {
				//this.copy(ms.final,final,i);
				final.push(this.chatTmplDo(i,ms,ms.final[i]));
			}
			
			fl=final.length-1;
			
			if(ms.hasOwnProperty('mods')&&ms.mods.noReplyToSelf&&ms.final[ms.finalTurn].nId==ms.nicks.ai) {
				this.w(`Final message belongs to replier and noReplyToSelf set, searching for another reply.`);
				if(logRaw) this.wDo(`Final message belongs to replier and noReplyToSelf set, searching for another reply.`);

				for(let i=ms.finalTurn;i>=0;i--) {
					if(ms.final[i].nId!=ms.nicks.ai) {
						ftRaw	=ms.final[i];
						ft		=final[i];
					}
				}
				if(ft==undefined) {
					this.w(`No message found to reply to, using empty data`);
					if(logRaw) this.wDo(`No message found to reply to, using empty data`);
					ft		=this.chatTmplRow('','','',[]);
					ftRaw	=this.chatTmplRow('','','',[]);
				}
			} else {
				this.w(`Taking final message from the last turn.`);
				ftRaw	=ms.final[ms.finalTurn];
				ft		=final[ms.finalTurn];
			}
			
			d={
				replierId:					ms.nicks.ai,
				replierName:				ms.nicks.l[ms.nicks.ai].n,
				replyToUserId:			ftRaw.nId,
				replyToName:				ft.nick,
				replyToText:				ft.content,
				replyToTextRaw:			ftRaw.content,
				sys:								ms.sys,
				charId:							'',
				charName:						'',
				msg:								'',
				msgRaw:							'',
				charIdPrev:					'',
				charNamePrev:				'',
				msgPrev:						'',
				msgRawPrev:					'',
				imgIndex:						'',
				img:								'',
			};
			
			//process extras like trinity.
			for(let i=ms.finalTurn+1;i<=fl;i++) { //>
				if(!final[i].content.length) continue;
				final[i].content=this.rawTmplReplace(d,final[i].content);
			}
			
			this.w({msgsFinal:final});
			
			if(ms.raw) {
				if(logRaw) this.wDo(`Raw mode enabled, processing data.`);
				this.w({nicks:ms.nicks})
				
				res.push(this.rawTmplReplace(d,ms.rawTmpl.start));
				if(logRaw) this.wDo({part:'start',data:d,template:res[res.length-1]});

				let msgs=[];
				for(const i in final) {
					const fRaw=ms.final[i];
					const f		=final[i];
					let txt='';
					if			(ms.rooms)							{	txt=ms.rawTmpl.singleMsgMode	}
					else if	(f.role==='user') 			{	txt=ms.rawTmpl[f.role]				}
					else if	(f.role==='assistant')	{	txt=ms.rawTmpl[f.role]				}
					else 		{
						this.w(`Unknown role: ${f.role}, ignoring line: ${f.content}`);
						if(logRaw) this.wDo(`Unknown role: ${f.role}, ignoring line: ${f.content}`);
						continue;
					}
					
					if(txt==null||!txt.length) {
						if(logRaw) this.wDo(`Empty template for msg ${i}, skipping.`);
						continue;
					}

					d.charId			=fRaw.nId;
					d.charName		=f.nick;
					d.msg					=f.content;
					d.msgRaw			=fRaw.content;
					d.img					='';
					d.imgIndex		='';

					if(i>0) {
						const fp				=final[i-1];
						const fpRaw			=ms.final[i-1];
						d.charIdPrev		=fpRaw.nId;
						d.charNamePrev	=fp.nick;
						d.msgPrev				=fp.content;
						d.msgRawPrev		=fpRaw.content;
					} else {
						d.charIdPrev		='';
						d.charNamePrev	='';
						d.msgPrev				='';
						d.msgRawPrev		='';
					}

					tmp='';
					if(f.images&&f.images.length) {
						let imgTmpl=ms.rawTmpl.img;
						tmp=[];
						for(const img of f.images) {
							imgs.push(img);
							tmp.push(this.rawTmplReplace({imgIndex:imgs.length-1},imgTmpl));
						}
						tmp=tmp.join(' ');
					}
					d.img=tmp;

					msgs.push(this.rawTmplReplace(d,txt));
					if(logRaw) this.wDo({turn:i,role:f.role,data:d,template:msgs[msgs.length-1]});
				}
				
				if(ms.rooms) {
					d.charId			=d.replyToUserId;
					d.charName		=d.replyToName;
					d.msg					=msgs.join('');
					d.msgRaw			=msgs.join('');
					d.img					='';
					d.imgIndex		='';
					d.charIdPrev	='';
					d.charNamePrev='';
					d.msgPrev			='';
					d.msgRawPrev	='';
					//everything is already replaced but we just put it this way into the single msg template
					res.push(this.rawTmplReplace(d,`${ms.rawTmpl.user}`));
					this.w({chat:res[res.length-1],singleMsg:ms.rooms});
					if(logRaw) {
						this.wDo('Single message mode is activated, chat log will be joined into a single message..');
						this.wDo({chatLog:res[res.length-1]});
					}
				} else {
					for(const m of msgs) {
						res.push(m);
					}
					this.w({chat:res,singleMsg:ms.rooms});
					if(logRaw) this.wDo('Single message mode is disabled, building role based template.');
				}
				
				d.charId		=d.replierId;
				d.charName	=d.replierName;
				d.msg				='';
				d.msgRaw		='';
				d.img				='';
				d.imgIndex	='';

				if(final.length) {
					const fp				=final[fl];
					const fpRaw			=ms.final[fl];
					d.charIdPrev		=fpRaw.nId;
					d.charNamePrev	=fp.nick;
					d.msgPrev				=fp.content;
					d.msgRawPrev		=fpRaw.content;
				}
				res.push(this.rawTmplReplace(d,ms.rawTmpl.end));
				if(logRaw) this.wDo({part:'end',data:d,template:res[res.length-1]});

				if(logRaw) this.wDo(`Resulting template: ${res.join('')}`);

				return { prompt:res.join(''),images:imgs };
			} else {
				if(logRaw) this.wDo(`Raw mode is disabled, using standard data processing.`);
			}
			
			if(ms.sys.length) {
				this.chatAiMsPush(res,ms.sys,'system');
			}
			
			if(ms.rooms) {
				this.w("room mode, let's concatenate everything");
				imgs=[];
				for(const i of final) {
					if(!i.images||!i.images.length) continue;
					imgs.push(...i.images);
				}
				this.w(`in rooms mode amount of images: ${imgs.length}`);
				this.chatAiMsPush(res,final.map(arr=>arr.content).join('\n\n'),'user',imgs);
			} else {
				this.w("chat mode, let's add everything as messages");
				for(const i of final) {
					this.chatAiMsPush(res,i.content,i.role,i.images);
				}
			}
			return { prompt:res,images:[] };
		},
		chatAiMsPush(ms,c,r,i) {
			ms.push({ content:c,role:r });
			if(i&&i.length) ms[ms.length-1].images=i;
		},
		chatTmplDo(turn,h,f) {
			this.w(h);
			let role	=h.nicks.l[f.nId].t==='a'?'assistant':'user';
			let nick	=f.nick;
			let ct		=f.content;
			let images=f.images;

			//this.w({role:role,mod:123,mods:h.mods,asd:`${role},${f.nId},${h.nicks.aid}`,f:f});
			if(h.hasOwnProperty('mods')) {
				if(h.mods.imgsLastOnly)			images=this.chatTmplImgsLastOnly(turn,h.finalTurn,images);
				if(h.mods.otherAiAsUser)		role	=this.chatTmplOtherAiAsUser(role,f.nId,h.nicks.ai);
				if(h.mods.aiIsYou)					nick	=this.chatTmplAiIsYou(nick,f.nId,h.aid);
				if(h.mods.namesAdd)					ct		=this.chatTmplNameAdd(ct,nick);
				if(h.mods.replyWithRating)	ct		=this.chatRatingMod(f.rating,ct);
			}
			return this.chatTmplRow(ct,role,images,nick);
		},
		chatTmplRow(ct,role,images,nick) {
			return {
				content:	ct,
				role:			role,
				images:		images,
				nick:			nick,
			};
		},
		chatTmplImgsLastOnly(turn,lastLogTurn,imgs) {
			if(!imgs.length) return imgs;
			this.w(`img filter: ${turn}!=${lastLogTurn}`);
			if(lastLogTurn!=turn) return [];
			return imgs;
		},
		chatTmplOtherAiAsUser(role,nId,aid) {
			if(role!=='assistant'||nId==aid) return role;
			this.w(`overriding role of ${nId}!=${aid} to make it user`);
			return 'user';
		},
		chatTmplAiIsYou(nick,nId,aid) {
			if(nId!=aid) return nick;
			return 'You';
		},
		chatTmplNameAdd(ct,n) {
			return `${n}: ${ct}`;
		},
		chatAiMsTmpl(c,r,nId,n,rt,i,cr,uRaw,uRating,uName) {
			let tmp={
				content:		c,
				contentRaw:	cr,
				role:				r,
				nick:				n,
				rating:			rt,
				nId:				nId,
				useRaw:			uRaw,
				useRating:	uRating,
				useName:		uName,
			};
			if(i!=null&&i.length) {
				tmp.images=[];
				for(const img of i) {
					tmp.images.push(img.c);
				}
			}
			return tmp;
		},
		chatRatingMod(rt,s) {
			if(!(rt!=null&&rt!==''&&(rt==1||rt==0))) return s;
			
			let tmp='';
			if(rt==1) {
				tmp='((+))';
			} else if(rt===0) {
				tmp='((-))'
			}
			//this.w(`ratingmod: ${rt} ${s} ${tmp}`);
			return `${tmp}${s}`;
		},
		chatUserSide(turn,c,u,u2) {
			let b=this.brancha(turn);
			this.msgNew(turn,u,u2,(c??''),this.group); //contents needs to be inited
			b.msgs[b.msg]['side']=1;
			this.msgaStatusSet(turn,'waiting');
			this.w(`a new side message at ${turn} for user ${u}, next turn is ${u2}`);
			turn=this.turn=turn-1;
			this.branchu(turn);
			this.w(`resetting turn to ${this.turn}`);
		},
		chatOptions() {
			const opt=this.chatOpt2hash(0);
			opt['options']=this.chatOpt2hash(1);
			return opt;
		},
		chatOpt2hash(m) {
			let opt={};
			const sets=m==1?this.settings.options:this.settings.req;
			for(const i in sets) {
				if(i=='modelEmb') continue; //dirty hack :)
				this.w(`processing settings param ${i}=${sets[i].v}`);
				if(!(sets[i].v+'').length) continue;
				this.w(`${i}=${sets[i].v}`)
				if(sets[i].t==='n') {
					opt[i]=sets[i].v*1;
				} else if(sets[i].t==='as') {
					opt[i]=[];
					for(const j of sets[i].v) {
						if(j==='') continue;
						opt[i].push(j+'');
					}
				} else if(sets[i].t==='sel') {
					opt[i]=sets[i].v.l[sets[i].v.v].tag;
				} else {
					opt[i]=sets[i].v+'';
				}
			}
			return opt;
		},
		rgEsc(string) {
			return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
		},

		//connection url stuff
		url() {
			return this.config.url.v;
		},
		async urlTest(url) {
			if(this.working) {
				this.w('working right now, leaving');
				return;
			}
			
			this.connectionErr='';
			this.connection		=0;
			this.working			=1;
			
			this.w(`taking url`);
			if(!url) url=this.url();
			if(!url) {
				this.w(`no good address`);
				this.connectionErr='No good url found';
				this.working=0;
				return;
			}
			this.connectionErr='';

			let res=await fetch(url+"/api/tags",{
				"method": "GET",
			}).then(r=>{
				if(!r.ok) throw new Error(r.statusText);
				return r;
			}).then(async (r)=>{
				this.working=0;
				this.connectionErr=''
				this.w(`connection established, running models listing`);
				await this.listDo();
				return 1;
			}).catch((error)=>{
				this.connectionErr=error.message;
				console.error(`network error ${error.message}`);
				this.working=0;
			});
		},
	}
})

app.component(
	'css',{
		template: '#tmplCss'
	}).component('nick',{
		template: '#tmplNick',
		props: ['id','name'],
	}).component('menun', {
		template: '#tmplMenuN',
		props: ['k','t'],
		inject: ['config']
	}).component('fields', {
		template: '#tmplField',
		props: ['i','n','nShow','id'],
		methods: {
			loadFile(n) {
				this.$root.loadFile(n);
			}
		},
	}).component('nickadd', {
		template: '#tmplNickAdd',
		props: ['t','group','nicks','groups','amountNicks'],
		computed: {
			ut() {
				return (this.t==="u"?"user":"ai");
			},
			uListAvail() {
				return this.msgUserListAvail({nicks:this.groups[this.group].u},this.t,0);
			},
		},
		data() {
			return {
				userGroupAddId:null,
				userNickA: '',
			}
		},
		watch: {
			'uListAvail'(v) {
				if(!this.uListAvail.length) return 0;
				this.userGroupAddId=this.uListAvail[0];
			}
		},
		methods: {
			sel(i) {
				this.userGroupAddId=i;
				return false;
			},
			async userAdd() {
				await this.$root.userAdd(this.t,this.userNickA,{});
				this.$root.userGroupAdd(this.group,this.amountNicks.idNext-1);
				this.userNickA='';
			},
			userGroupAdd() {
				this.$root.userGroupAdd(this.group,this.userGroupAddId)
				this.userGroupAddId=null;
			},
			msgUserListAvail(msg,t,g) {
				return this.$root.msgUserListAvail(msg,t,g);
			},
			pToggle(id) {
				this.$root.pToggle(id);
			},
		},
	}).component('heardBy', {
		template: '#tmplHeardBy',
		props: ['u','nicks','groups','group','config'],
		computed: {
			users() {
				//yes, i don't want to write that idiotic hash to array thing :).
				let arr=[[],[]];
				const g=this.groups[this.group].u[this.u];
				for(const i in g) { if(this.nicks[i].t==='u') arr[0].push(i) }
				for(const i in g) { if(this.nicks[i].t==='a') arr[1].push(i) }
				return [
					...arr[0].sort((a,b)=>(this.nicks[a].n.localeCompare(this.nicks[b].n))),
					...arr[1].sort((a,b)=>(this.nicks[a].n.localeCompare(this.nicks[b].n)))
				];
			}
		}
	}).component('talkers', {
		template: '#tmplTalkers',
		props: ['nicks','t','groups','group','config'],
		methods: {
			userS(t) {
				return this.$root.userS(t);
			},
			userVis(id) {
				return this.$root.userVis(this.t,id);
			},
			groupNext() {
				this.$root.groupNext();
			},
			groupPrev() {
				this.$root.groupPrev();
			},
			userCh() {
				this.$root.userCh(this.t);
			},
			send(e,m,aw,id) {
				if(this.t!='a') return;
				this.groups[this.group]["sel"][this.t]=id;
				this.$root.send(e,m,aw)
			}
		}
	}).component('userList', {
		template: '#tmplUserList',
		props: ['nicks','t','groups','group'],
		methods: {
			userVis(id) {
				return this.$root.userVis(this.t,id);
			},
			userGroupDel(id) {
				this.$root.userGroupDel(this.group,id);
			},
			userDel(id) {
				this.$root.userDel(id);
			},
			userTypeCh(id) {
				this.$root.userTypeCh(id);
			},
		}
	}).component('help', {
		template: '#tmplHelp',
	}).component('opt', {
		template: '#tmplOpt',
		props: ['config','settings','opt','pState','branch'],
		data() {
			return {
				
			}
		},
		methods: {
			optimizeRun() {
				this.$root.optimizeRun();
			},
			optimizeCancel() {
				this.$root.optimizeCancel();
			},
			optChUse(m,k) {
				this.$root.optChUse(m,k);
			},
			pToggle(id,v) {
				this.$root.pToggle(id,v);
			},
			optResSave() {
				this.$root.optResSave();
			}
		}
	}).component('optRes',{
		template: '#tmplOptRes',
		props: ['m','i']
	}).component('optResValsLine',{
		template: '#tmplOptResValsLine',
		props: ['m','mid','vals']
	}).component('optResValsHeader',{
		template: '#tmplOptResValsHeader',
		props: ['m']
	}).component('ragErr',{
		template: '#tmplRagErr',
		props: ['rag']
	}).component('ragStatus',{
		template: '#tmplRagStatus',
		props: ['rag','id'],
	}).component('charNewParsedParams',{
		template: '#tmplCharNewParsedParams',
		props: ['char-new'],
		computed: {
			disabled() {
				return (this.charNew.working||this.charNew.stepShow>=2)?true:false;
			}
		},
		methods: {
			charNewParamsDel(id) {
				this.$root.charNewParamsDel(id);
			},
			charNewCoreParamCh(r) {
				this.$root.charNewCoreParamCh(r);
			}
		}
	}).component('charNewMemSets',{
		template: '#tmplCharNewMemSets',
		props: ['charNew'],
		methods: {
			memSetsDel(o,id) {
				this.$root.memSetsDel(o,id);
			}
		}
	}).component('charNewMemParsed',{
		template: '#tmplCharNewMemParsed',
		props: ['char-new'],
		methods: {
			memParsedDel(o,id) {
				this.$root.memParsedDel(o,id);
			}
		}
	}).component('charNewSystemEdit',{
		template: '#tmplCharNewSystemEdit',
		props: ['char-new','pState','id'],
		methods: {
			charNewSystemReset(o,id) {
				this.$root.charNewSystemReset(o,id);
			},
			charNewReqReset(o,id,rid) {
				this.$root.charNewReqReset(o,id,rid);
			},
			pToggleDo(id) {
				this.$root.pToggleDo(id)
			},
			charNewCoreParamCh(r) {
				this.$root.charNewCoreParamCh(r);
			}
		}
	}).component('chatRow',{
		template: '#tmplChatRow',
		props: ['turn','branch','msg','fontSize','trinity','u','ai','stories','group','tokens','ctx','nicks','turnEnd','branchMoving'],
		data() {
			return {
			}
		},
		watch: {
		},
		computed: {
			t() {
				return this.$root.turns[this.turn];
			},
			b() {
				return this.t.branches[this.branch];
			},
			msgLast() {
				return this.turn===this.turnEnd;
			},
			msgEditable() {
				return this.$root.msgEditable(this.m);
			},
			m() {
				return this.$root.msga(this.turn);
			},
			msgIndex() {
				return this.$root.msgIndex(this.turn,this.branch);
			},
			divId() {
				return 'msgC'+this.turn;
			},
			uType() {
				const t=this.$root.msgRole(this.m);
				return t;
			},
			nickClass() {
				return this.uType==="u"?"nicku":"nickai";
			},
			tabIndex() {
				return 10000+this.turn*2;
			},
			waitingTxt() {
				return this.uType==='u'?'..input new variant into the prompt, please..':"..wait for it..";
			},
			msgEmpty() {
				return this.$root.msgEmptyDo(this.m);
			},
			statusClass() {
				if(this.m.error) return 'error';
				return '';
			},
			status() {
				if(this.m.waiting)			return 'waiting..';
				if(this.m.loading)			return 'generating..';
				if(this.m.error)				return 'error..';
				if(this.m.status>=5)		return this.$root.msgStatusId2W(this.m.status)+'..';
				if(this.msgEmpty)				return 'empty message';
			},
			msgUserListOn() {
				return this.$root.msgUserListOn[this.msgUserListId];
			},
			msgUserListId() {
				return this.turn+'_'+this.branch+'_'+this.msgIndex;
			},
			usersAvail() {
				return this.$root.msgUserListAllAvail(this.m,this.group)
			},
			tokensShow() {
				if(this.uType!=="a")	return false;
				if(!this.tokens)			return false;
				if(!this.tokensTotal)	return false;
				return true;
			},
			tokensTotal() {
				return this.$root.tokensTotal(this.m,null);
			},
			trinityFields() {
				if(this.trinity) {
					return this.uType=='a'?["th","a"]:['a']; //"e"
				}
				return [null];
			},
			msgMore() {
				return this.$root.msgTotal(this.turn,this.branch)-this.msgIndex-1;
			},
			msgRole() {
				return this.$root.msgRole(this.m);
			},
			branchRated() {
				return this.b.rated
			},
			msgContClass() {
				let tmp='msgTextCont';
				return tmp;
			},
			msgDelClass() {
				if			(this.m.delShow==1) { return 'msgDelShow'	}
				else if	(this.m.delShow==2) { return 'msgMvShow'	}
				return '';
			},
			branchDelClass() {
				if			(this.b.delShow==1) { return 'msgDelShow'		}
				else if	(this.b.delShow==2) { return 'msgMvShow'		}
				return '';
			},
			chatRowClass() {
				let tmp="chatRow ";
				tmp+=this.msgFilterRow();
				return tmp;
			},
		},
		methods: {
			msgClass(tr) {
				let tmp='msgText';
				tmp+=' '+this.msgFilterTrinity(tr);
				return tmp;
			},
			editNick(e) {
				this.m.nick=e.target.innerText.trim()??'';
			},
			edit(e,tr) {
				if(!this.msgEditable) return;
				this.m.edited=1;
				const txt=e.target.innerText.trim()??'';
				this.$root.msgContentSet(this.m,tr,txt,false);
				e.target.innerText=txt;
			},
			msgFilterTrinity(tr) {
				//user messages show only content, they do not show trinity even when it's turned.
				//that's why we filter by usertype
				if(this.uType==='a'&&this.trinity&&this.ai!=this.m.nId&&tr!=='a') return "filterGray";
				return "";
			},
			content(tr) {
				//user id there is needed only for getting content for building list to send to model,
				//so it could filter things, here we just show all content, 
				//so we just pass id of the owner of the message to bypass the check inside
				const content=this.$root.msgContent(this.m,tr,this.m.nId); 
				if(this.m.waiting&&content=='') return this.waitingTxt;
				return content;
			},
			usersAvailShow(v) {
				this.$root.msgUserListOn[this.msgUserListId]=v;
			},
			msgUserAdd(uid) {
				this.$root.msgUserAdd(this.m,uid,this.msgUserListId)
			},
			msgUserDel(u) {
				this.$root.msgUserDel(this.m,u);
			},
			tokens(t) {
				this.$root.tokens(this.m,null,t);
			},
			msgRating(v) {
				this.$root.msgRating(this.turn,this.m,v);
			},
			branchMerge() {
				if(!confirm(`Are you sure you wish to delete this message and merge the branch below into this branch? It will move everything below into the place of the deleted message, moving it all up one turn.`)) return;
				const t=this.turn;
				const r=this.$root;
				const bn=r.turns[t+1].branch;
				r.branchMerge(t+1,bn,r.msgIndex(t+1,bn),this.turn,this.branch,this.msgIndex);
			},
			branchDel() {
				if(!confirm(`Are you sure you wish to delete the whole branch? It will delete this message and everything below "growing" from it.`)) return;
				this.$root.branchDel(this.turn,this.branch,this.msgIndex);
			},
			delShow(m) {
				this.m.delShow=m>0?1:0;
				for(let i=this.turn+1;i<=this.turnEnd;i++) { //>
					this.$root.msga(i).delShow=m;
					this.$root.brancha(i).delShow=m;
				}
			},
			mvShow(m) {
				this.m.delShow=m>0?1:0;
				const v=m==0?0:2;
				for(let i=this.turn+1;i<=this.turnEnd;i++) { //>
					this.$root.msga(i).delShow=v;
					this.$root.brancha(i).delShow=v;
				}
			},
			msgSide() {
				return this.$root.msgSide(this.m);
			},
			msgFilterRow() {
				if(this.$root.msgFilterDo(this.m)) {
					return "filterGray"
				}
				return '';
			},
			branchMvStart() {
				this.$root.branchMoving={self:{},src:[this.turn,this.branch,this.msgIndex]};

				let turn=this.turn+1,br={[this.branch]:{[this.msgIndex]:true}};
				this.$root.branchMoving.self[this.$root.tbmId(this.turn,this.branch,this.msgIndex)]=true;
				while(this.$root.turns[turn]!=undefined) {
					const tr=this.$root.turns[turn];
					const tree=tr.tree;
					if(tree==undefined) break;
					
					let br2={};
					for(let bp in br) {
						if(!tree.hasOwnProperty(bp)) continue;
						for(let mp in br[bp]) {
							//this.$root.w({bp:bp,mp:mp,turn:turn,tree:tree,tr:tree.hasOwnProperty(bp+''),tr2:tree[bp]});
							if(!tree[bp].hasOwnProperty(mp)) continue;
							let b=tree[bp][mp];
							if(!tr.branches[b].msgs.length) continue;
							this.$root.w(`turn: bp/bm:${bp}/${mp} ${turn} branch: ${b}`);
							br2[b]={};
							for(let m=0;m<tr.branches[b].msgs.length;m++) { //>
								const id=this.$root.tbmId(turn,b,m);
								this.$root.branchMoving.self[id]=true;
								br2[b][m]=true;
							}
						}
					}
					br=br2;
					turn++;
				}
			},
			branchMvCancel() {
				this.$root.branchMoving=false;
			},
			branchMvEnd() {
				let d=this.$root.branchMoving.src;
				this.$root.branchMv(d[0],d[1],d[2],this.turn,this.branch);
				this.branchMvCancel();
			},
		}
	});

window.ap=app.mount('#app');

</script>
</body>
</html>
