<!-- This is a code that is a part of this project: https://github.com/drazdra/ollama-chats -->
<!-- It's totally free for personal non-commercial use. Please enjoy. -->
<!-- It's not allowed to use this commercially and/or by/for any business or corporation. -->
<!-- It's not allowed to use this in your product or project without my agreement. -->
<!-- Read more at github page mentioned above -->
<html id='html'>
<head>

<!--			"vue": 		"/vue.prod.js" -->
<script type="importmap">
	{
		"imports": {
			"vue": 		"https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js"
		}
	}
</script>
</head>
<body style="background: black" id='body'>
	<div id="app" ><chat /></div>

<div class='tmpl' style='display:none'>
	<div id='tmplChat'>
		<div id='chatC'><!--:style='{backgroundImage: `url(${this.config.bgImg.v})`}'-->
			<table id='chat' border=1 height='100%'>
				<tr>
					<td colspan='3' id='heading'><a href='https://www.github.com/drazdra/ollama-chats' target='new' class='nobg'>Ollama-chats (v{{config.version.v}})</a></td>
				</tr>
				<template v-if='this.connection==1'>
					<tr>
						<td colspan='3'  id='nicks'>
							<table width='100%' cellspacing=0 cellpadding=0>
								<tr v-if='config.storiesUI.v'>
									<td class='' colspan='2' title="These are presets of users. They are here simply to let you save and quickly access groups of users that talk together. For example, characters in 2 different rooms. Or character talking on a phone to somebody when others do not hear it, etc.">
										<span class='nobgt'>
											<template v-for='(g,gi) in groups'>
												<span @click='groupCh(gi)' :class='"groups "+(gi==group&&"groupSel")'>{{g.n}}</span> <template v-if='gi!=0'>(<span @click='groupDel(gi)' class='del'>x</span>)</template> :
											</template>
											<input placeholder='add new' v-model='groupAddN'/> <span class='lnk' @click='groupAdd(this.groupAddN,[]);groupAddN=""'>add</span>
										</span>
										<br><br>
									</td>
								</tr>
								<tr>
									<td class='nicksListTitle'>
										<div class='understroke nobgt right nobreak'>Users ({{groups[this.group].an['u']}}):</div>
									</td>
									<td width='100%'>
										<user-list :t='"u"' :group='group' :groups='groups' :nicks='nicks'></users-list>
									</td>
									<td><nickadd t='u' :group='group' :groups='groups' :nicks='nicks' :amount-nicks='amountNicks'/></td>
								</tr>
								<tr>
									<td class='right nicksListTitle'>
										<span class='understroke nobgt rightf nobreak'>AIs ({{groups[this.group].an['a']}}):</span>
									</td>
									<td>
										<user-list :t='"a"' :group='group' :groups='groups' :nicks='nicks'></users-list>
									</td>
									<td>
										<nickadd t='a' :group='group' :groups='groups' :nicks='nicks' :amount-nicks='amountNicks'/><br>
									</td>
								</tr>
							</table>
						</td>
					</tr>
					<tr id='chatLog'>
						<td colspan='3'>
							<table width='100%'>
								<tbody id='chatLogC' :style='{display:(this.config.chatHeight.v!=""?"block":"table"),maxHeight: this.config.chatHeight.v+"px"}'>
									<template v-for="(i,index) in turns">
										<tr class='chatRow' v-if='index<=turn&&i.branch>=0&&!hideMsg(...tbma(index))' :class='msgFilterRow(index)'>
											<template v-if='index>0&&index<=turn'>
												<template v-for='(m) in [msga(index)]'>
													<td class='prev'>
														<div class='prevC'>
															<div class='nobg' @click='listmsgs(0,index)'>
																<template v-if='msgIndex(index,i.branch)!=0'>
																	&lt;<br>
																	{{msgIndex(index,i.branch)}}
																</template>
															</div>
														</div>
													</td>
													<td 
														:id		='"msg"+index'
														:class='"nobg "+(index===turn?"lastmsg":"msg")' 
														width	='100%' 
													>
														<transition name="slide-fade" mode="out-in">
															<div :key='msgIndex(index,i.branch)' class='msgTextCont' :id='"msgC"+index'>
																<div :class='i.role==="user"?"nicku":"nickai"'>
																	<span contenteditable='true' @blur='edit($event,"n",index)'>{{msga(index).nick}}</span> #{{msgIndex(index,i.branch)+1}}:
																</div>
																<div 
																	class						='msgText' 
																	:style					='"font-size:"+this.config.msgFontSize.v' 
																	:tabindex				='10000+index*1'
																	contenteditable	='true' 
																	@blur						="edit($event,'c',index)"
																>
																	<template v-if="i.role==='user'">
																		<template v-if='m.waiting'>
																			..input new variant into the prompt, please..
																		</template>
																		<template v-else>
																			{{m.content}}
																		</template>
																	</template>
																	<template v-else-if='m.waiting'>
																		..wait for it..
																	</template>
																	<template v-else>
																		{{m.content}}
																	</template>
																</div>
																<template v-if='m.images&&m.images.length'>
																	<br><br>
																	<div>
																		<template v-for='(img,ind) in m.images'>
																			<span class='chatLogImg'>
																				<img @click='img.s=img.s==0?1:0' :class='img.s==0?"imgEmbed":"imgBig"' :src='`data:image/gif;base64,${img.c}`'>
																			</span>
																		</template>
																	</div><br>
																</template>
																<div class='msgFooter'>
																	<span class='msgNicks' v-if='config.storiesUI.v'>
																		<template v-if='msgUserListAllAvail(m,this.group).length'>
																			<template v-if='!msgUserListOn[index+""+msgIndex(index,i.branch)]'>
																				<span class='lnk' @click='msgUserListOn[index+""+msgIndex(index,i.branch)]=true'>add</add></span>
																			</template>
																			<template v-else>
																				<span class='msgUserList'>
																					<template v-for='uid in msgUserListAllAvail(m,this.group)'>
																						<span class='lnk' @click='msgUserAdd(m,uid,index+""+i.branch)'><nick :id='uid' :name='nicks[uid].n'></nick></span>
																						&nbsp;
																					</template>
																				</span>
																			</template>
																		</template>
																		&nbsp;
																		<template v-for='(u) in m.nicksArr'>
																			<span @click='msgUserDel(m,u)' class='lnk'><nick :id='u' :name='nicks[u].n'></nick></span> 
																			&nbsp;
																		</template>
																	</span>
																	<template v-if='!msgWaiting(m)'>
																		<template v-if='msgEmpty(...tbma(index))'><span class='empty'>empty message</span></template>
																		<template v-if='m.status==msgStatusId("error")'><span class='error'>error</span></template>
																	</template>
																	<span 
																		class='tokens' 
																		v-show='i.role==="assistant"&&tokensTotal(index,null)'
																	>
																		Tokens: 
																		<template v-if='tokensTotal(index,null)'>
																			<!--span title='History token'>{{tokens(index,null,'tp')}}</span>
																				+
																			<span title='Response tokens'>{{tokens(index,null,'tr')}}</span>
																			= -->
																			<span title='Whole history tokens'>
																				{{tokensTotal(index,null)}}
																			</span>
																			<template v-if='this.settings.options["num_ctx"].v.length'>
																				of 
																				<span title='Configured context window'>
																					{{this.settings.options.num_ctx.v}}
																				</span>
																			</template>
																		</template>
																	</span>
																	&nbsp;&nbsp;
																	<span class='rating'>
																		<span :class='m.rating===0&&"litn"' @click='msgRating(index,0)'>--</span>
																		 / 
																		<span :class='m.rating===1&&"litp"' @click='msgRating(index,1)'>++</span>
																	</span>
																</div>
															</div>
														</transition>
													</td>
													<td 
														class='next' 
														@click='listmsgs(1,index)' 
													>
														<div class='nextC'>
															<div
																v-if="m.side!=1"
																class='nobg'
																title="This will generate an alternative message."
															>
																><br>
																{{msgMore(index,i.branch)||">"}}<br>
															</div>
															<div 
																@click.prevent='listmsgs(2,index)' v-if='m.side!=1&&i.role==="assistant"&&i.branches[i.branch].rated' 
																class='nobg'
																title="This (ctrl+right on keyboard) will generate a new message trying to use the messages you've rated in this turn as good/bad examples for AI"
															>
																+-<br>
																><br>
															</div>
														</div>
													</td>
												</template>
											</template>
										</tr>
									</template>
									<tr><td id='chatLogEnd'></td></tr>
								</tbody>
							</table>
						</td>
					</tr>
					<tr v-if='this.turnNotLast(turn)'>
						<td class='nobg'></td>
						<td class='lnk nobg'>
							<div class='center' @click='this.turnDown(0)'>
								There is more in the chat below, totally: {{turnLast(turn)-turn}} message(s), press down or click here to see.
							</div>
							<div class='center' @click='this.turnDown(1)'>
								Press shift+down or click here to show all the messages below
							</div>
						</td>
						<td class='nobg'></td>
					</tr>
					<tr v-if='config.storiesUI.v&&turns.length>1' id='contextFilterRow'>
						<td></td>
						<td id='contextFilter' colspan='2' title='Filters the messages of context history by who was meant to read them. You can do it to see either what Ai will see or just the history. "Every1" shows all the messages ever sent to chat. If you have both characters selected, you get one more checkbox that can be "AND" / "OR". "And" means you see only messages visible for BOTH selected characters - that is you see everything they BOTH meant to see. If one of them did not see something, you do not see it in this mode. "OR", on other hand, means you see ALL of the messages visible by any of these characters (in that some message of yours you see might not not be visible Ai, and some of the messages sent by Ai might not be meant for you to see)'>
							<span class='nobg'>
								<template v-if='!context[0]'>
									<span v-if="userS('u')!=null"><input type='checkbox' v-model='context[2]'><nick :id='userS("u")' :name='nicks[userS("u")].n'></nick></span>
									<template v-if='context[2]&&context[1]'>
										<span><input type='checkbox' v-model='context[3]'>{{context[3]?"and":"or"}}</span>
									</template>
									<span v-if="userS('a')!=null"><input type='checkbox' v-model='context[1]'><nick :id='userS("a")' :name='nicks[userS("a")].n'></nick></span>
								</template>
								<span><input type='checkbox' v-model='context[0]'>Every1</span>
							</span>
						</td>
						<td></td>
					</tr>
					<tr v-show='pState["control"]'>
						<td colspan=3 class='center'>
							<br>
							<talkers t='u' :config='config' :group='group' :groups='groups' :nicks='nicks'></talkers>
							<textarea rows='5' tabindex='5300' id='prompt' placeholder='Prompt'
								:disabled='userS("u")==null||userS("a")==null'
								v-model="prompt" 
									@keydown.enter='send($event,1,null)'
								:style='"font-size:"+config.taFontSize.v'
							></textarea>
							<table id='talkersB'>
								<tr>
									<td class='nobgb' width='50'>
										<div class='left leftf' id='imgAdd'>
											<fields n='+Image' id='img' :i='{name:"+Image",f:"file",d:"Upload an image to the prompt"}' :n-show='false'></fields>
										</div>
									</td>
									<td>
										<talkers t='a' :config='config' :group='group' :groups='groups' :nicks='nicks'></talkers>
									</td>
								</tr>
							</table>
							<div class='left' id='imgAddList'>
								<template v-for='(img,ind) in this.imgs'>
									<span class='chatLogImg nobg'>
										<img title='An image to attach to the prompt, click to remove.' @click='this.imgs.splice(ind,1)' class='imgPrompt nobg' :src='`data:image/gif;base64,${img}`'>
									</span>
								</template>
							</div>
							<br>
							<br><br>
							<table id='sysinstr'>
								<tbody>
								<tr>
									<td :width='(pState["sys"]?(pState["instr"]?"50%":"100%"):"0%")'>
										<transition name="ta" mode="out-in">
											<div :key='pState["sys"]' v-if='userS("a")!=null'>
												<div v-show='pState["sys"]' id='sysTitle'>
													<span class='nobgt'>System Prompt of <nick :id='userS("a")' :name='nicks[userS("a")].n'/></span>
												</div>
												<textarea 
													v-show='pState["sys"]'
													id='sys' 
													rows=10 
													v-model='this.nicks[userS("a")].system'
													:placeholder='`Edit this to override the system prompt of (${userS("a")}) ${nicks[userS("a")].n} with this text. Empty means the system uses default system prompt (from modelfile)`'
													:style='"font-size:"+config.taFontSize.v'
												></textarea>
											</div>
										</transition>
									</td>
									<td :width='(pState["instr"]?(pState["sys"]?"50%":"100%"):"0%")'>
										<transition name="ta" mode="out-in">
											<div :key='pState["instr"]' v-if='userS("a")!=null'>
												<div v-show='pState["instr"]' id='instTitle'>
													<span class='nobgt'>Instruction of <nick :id='userS("a")' :name='nicks[userS("a")].n'/></span>
												</div><br>
												<textarea 
													v-show='pState["instr"]'
													id='instr'
													rows=10 
													v-model='this.nicks[userS("a")].instr'
													:placeholder='`You can specify special reminder here for (${userS("a")}) ${nicks[userS("a")].n} on the situation. It will be injected as a last message belonging to the AI, but will not stay in the chat log. I use things like: "I am thinking about doing .., as i am .., i see that.. i feel that.. etc`'
													:style='"font-size:"+config.taFontSize.v'
												></textarea>
											</div>
										</transition>
									</td>
								</tr>
								</tbody>
							</table>

							<div id='ragC' v-show='pState["ragG"]||pState["ragU"]'>
								<br><br>
								<template v-if='this.config.rag.v'>
									<template v-if='rag.err!=null'>
										<div class='center red'><span class='nobg'><rag-err :rag='rag'></rag-err></span></div><br>
									</template>
									<table v-if='userS("a")!=null'>
										<tr>
											<td>
												<div class='nobg' id='remembered'>
													<template v-if='rag[userS("a")].last.length||rag["g"].last.length'>
														<p class='green understroke'>Things {{nicks[userS("a")].n}} remembers at last reply:</p>
														<template v-for='(r,id) in rag["g"].last'>
															<p class='justify'>Knowledge {{id+1}}: {{r.t}} (<span :title='r.cos'>Similarity: {{this.rnd(r.cos,3)}}</span>)</p>
														</template>
														<template v-for='(r,id) in rag[userS("a")].last'>
															<p class='justify'>Memories {{id+1}}: {{r.t}} (<span :title='r.cos'>Similarity: {{this.rnd(r.cos,3)}}</span>)</p>
														</template>
													</template>
													<template v-else>
														<span class='small'>Nothing was remembered last time</span>
													</template>
												</div>
											</td>
										</tr>
									</table>
									<br>
									<transition name="ta" mode="out-in">
										<table id='ragU' v-show='pState["ragU"]' v-if='userS("a")!=null'>
											<tr>
												<td>
													<div id='ragTitle'>
														<span class='nobgt'>Memories (rag) of <nick :id='userS("a")' :name='nicks[userS("a")].n'/>:</span>
													</div>
													<textarea
														id='rag'
														rows=7
														:disabled='this.workingRag||this.working'
														v-model='this.rag[userS("a")].t'
														@blur='ragU(userS("a"))'
														:placeholder='"Edit this to store ("+userS("a")+") "+nicks[userS("a")].n+" memories (rag). Only "+nicks[userS("a")].n+" can access these. You can use any format but i recommend to split it into small paragraphs, every separate paragraph should explicitly mention all the relevant subjects it speaks of, because every paragraph is searched separately. For example:\nMari has the following preferences in reading: Mari reads only sci-fi and hates manga. Favorite authors of Mari are Bubu Dada nad Dudu Baba.\nWhen Mari sees a mouse Mari screams and jumps on any man next her.\nSame about the world, environment, anything. Data in this field is searched by semantic similarity to the prompt."'
														:style='"font-size:"+config.taFontSize.v'
													></textarea><br>
													<div @click='pToggle("ragMemGen")' class='nobgb lnk rightf'>Memories generator</div>
													<div class='left small'>
														&nbsp;
														<rag-status :rag='rag' :id='userS("a")'></rag-status>
													</div>
													<div id='memGen'>
													<br>
													<transition name="ta" mode="out-in" >
														<div class='nobg' v-if='pState["ragMemGen"]' :key='pState["ragMemGen"]'>
															<char-new-mem-sets :char-new='memNew'></char-new-mem-sets>
															<template v-if='memNew.parts.m.length==0'>
																<span class='lnk' @click='memGen4rag(userS("a"))'>Generate</span>
															</template>
															<template v-else>
																<span class='lnk' @click='memGen4rag(userS("a"))'>Re-generate</span>
																: 
																<span class='lnk' @click='memGen2rag(memNew,userS("a"))'>Move to memories</span>
																: <span class='lnk' @click='memGenParsedReset(memNew,0)'>Clear</span>
															</template>
															<div class='rightf' title="When this marked, model will get not just system prompt of the character but also all of the character's 'memories' in its context for new memories generation. This may give a hope to have new memories more consistent with the existing ones.">w. ex. memories: <input type='checkbox' v-model='memNew.parts.wMemories'></div>
															<char-new-mem-parsed :char-new='memNew'></char-new-mem-parsed>
															<template v-if='memNew.working'>
																<template v-if='memNew.parts.tmp.waiting'>..loading..</template>
																<template v-else-if='memNew.working'>..working..</template>
																<textarea disabled=1 v-model='memNew.parts.tmp.content' rows='7'></textarea>
															</template>
															<table class='memparsed'>
																<tr>
																	<td>
																		<char-new-system-edit :char-new='memNew' :p-state='pState' id='0'></char-new-system-edit>
																	</td>
																</tr>
															</table>
														</div>
													</transition>
													</div>
												</td>
											</tr>
										</table>
									</transition>
									<br>
									<transition name="ta" mode="out-in">
										<table id='ragG' v-show='pState["ragG"]'>
											<tr>
												<td>
													<div class='rightf' id='ragTitle'>
														<span class='nobgt'>Public knowledge (rag) of all characters</span>
													</div>
													<textarea
														id='rag'
														rows=7
														:disabled='this.workingRag||this.working'
														v-model='this.rag["g"].t'
														@blur='ragU("g")'
														:placeholder='"Edit this to store global knowledge (rag) of all characters. You can use any format but i recommend to split it into small paragraphs, every separate paragraph should have explicitly mention all the relevant subjects it speaks of, because every paragraph is searched separately. For example:\nCafe where they meet first time for in the city of Kikuku, it was evening and the dragons were dancing in the air.\nTransportation, moving, driving is possible only on donkeys as cars do not exist, cars are just faity tales. If you need to get somewhere, get a donkey.\nSame about the world, environment, anything. Data in this field is searched by semantic similarity to the prompt."'
														:style='"font-size:"+config.taFontSize.v'
													></textarea><br>
													<div class='left small'>
														&nbsp;<span class='nobgb'>
															<rag-status :rag='rag' id='g'></rag-status>
														</span>
													</div>
													<br>
												</td>
											</tr>
										</table>
									</transition>
								</template>
								<template v-else>
									<p class='small nobg center'>Memories (rag) are disabled, please enable in settings if you wish to use it.</p>
								</template>
								<br>
							</div>
							<div id='setsQ' v-if='config.setsQ.v'>
								<br>
								<template v-for='(g,gind) in configGroups'>
									<template v-for='j of [config,settings.options,settings.req]'>
										<template v-for='(i,ind) of j'>
											<template v-if='i!=null&&i.q===true&&i.g==gind'>
												<fields :n='ind' :id='ind' :i='i' n-show='1'/>
											</template>
										</template>
									</template>
								</template>
							</div>
							<div v-show='pState["sets"]' align='center'>
								<br>
								<table id='sets' class='nobg'>
									<tr>
										<td colspan='3' class='green heading understroke center'>
											Settings
										</td>
									</tr>
									<tr>
										<td class='header center'>
											<p class='green right'>Name</p>
										</td>
										<td class='header center'>
											<p class='green'>Value</p>
										</td>
										<td class='header center'><p title='Quick access' class='green'>Quick</p></td>
									</tr>
									<!-- hardcoded settings that are personalized/outside of main ones, too lazy to write templating that would support everything needed. i suppose if needed i can make this "nicks" settings and then it's easy enough.-->
									<tr v-if='userS("a")!=null' class='setsRow'>
										<td class='title' title="Enable this to make the currently active AI to have personal set of settings and configuration. It makes it possible to assign different models per characters, to have different settings like temperature, etc and even different interface style (the latter is totaly useless).">
											<div :class='config.setsDescrShow.v&&"understroke green"'>
												Personal settings for <nick :id='userS("a")' :name='nicks[userS("a")].n'></nick>
											</div>
											<div v-if='config.setsDescrShow.v' class='justify txt'>
												Enable this to make <nick :id='userS("a")' :name='nicks[userS("a")].n'></nick> have personal set of settings and configuration. It makes it possible to assign different models per characters, to have different settings like temperature, etc and even different interface style (the latter is totaly useless).
												Default: false
											</div>
										</td>
										<td class='val'><input type='checkbox' @change='userSetsPerAi(userS("a"))' v-model='nicks[userS("a")].setsDo'></td>
										<td class='setsQ'></td>
										<td v-if='!config.setsDescrShow.v' class='def left'>def: false</td>
									</tr>
									
									<template v-for='(g,gind) in configGroups'>
										<tr>
											<td class='left headerC' colspan='3'>
												<p class='lnk green header' @click='pToggleDo("sets_"+gind)'>{{g.name}}</p>
											</td>
										</tr>
										<template v-for='j in [config,settings["req"],settings["options"]]'>
											<template v-for='(i,ind) in j'>
												<template v-if='i!=null&&i.g==gind'>
													<transition name='ta'>
														<template v-if='pState["sets_"+gind]'>
															<tr :id='"sets_"+gind' class='setsRow'>
																<td class='title' :title='i.d'>
																	<div :class='config.setsDescrShow.v&&"green"'>
																	{{i.name?i.name:ind}}
																	</div>
																	<div v-if='config.setsDescrShow.v' class='justify txt'>
																		{{i.d}}<br>
																		Default: <span>{{i.def===''?"empty":i.def}}</span>
																	</div>
																</td>
																<td class='val'><fields :n='i.name?i.name:ind' :id='ind' :i='i'/></td>
																<td class='setsQ'><input v-if='i.q!==null' type='checkbox' v-model='i.q'/></td>
																<td v-if='!config.setsDescrShow.v' class='def left'><span v-show='(i.def+"")!=""'>def: {{i.def}}</span></td>
															</tr>
														</template>
													</transition>
												</template>
											</template>
										</template>
									</template>
								</table>
							</div>
							<div id='howto' class='nobg' v-if='pState["howto"]'><help></help></div>
							<div v-if='pState["pull"]' id='pull'>
								<br>
								<div class='nobg'>
									<p class='heading understroke green center'>Pull a model</p>
									<br>
									<template v-if='!this.working'>
										<div v-if='!this.models.length'>
											There are no models installed, please install the models in the console
											or install it through this interface. 
										</div>
										To install a model enter your preferred model's name, as it is at 
										<a href='https://ollama.com/library' target='new'>https://ollama.com/library</a>
										and click "pull".<br><br>
										<input @keydown.enter.prevent='this.pull()' v-model='modelPull'/> <span class='lnk' @click='this.pull()'>pull</span>
										<br><br>
										<div v-if='this.connectionErr.length'>
											Error: {{this.connectionErr}}
										</div>
									</template>
									<template v-else>
										Pulling model: {{this.modelPull}}<br><br>
										<template v-for='i in this.mpull'>
											<div>
												{{i.status}} 
												<span v-if='i.total'>
													{{i.done}} / {{i.total}} = {{i.prcnt}}%
												</span>
											</div><br>
										</template>
									</template>
								</div>
							</div>
						</td>
					</tr>
					<tr v-if='pState["charNew"]' id='charNew'>
						<td colspan='3' class='center nobg'>
							<transition name="ta" mode="out-in" :key='pState["charNew"]'>
								<div>
									<div>
										<div class='header understroke green center'>
											Generation of a new character 
												<template v-if='charNew.parts.auto.working'>
													{{charNew.parts.auto.at}} of {{charNew.parts.auto.amount}}
													(<span class='del' @click='this.charNew.cancel=this.cancel=0'>cancel</span>)
												</template>
										</div>
									</div>
									
									<transition name="ta" mode="out-in" :key='charNew.stepShow'>
										<table width='100%'>
											<tr>
												<td colspan='2'>
													<template v-if='charNew.step>0'>
														<table id='charNewStep'>
															<tr>
																<td>
																	<div class='lnk header' v-if='charNew.stepShow>0' @click='charNew.stepShow--'>Back to step {{charNew.stepShow}}</div>
																</td>
																<td>
																	<div v-if='charNew.stepShow>0' class='header understroke green center'>Step {{charNew.stepShow+1}}</div>
																</td>
																<td>
																	<div class='lnk header rightf' v-if='charNew.step>charNew.stepShow' @click='charNew.stepShow++'>Back to step {{charNew.stepShow+2}}</div>
																</td>
															</tr>
														</table>
													</template>
												</td>
											</tr>
											<tr>
												<td colspan='2'>
													
												</td>
											</tr>
											<template v-if='charNew.stepShow==0'>
												<tr>
													<td colspan='2' style='width:100%' class='center'>
														<div>
															<span class='lnk' @click='charCreate(0)'>Click to create step by step</span> or 
															<span class='lnk' @click='charCreateAuto()'>Click to create in 1 click</span> <input class='understroke' characters style='width: 21px' v-model='charNew.parts.auto.amount'> characters
															<div class='del rightf' @click='charCreateReset(charNew,1)'>Click to reset</div>
															</div>
														<p>
															Here you can generate a new character. Refer to help section at the bottom for instruction.
															To start you can predefine any of the parameters below or leave all empty and just start.
															The input to the right from parameters is the amount of character memories to generate about
															that "topic". You can leave it empty.<br>
															Btw, you can even remove any of these parameters if they don't fit your idea and 
															add any custom parameters.
														</p>
													</td>
												</tr>
												<tr>
													<td colspan='2' class='center'>
														<div style='max-width:90%;' class='center'>
															<char-new-parsed-params :char-new='charNew'></char-new-parsed-params>
															<br>
															<char-new-mem-sets :char-new='charNew'></char-new-mem-sets>
															<br><br>
															<char-new-system-edit :char-new='charNew' :p-state='pState' id='0'></char-new-system-edit>
														</div>
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==1'>
												<tr>
													<td class='center'>
														Below are values recognized in the content generated by the model.
														You can edit it before doing next step or just re-create these. 
													</td>
													<td class='center'>
														<template v-if='charNew.step==1'>
															<div class='center green'>
																<template v-if='charNew.parts.tmp.waiting'>..loading..</template>
																<template v-else-if='this.charNew.working'>..working..</template>
															</div>
														</template>
														<template v-if='!charNew.working'>
															<template v-if='charNew.step>charNew.stepShow'>
																<div class='center lnk bold' @click='charNew.stepShow++'>Move to next step</div>
																<br>
															</template>
															<div class='center lnk' @click='charCreate(0)'>Click here to re-create</div>
														</template>
													</td>
												</tr>
												<tr>
													<td>
														<char-new-parsed-params :char-new='charNew'></char-new-parsed-params>
														<br><br>
														<char-new-system-edit :char-new='charNew' :p-state='pState' id='0'></char-new-system-edit>
													</td>
													<td>
														<textarea v-show='charNew.working&&charNew.step==1' :disabled="1" style='width: 100%;height:100%;' v-model='charNew.parts.tmp.content'></textarea>
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==2'>
												<tr>
													<td class='center green'>
														Below are values recognized in the content generated by the model. To edit these move to the previous step.
													</td>
													<td class='center'>
														<template v-if='charNew.step==2'>
															<div class='center green'>
																<template v-if='charNew.parts.tmp.waiting'>..loading..</template>
																<template v-else-if='this.charNew.working'>..working..</template>
															</div>
														</template>
														<template v-if='!charNew.working'>
															<template v-if='charNew.parts.sys.length'>
																<div class='lnk center middle bold' @click='charNew.stepShow++'>Move to next step</div>
																<br>
															</template>
															<div class='lnk center middle' @click='charCreate(1)'>Click here to do rephrasing of generating content.</div>
															<br>
															You can edit it manually too, of course.
														</template>
													</td>
												</tr>
												<tr>
													<td>
														<char-new-parsed-params :char-new='charNew'></char-new-parsed-params>
														<br><br>
														<char-new-system-edit :char-new='charNew' :p-state='pState' id='1'></char-new-system-edit>
													</td>
													<td>
														<template v-if='charNew.working==1'>
															<textarea :disabled='charNew.working' style='width:100%;height:100%' v-model='charNew.parts.tmp.content'></textarea>
														</template>
														<template v-else>
															<textarea style='width:100%;height:100%' v-model='charNew.parts.sys'></textarea>
														</template
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==3'>
												<tr>
													<td class='center green'>
														You can edit the memories below after the generation.
													</td>
													<td>
														<template v-if='charNew.step==3'>
															<div class='center green'>
																<template v-if='charNew.parts.tmp.waiting'>..loading..</template>
																<template v-else-if='charNew.working'>..working..</template>
															</div>
														</template>
														<template v-if='!charNew.working'>
															<template v-if='charNew.parts.m.length'>
																<div class='lnk center middle bold' @click='charNew.stepShow++'>Move to next step</div>
																<br>
															</template>
															<div class='center middle'>
																<span class='lnk' @click='charCreate(2)'>Click here to start (re)generating memories</span>
																or
																<span class='lnk' @click='charNew.stepShow=4'>Skip this step</span>
															</div>
														</template>
													</td>
												</tr>
												<tr>
													<td class='center'>
														<div><char-new-mem-sets :char-new='charNew'></char-new-mem-sets></div>
														<char-new-mem-parsed :char-new='charNew'></char-new-mem-parsed>
														<br><br>
														<char-new-system-edit :char-new='charNew' :p-state='pState' id='2'></char-new-system-edit>
													</td>
													<td>
														<textarea v-show='charNew.working&&charNew.step==3' :disabled='charNew.working==1' style='width:100%; height:100%' v-model='charNew.parts.tmp.content'></textarea>
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==4'>
												<tr>
													<td class='center green'>
														Remaining steps to complete:
													</td>
													<td>
														<div class='center'><span class='lnk bold' @click='charCreate(3)'>Click here</span> to make new character with the generated data</div>
													</td>
												</tr>
												<tr>
													<td>
														<table width='100%'>
															<tr>
																<td class='green'>Name <span class='small'>(if you change this, update the system prompt manually)</span>:<br>
																	<textarea rows=1 v-model='charNew.parts.name.c'></textarea>
																</td>
															</tr>
															<tr>
																<td class='green center'>System prompt, these 2 parts will be united:<br>
																	<textarea v-model='charNew.parts.sysKq' rows='4'></textarea>
																	+
																	<textarea v-model='charNew.parts.sys' rows='7'></textarea>
																</td>
															</tr>
															<tr>
																<td>
																	<char-new-mem-parsed :char-new='charNew'></char-new-mem-parsed>
																</td>
															</tr>
														</table>
													</td>
													<td>
														<br>
														<table width='100%'>
															<tr>
																<td style='width:90%'>Creating new character:</td>
																<td style='width:10%'>{{charNew.parts.copy.userAdd?("done, user: "+charNew.parts.copy.userAdd):".."}}</td>
															</tr>
															<tr>
																<td>Adding system prompt:</td>
																<td>{{charNew.parts.copy.sysPrompt?"done":".."}}</td>
															</tr>
															<tr>
																<td>Adding character to the group:</td>
																<td>{{charNew.parts.copy.add2group?"done":".."}}</td>
															</tr>
															<tr>
																<td>Selecting character as active:</td>
																<td>{{charNew.parts.copy.select?"done":".."}}</td>
															</tr>
															<tr>
																<td>Adding memories and converting these to embeddings:</td>
																<td>
																	<template v-if='!charNew.parts.copy.embedding'>
																		..
																	</template>
																	<template v-else>
																		<rag-status :rag='rag' :id='charNew.parts.u'></rag-status>
																	</template>
																</td>
															</tr>
														</table>
													
													</td>
												</tr>
											</template>
											<template v-if='charNew.stepShow==5'>
												<tr>
													<td colspan='2'>
														<div class='center green'>
															You have finished creating a new character.
														</div>
														<br><br>
														<div class='center'>
															<span class='lnk' @click='pToggle("charNew")'>You can close this</span>
															<br><br>or<br><br>
															<span class='lnk' @click='charNew.stepShow=0'>Create one more character with the same presets</span>.
															<br><br>or<br><br>
															<span class='lnk' @click='charCreateReset(charNew,1)'>Create one more character from scratch</span>.
														</div>
													</td>
												</tr>
											</template>
										</table>
									</transition>
									<br><br>
									<div id='charNewHelp'>
										<div class='green understroke right header'>Help</div>
										<ol>
											<template v-if='charNew.stepShow==0'>
												<li>Set all the desired predefined characteristics above or just leave them empty</li>
												<li>
													Input field to the right from each characteristic is the amount of memories
													you wish to be generated about it at a later stage. In other words,
													if you put 3 here, you will
													get 3 autogenerated memories about this parameter later. Just as
													it goes with predefined topics for memories at the bottom.
												</li>
												<li>
													You can proceed by steps, controlling everything, or just click
													an automatic creation in 1-click of any amount of new characters.
													The choice is yours.
												</li>
												<li>
													If you wish to control every step, click on "click to create by steps" 
													at the top, it will use your predefined 
													parameters to start generating the rest. 
												</li>
												<li>
													If you choose to create everything in one click, it will
													use the predefined values and create as many characters as
													you have requested. The predefined values will be used for all of the
													generations, everything else is re-generated.
												</li>
												<li>
													Please note, if you move back and forth between the steps,
													data is retained. But if you re-generate things, at, say, step 2,
													then everything in the next steps is erased to keep things
													consistent. If you just edit things, data in the next
													steps is not erased, because i believe you know what you do
													with manual editing.
												</li>
											</template>
											<template v-if='charNew.stepShow==1'>
												<li>
													Here you see the values generated for your new character, 
													if you wish, you can correct any of these. It's a good idea to check
													them for consistency.
												</li>
												<li>
													If the reply was 
													bad and generated parameters were not recognized, 
													it will try to repeat the process multiple times,
													regenerating only the absent parameters. 
													You can cancel it with "Esc" button on your keyboard.
												</li>
												<li>
													If you don't like the values, you can click on a link to re-create these.
												</li>
												<li>
													When done, click on the link to move to the next step.
												</li>
											</template>
											<template v-if='charNew.stepShow==2'>
												<li>
													Click on a link in the upper right column to proceed 
													with rephrasing of the generated character parameters into a more human/llm readable form. 
													It adds more life to the system prompt.
												</li>
												<li>
													It may automatically try to do it several times if the model doesn't generate it properly. You can cancel the process with "Esc" button on the keyboard.
												</li>
												<li>
													Once ready, you can edit the resulting system prompt right where it is. The edits
													you make are used in the final character settings.
												</li>
												<li>
													Once you are satisfied click to proceed to the next step.
												</li>
											</template>
											<template v-if='charNew.stepShow==3'>
												<li>
													This step is for creating various memories of the new character.
												</li>
												<li>
													If you don't use RAG and don't want to generate memories,
													you can skip this step by clicking the appropriate link at the 
													top of the right column. 
												</li>
												<li>
													If you wish to generate specific memories, just
													add the desired topics in the left column. You can
													define any amount of topics for model to hallucinate about and
													set any desired amount of these to generate (0-9999). 
													Please note that all of the generated memories remain
													in the context of a model, to make them consistent, so
													requesting a lot of these may overfill your context window
													size (num_ctx).
												</li>
												<li>
													It's a good idea to generate memories with desired
													reactions to the situations you expect. For example: "i feel irritated and i scream",
													"i saw a flower and i cried", "talking to the walls is a sign of a clever person", etc.
													If you have only a few memories, these will almost always emerge, 
													thus somewhat limiting the variativity of character's replies. 
													It means that in general, having a few memories might be a bad idea. 
													However, i often use it as i may just turn rag on and off when needed.
												</li>
												<li>
													Once generated, check the results to ensure everything is consistent.
													You can edit the memories in place.
												</li>
												<li>
													Please note, a click on generation will delete all existing memories.
												</li>
												<li>
													When ready, proceed to the next step.
												</li>
											</template>
											<template v-if='charNew.stepShow==4'>
												<li>
													This uses all the generated data
													and creates a new character.
												</li>
												<li>
													If you didn't have a field with the "name" data, then
													system doesn't know how to call your character. You might
													want to enter the name manually then. Also, be sure to 
													edit the system prompt manually after that.
												</li>
												<li>Enjoy!</li>
											</template>
										</ol>
									</div>
								</div>
							</transition>
						</td>
					</tr>
					<tr v-if='pState["opt"]' id='opt'>
						<td colspan='3' class='center nobg'>
							<opt :branch='branchac':config='config' :settings='settings' :opt='opt' :p-state='pState'></opt>
						</td>
					</tr>
					<tr>
						<td colspan=3 class='center' id='menu'>
							<br>
							<table v-if='pState["menu"]'>
								<tr>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("howto")'><menun k='F1' t='Help'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='save()'><menun k='F2' t='Save'/></span></td>
									<td></td>
									<td><span class='nobgt'><input id='load' type='file' @change='load()'/><label class='lnk' for="load" id="loadlabel"><menun k='F3' t='Load'></label></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("sys")'><menun k='F4' t='Sys prompt'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("instr")'><menun k='F5' t='Instr'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='list()'><menun k='F6' t='Reload models'/> </span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("pull")'><menun k='F7' t='Pull'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='this.prune()'><menun k='F8' t='Prune'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("sets")'><menun k='F9' t='Settings'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='quit()'><menun k='F10' t='Quit'/></span></td>
								</tr>
								<tr>
									<td><span class='nobgt'>Shift+</span>&nbsp;</td>
									<td><span class='gray nobgt'><menun k='F1' t='None'/></span></td>
									<td></td>
									<td><span class='gray nobgt'><menun k='F2' t='None'/></span></td>
									<td></td>
									<td><span class='gray nobgt'><menun k='F3' t='None'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("ragG")' title='Public knowledge'><menun k='F4' t='P.knlg'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("ragU")' title="Character's memory"><menun k='F5' t='Ch.mem'/></span></td>
									<td></td>
									<td><span class='gray nobgt'><menun k='F6' t='None'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='pToggle("charNew")' title="Generate a new character"><menun k='F7' t='Gen.char'/></span></td>
									<td></td>
									<td><span class='gray nobgt'><menun k='F8' t='None'/></span></td>
									<td></td>
									<td><span class='lnk nobgt' @click='optToggle()'><menun k='F9' t='Optimize'/></span></td>
									<td></td>
									<td><span class='gray nobgt'><menun k='F10' t='None'/></span></td>
								</tr>
							</table>
						</td>
					</tr>
				</template>
				<template v-else>
					<tr>
						<td class='center nobg'>
							Ollama url<br>
							<input v-model='this.config.url.v' class='understroke'/>
							&nbsp;<span class='lnk' @click='this.config.url.v=this.def.configGlobal.url.v'>reset</span>
							<br><br>
							<template v-if='this.connectionErr.length'>
								<br>
								<span class='lnk' @click='this.urlTest()'>Re-try</span><br><br>
								{{this.connectionErr}}
							</template>
							<br><br><br><br>
							<table>
								<tr>
									<td colspan=2>
										<p class='header center green'>Installation</p>
										<p>There is not much to install, it's a single index.html file. 
											However, the file needs to connect to your local Ollama server and you have 2 choices for that:
											<ul>
												<li>You can install a local web-server as a reverse proxy.
												<li>If Ollama runs on your own computer, you can use a bad way to configure Ollama to
													allow a specific Origin header. As it still runs only on your local 127.0.0.1 address, others still
													won't be able to connect to it directly. However, sites you visit may use malicious code 
													to connect to your local network, as you run their code in your browser on your local 
													computer. So any site you open theoretically will be able to exploit your Ollama with this.
													You could limit the Origin header to a certain URL only but then you won't be able to run
													this from your local computer only, you would have to access this page on internet,
													which doesn't make much sense in my opinion as it's totally not required.
											</ul>
										</p>
										<p>So here is a longer but better way with a web-server:</p>
										<p>If you already have a web-server, there is not much to say, just put "index.html" from this
											project into any of your web folders, rename it as you wish if needed and access in browser.
										</p>
										<p>If you don't have a web-server, the easiest and the best one is Nginx.</p>
									</td>
								</tr>
									<tr>
									<td>
										Ubuntu:
									</td>
								</tr>
								<tr>
									<td>
										<ol>
											<li>Download the project, let's say it's in ~/ollama-chats
											<li>Open terminal
											<li>sudo apt install nginx
											<li>sudo cp ~/ollama-chats/nginx-ollama.conf /etc/nginx/conf.d
											<li>If you have different paths, make sure to edit the config file.
											<li>sudo cp ~/ollama-chats/index.html /var/www/html/ollama-chats.html
											<li>sudo chmod 640 /var/www/html/ollama-chats.html
											<li>sudo chown "$USER":www-data /var/www/html/index.html
											<li>sudo service nginx restart
											<li>Access http://127.0.0.1/ollama-chats.html in your browser
											<li>If you configured everything correctly, that's it. It was probably just 2-3 minutes.
										</ol>
									</td>
								</tr>
							</table>
						</td>
					</tr>
				</template>
			</table>
		</div>
	</div>
	<div id='tmplNick'><span>({{id}}) {{name}}</span></div>
	<div id='tmplMenuN'><span v-show='config.fKeys.v' class='menuHK'>{{k}}&nbsp;</span>{{t}}</div>
	<div id='tmplField'>
		<div style='display:inline-block' :title='n+": "+i.d' class='nobg'>
			<template v-if='nShow'>{{i.qn??n}}: </template>
			<template v-if='i.f==="ro"'>
				{{i.v}}
			</template>
			<template v-else>
				<template v-if='i.f==="cb"'>
					<input :title='n+": "+i.d' type='checkbox' v-model='i.v' :id='"field"+id'/>
				</template>
				<template v-else-if='i.f==="sel"'>
					<select v-model="i.v.v" :id='"field"+id'>
						<template v-for="(j,jind) in i.v.l">
							<option :value='jind'>{{j.n}}</option>
						</template>
					</select>
				</template>
				<template v-else-if='i.f==="mis"'>
					<template v-for='(k,kind) in i.v'> 
						<span class='nobreak'>{{kind+1}}: 
							<input class='understroke' type='input' v-model='i.v[kind]' :id='"field"+id+kind'/>
						</span><br>
					</template>
				</template>
				<template v-else-if='i.f==="file"'>
					<input :id='"load"+id' type='file' @change='loadFile(id)'/>
					<label class='lnk nobg' :for="'load'+id" :id="'loadLabel'+id">{{n}}</label>
					<template v-if='i.v!=""&&i.unload'><br>
						or <span class='lnk' @click='i.v=""'>remove existing</span>
					</template>
				</template>
				<template v-else>
					<input v-model='i.v' :id='"field"+id'/>
				</template>
			</template>
		</div>
	</div>
	<div id='tmplNickAdd'>
		<table width='100%'>
			<tr>
				<td class='nowrap addTxt right'>
					<div class='right'><span class='nobg'>New {{ut}}:</span></div>
				</td>
				<td class='addVal'>
					<input @keydown.enter='this.userAdd()' v-model='userNickA' :placeholder='ut'/>
				</td>
				<td class='addBtn'>
					(<span class='lnk nobgt' @click='this.userAdd()'>+</span>)
				</td>
			</tr>
			<tr v-show='uListAvail.length'>
				<td class='nowrap addTxt right'><div class='right'><span class='nobg'>Existing {{ut}}:</span></div></td>
				<td class='addVal'>
					<template v-if='amountNicks[t]>groups[group].an[t]'>
						<template v-if='t=="u"'>
							<select class='nickGroupAddList' v-model='userGroupAddId'>
								<template v-for='i in uListAvail'>
									<option :value='i'>({{i}}) {{nicks[i].n}}</options>
								</template>
							</select>
						</template>
						<template v-else>
							<select class='nickGroupAddList' v-model='userGroupAddId'>
								<template v-for='i in uListAvail'>
									<option :value='i'>({{i}}) {{nicks[i].n}}</options>
								</template>
							</select>
						</template>
					</template>
					<template v-else>
						all are in
					</template>
				</td>
				<td class='addBtn'>
					(<span @click='userGroupAdd()' class='lnk nobg'>+</span>)
				</td>
			</tr>
			<tr v-if='t==="a"'>
				<td></td>
				<td colspan='2'>
					<br>
					<span class='lnk nobg' @click='pToggle("charNew")'>Generate new</span>
				</td>
			</tr>
		</table>
	</div>
	<div id='tmplHeardBy'>
		<div class='heardBy' :style='!config.storiesUI.v&&"display:none;"' :title='`New message by (${u}) ${nicks[u].n} will be "heard" only by these users`'>
			<span :class='nicks[u].t=="a"?"nobgb":"nobgt"'>
			<template v-for='id in users'>
				<template v-if='u!=id'>
					<input type='checkbox' v-model='groups[group].u[u][id]'><nick :id='id' :name='nicks[id].n'/>
				</template>
			</template>
			</span>
		</div>
	</div>
	<div id='tmplTalkers'>
		<template v-if='userS(t)!=null'>
			<transition name="slide-fade" mode="out-in">
				<div><!-- :key='group+groups[group]["u"].length'-->
					<table class='talkers'>
						<tr>
							<td :class='t=="a"?"nobgb":"nobgt"'>
								<center>
								<span>
									<span title="This simply changes the set of characters if you don't want to see them all. You can predefine these at the top" @click='groupPrev()' class='lnk groupPN' v-if='config.storiesUI.v&&group>0'>&lt; {{groups[group-1].n}}</span>
									&nbsp;
									<template v-for='(i,id) in groups[group]["u"]'>
										<template v-if='userVis(id)'>
											<span class='nickSel' 
												@click.right.prevent='send($event,1,null,id)'
											:title='
												t==="u"?
													`"Speak for" selector. This selects the character you play for in this turn. For example you nay have your main "hero" and "World" describing the changes of the situation.`
													:`"Reply from:" selector. This selects an AI character that will generate a reply. You can have multiple personages talking to you. Every AI personage has its own instruction (instr) and system prompt. Click on the desired character here and then edit their system prompt by clicking "System prompt" below. Add more AI characters at the top. Hint: right-click on this nick will auto-submit current prompt as this user.`
											'>
												<input 
													:id='"s"+t+id' :name='"s"+t+id' :key='"s"+t+id'
													class='nickSel'
													type='radio' 
													:tabindex='(t==="u"?5100:5500)+id*1' 
													
													@change='userCh()' 
													
													@keydown.enter.stop	='send($event,1,null,id)' 
								
													:value='id' 
													v-model='groups[group]["sel"][t]'
												/>
												<label 
													class='lnk' 
													:for='"s"+t+id'
												><nick :id='id' :name='nicks[id].n'/></label>&nbsp;
											</span>
										</template>
									</template>
									&nbsp;
									<span title="This simply changes the set of characters if you don't want to see them all. You can predefine these at the top" @click='groupNext()' v-if='config.storiesUI.v&&group<(groups.length-1)' class='lnk groupPN'>{{groups[group+1].n}} ></span>
								</span>
								</center>
							</td>
							<td :class='"right "+(t=="a"?"nobgb":"nobgt")' v-if='config.storiesUI.v'>
								<heard-by :u='userS(t)' :config='config' :nicks='nicks' :groups='groups' :group='group'></heard-by>
							</td>
						</tr>
					</table>
				</div>
			</transition>
		</template>
		<template v-else>
			<template v-if='t=="u"'>
				<p class='talkers nobgt'>Please add at least one user you control at the top-right corner.
			</template>
			<template v-else>
				<p class='talkers nobgb'>Please add at least one AI controlled user at the top-right corner.</p>
			</template>
		</template>
	</div>
	<div id='tmplUserList'>
		<template v-for='(i,id) in groups[group]["u"]'>
			<template v-if='userVis(id)'>
				<span class='nick'>
					(<span class='nobg'>{{id}}</span>)
					<input v-model='nicks[id].n'/>(<span @click='userTypeCh(id)' class='lnk userTypeCh nobg' title='Change user type from manual to AI and vice-versa if you all of a sudden decide to control some character yourself or wish AI to control your character.'><template v-if='t=="a"'>&uarr;</template><template v-else>&darr;</template></span>)<span class='nickDelC'>(<span class='nickDel nobg' @click='group==0?userDel(id):userGroupDel(id)'>x</span>)</span>
				</span>&nbsp;
			</template>
		</template>
	</div>
	<div id='tmplHelp'>
		<div id='help'>
			<div class='center understroke header green'>How to chat here, a short guide</div>
			<ol>
				<li>At the top left rename your character, rename Ai character.</li>
				<li>At the top right add more characters if your rpg will have more people.</li>
				<li>Click "system prompt", a new text area opens. 
						Write the definition of the first AI character into the system prompt.
						like "You are...". Alternatively, click on "generate new" (shift+F7)
						and let the system generate a new character for you automatically!
				</li>
				<li>If you have more than one AI character, under the prompt text area
						you will see several radio buttons with the names you created.
						By default the first one is chosen and you've already defined the system prompt
						for this one. Now, click on the next radio button and system prompt
						box will be cleared, as now it is a system prompt of the newly selected
						character. Write a definition for this character. Repeat with all
						AI characters you've created. You can update these anytime during
						the chat.</li>
				<li>Click on "system prompt" link again to hide it.</li>
				<li>Click on "instr". It uses the same logic as system prompt and defines
						instructions for each AI character. You can use it to push character
						towards certain actions in a story. It should be written in first person.
						For example: "i'm so jealous". or "i'm angry". or "i want to..".
						Also you can use it for describing the location of personages, for whatever.
						Use it throughout the chat process, changing accordingly.</li>
				<li>Click on instr to hide it, if you don't want to see the text area.</li>
				<li>Before start, check the settings and set the num_ctx param to a desired value.
						It's a size of the context memory in tokens that AI remembers. 
						Check other settings you may need, like temperature, etc.</li>
				<li>Below the "prompt" text area in the select list choose the model you wish to get reply from.
						if you don't have models, you can click "pull" and download some.
						Names of the models to pull you can see at ollama.com/library website.</li>
				<li>It's a good idea to click "Save" now to save your starting point of the game.</li>
				<li>Type in your first message. it's best to start from introduction,
						like "I'm ...describe yourself... walking/sitting/doing sth.	
						Usually you can put into the system prompts how they are related to you. 
						so the reply should make some sense, when they meet you.</li>
				<li>Hit enter to send your first message.</li>
				<li>Once the model is loaded, which may take time, the character will reply.</li>
				<li>If you dislike the reply, just hit "right" on the keyboard or click the arrows
						on the right of the AI reply.
						repeat until the reply is good.</li>
				<li>If the reply is nearly ideal but something is wrong, just click on the
						reply and edit that part yourself. Erasing of extra bs is a good idea,
						as models love to litter with meaningless garbage, platitudes, etc.</li>
				<li>If you decide that your own message is no good, you can edit it too. or, you can
						create an alternative side-reply, by clicking the "right" arrows on the right
						from your message. Then just type new prompt as usually and send it.</li>
				<li>Use rating buttons for AI messages. By default AI is instructed to follow the style of these. You can disable it in settings, if you wish to use the rating for future finetuning project but do not wish the model to see it in the chat.</li>
				<li>Also, you can use the rating of model's answers in the last turn to instruct the model. If you click "ctrl+right" or (-/+ button to the right from message, it's shown only if you have a rated messages), the model will be instructed to provide a new reply unlike bad ones and alike to the good ones. It may help if the answers are really bad.</li>
				<li>If you are bored with the story development you can anytime use up/down arrows to go up in the story and start another branch there or continue an existing alternative branch.</li>
				<li>It's a good idea to post situation changes from the name of the
						"World" character. like "That person went away". or "it started to rain".
						or "You have noticed that..". etc. To send message from another user
						just type in the prompt, click on the respective radio button above the prompt text area and
						hit enter.</li>
				<li>You can choose which character replies next by clicking on the respective
						radio button under the prompt box. You even can send empty messages,
						to make them talk to each other, that's half of the fun. Empty messages are hidden by default,
						so it looks like they just talk to each other, but you can change it in the settings.
						If they don't want to talk to each other, use "instr" field with sth like
						"now i should reply to.." or add some message from the world. To save a click
						on a prompt, if you just want another ai character to reply, just do a right click on it,
						it will make it choose that character and submit the current prompt right away.</li>
				<li>If you feel you need more control over the character's memory, you can use "Stories", it's enabled in the settings. With this feature on, you can define the access list for all messages, so you can have characters that don't know what's going or who plan something and others have no clue, or just characters that come late and being unaware, etc.</li>
				<li>If you wish, you can define different settings per AI with personal settings in.. settings. This way, for example, you could use 2 different models for 2 characters without need to change them every time.</li>
				<li>To expand the memory and world knowledge of the characters, you can fill in their memories with shift+f4 and shift+f5 keys (P.knlg and Ch.mem. in the menu). You can put any amount of data there and it will be searched by relevance to your last chat context and injected as something that character remembers. To have the best effect, use a lot of synonyms in each line. You can make these relevant not just text, but to moods.</li>
				<li>Repeat the process till the alarm clock is ringing telling you it's time to wake up.
						it was good idea to set alarm clock in your phone to the evening time, so
						you still have time to sleep tonight.</li>
				<li>Enjoy.</li>
			</ol>
		</div>
	</div>
	<div id='tmplOpt'>
		<template v-if='!opt.run'>
			<table id='optL' >
				<tr>
					<td colspan='6'>
						<p class='green center'>
							<span class='header'>Configure here ranges of parameters to try, per model.</span>
							<br>
							<span @click='pToggle("optHelp")' class='lnk'>(click for a short instruction)</span>
						</p>
						<transition name='slide-fade'>
							<div v-if='pState["optHelp"]' id='optHelp' :key='pState["optHelp"]'>
								<p class='justify'>
									Here you can try to optimize parameters to get the replies you like.
									How? Simple, it allows you to set starting value and final value of the range to try,
									as well as step size for next iteration. Then you just see which parameter combinations
									produce the best replies.
								</p>
								<p>
									<ul class='justify'>
										<li>
											IMPORTANT: always set SEED to start=1, end=1, step=1 and toggle on the "use"
											for seed! That guarantees, that replies models produce do not have
											a random element to them. I can not set this as default for 
											logical reasons of various use cases.
										</li>
										<li>
											Before starting this, remember to set everything in settings to 
											default, unless you actually want to use your manual configuration
											together with this. 
										</li>
										<li>
											To make it work you need to set Start value of the range you want to try,
											End value (that is, when to stop) and the Step value, that is how much
											we should add at every next try. For example: temperature start=1,
											end=5, step=2 will try to get replies for temperatures: 1, 3, 5.
										</li>
										<li>
											This thing works PER model. Beautiful. It means, you can set
											separate paramaters to try per each model you wish to try. To do that,
											simply select the model you wish to try and configure parameters to try,
											then switch to a second model and repeat for the second one, etc. Once
											you click "Run" all configured models are tried, one by one.
											Non-configured models are skipped.
										</li>
										<li>
											Most important parameters to play with are: temperature, top_k, top_p,
											mirostat, single prompt.
										</li>
										<li>
											Do not use small steps. Like, if you configure trying temperatures
											from 1 to 300 with the step "1", you get 300 replies to wait for.
											Now, if you you also add to that top_k 1 to 300 with the step 1, that's
											300*300 (every possible temperature vs every possible top_k) which makes
											it 90000 replies to wait for - if your setup generates a reply in 1
											second, that's 25 hours to wait :). So what's your strategy?
											Simply provide a very big steps, like temperature 1 to 300, step 50.
											That's only 6 replies. And top_k 1 to 300 is 6 more. So you get
											36 replies to wait for. If you add to that top_p from 1 to 100, step 20,
											you get 5 more steps, which makes it 36*5=180 replies. Even that is
											a lot, unless your setup is very fast. But with these you will see what 
											these changes do to replies, so you can figure out what rocks your boat.
											Once you know the approximate good parameters combination, you can repeat 
											the process but in that small nice area with a smaller ranges and steps.
										</li>
										<li>
											The results are auto-normalized for your convenience. That means, that
											all identical replies are collapsed into one, all the
											parameter combinations that produced that very same result are placed 
											next to it.
										</li>
										<li>
											Do not try to change settings during the work, it makes everything
											meaningless.
										</li>
										<li>
											Before starting this experiment, first have a your typical chat with ai,
											so it would have some context. Then you can actually see what your
											configuration do in a real chat. Using this with just "hi" is pointless,
											unless you search for an ideal config to run functions or something like 
											that.
										</li>
									</ul>
								</p>
							</div>
						</transition>
					</td>
				</tr>
				<tr>
					<td colspan='6' class='center'>
						Settings for:<fields n='' :i='settings.req.model' :n-show='false'/>
					</td>
				</tr>
				<tr>
					<td colspan='6' class='center' id='optTimes'>
						Amount of replies per combination: <input v-model='opt[settings.req.model.v.v].times'>
					</td>
				</tr>
				<tr>
					<td class='param' title='Name of the parameter to try to be changed'>Param</td>
					<td class='start' title='Starting value of this parameter'>Start</td>
					<td class='end' title='Ending value of this parameter'>End</td>
					<td class='step' title='Step we will go by, walking from start value to end value, for example from 1 to 5 step can be=1.'>Step</td>
					<td class='round' title='Round the parameter to this many decimals, to avoid getting parameters like 3.0000000000000004. If empty, no rounding. Please note, that if you round things wrong, you may end up posting the same combination many times (e.g. if you round 0.1-0.7 to an integer.'>Round</td>
					<td class='use' title='Should we use this parameter in our trial or not.'>Use</td>
				</tr>
				<template v-for='j of [config,settings.options,settings.req]'>
					<template v-for='(i,ind) of j'>
						<template v-if='i.opt===true'>
							<tr>
								<td class='param'>{{i.name??ind}}:</td>
								<template v-if='i.f!="cb"&&i.f!="sel"'>
									<td class='start'><input class='understroke' @keyup="optChUse(settings.req.model.v.v,ind)" v-model='opt[this.settings.req.model.v.v]["v"][ind]["start"]'></td>
									<td class='end'><input class='understroke' @keyup="optChUse(settings.req.model.v.v,ind)" v-model='opt[this.settings.req.model.v.v]["v"][ind]["end"]'></td>
									<td class='step'>
										<input class='understroke' @keyup="optChUse(settings.req.model.v.v,ind)" v-model='opt[this.settings.req.model.v.v]["v"][ind]["step"]'>
									</td>
									<td class='round'><input class='understroke' v-model='opt[this.settings.req.model.v.v]["v"][ind]["rnd"]'></td>
								</template>
								<template v-else>
									<td colspan='4' class='step'>a true/false param, nothing to configure</td>
								</template>
								<td class='use'>
									<input class='understroke' type='checkbox' v-model='opt[this.settings.req.model.v.v]["v"][ind]["use"]'>
								</td>
							</tr>
						</template>
					</template>
				</template>
				<tr>
					<td colspan='6' class='right'><span class='lnk' id='optRun' title="start the experiment" @click='optimizeRun()'>->Run</span></td>
				</tr>
			</table>
		</template>
		<template v-else>
			<p class='header'>Running.. {{opt.count.d}} / {{opt.count.t}} &nbsp;&nbsp;<span class='lnk' @click='optimizeCancel()'>Cancel</span></p>
			<template v-if='opt.vals.length||opt.count.t>0'>
				<table class='optResP' id='optResCur'>
					<tr>
						<td :colspan='opt.vals.length+1' class='center'>{{settings.req.model.v.l[opt.m].n}}<br></td>
					</tr>
					<template v-if='1'>
						<opt-res-vals-header :m='opt.res[opt.m]'></opt-res-vals-header>
					</template>
					<template v-if='1'>
						<opt-res-vals-line 
							:m='opt.res[opt.m]'
							:mid='branch.msg+1'
							:vals='opt.vals'>
						</opt-res-vals-line>
					</template>
				</table><br>
			</template>
		</template>
		<table width='100%' class='center' id='optRes' v-if='opt.count.t>0'>
			<tr>
				<td><span class='header'>.. results .. results .. results ..<br></span><span class='lnk rightf' @click='optResSave()'>Export to a file</span></td>
			</tr>
			<template v-for='(m,mi) in opt.res'>
				<template v-if='m.v.length'>
					<tr>
						<td class='header'>{{settings.req.model.v.l[mi].n}}</td>
					</tr>
					<template v-for='(i,ind) in m.v' >
						<tr>
							<td class='justify'>
								<opt-res :m='m' :i='i'></opt-res>
								<span class='green header'>{{ind+1}}:</span> {{i.c}}
							</td>
						</tr>
					</template>
				</template>
			</template>
		</table>
	</div>
	<template id='tmplOptRes'>
		<table class='rightf optResP'>
			<template v-if='1'>
				<opt-res-vals-header :m='m'></opt-res-vals-header>
			</template>
			<template v-for='(vals,valsid) in i.v'>
				<opt-res-vals-line :mid='i.ids[valsid]+1' :vals='vals' :m='m'></opt-res-vals-line>
			</template>
		</table>
	</template>
	<template id='tmplOptResValsLine'>
		<tr>
			<td class='center'>{{mid}}</td>
			<template v-for='(v,vind) in vals'>
				<td class='center'>
					<template v-if='m.k[vind].f=="cb"'>{{v==0?"False":"True"}}</template>
					<template v-else>{{v}}</template>
				</td>
			</template>
		</tr>
	</template>
	<template id='tmplOptResValsHeader'>
		<tr>
			<td class='center green' title='side message number in the chat'>#</td>
			<template v-for='k in m.k'><td class='center green' :title='`${k.name}: ${k.d}`'>{{k.qn??k.name}}</td></template>
		</tr>
	</template>
	<div id='tmplRagErr'>
		<template v-if='rag.err!=null'>RAG is not working: {{rag.err}}</template>
	</div>
	<div id='tmplRagStatus'>
		<span class='nobgb'>
			<template v-if='rag.err!=null'>
				<rag-err :rag='rag'></rag-err>
			</template>
			<template v-else-if='rag[id].doing'>
				Updating: {{rag[id].done}} / {{rag[id].total}}
			</template>
			<template v-else>
				Total: {{rag[id].v.length}}
			</template>
		</span>
	</div>
	<div id='tmplCharNewParsedParams'>
		<table class='charNewParams'>
			<template v-for='(r,rey) in charNew.parts.paramsCore'>
				<tr>
					<td class='right green'>
						{{r.pnl}} &lt;-> {{r.pnr}}:
						<br>
						<template v-if='charNew.stepShow==0&&r.v==0'>
							random
						</template>
						<template v-else>
							<template v-if='r.v==0'>
								<b>random</b>: {{r.vh}}
							</template>
							<template v-else>
								{{r.vh}}
							</template>
							({{r.vp}}%)
						</template>
					</td>
					<td>
						<template v-if='charNew.stepShow==0'>
							<input :disabled='disabled' @input='charNewCoreParamCh(r)' :class='r.v==0&&"rangeRandom"' type='range' :min='r.min' :max='r.max' v-model='r.v'>
						</template>
						<template v-else>
							<input :disabled='disabled' @change='r.v=$event.target.value;charNewCoreParamCh(r)' :class='r.v==0&&"rangeRandom"' type='range' :min='r.min' :max='r.max' :value='r.c'>
						</template>
					</td>
					<td style='width: 30px'></td>
				</tr>
			</template>
			<template v-for='(p,pey) in charNew.parts.params'>
				<template v-if='(p.n!=""||charNew.stepShow==0)&&!p.h'>
					<tr>
						<td class='right green'>
							<input :disabled='disabled' class='understroke 'v-model='p.n' :placeholder='p.nph'>
						</td>
						<td>
							<template v-if='charNew.stepShow==0'>
								<textarea :disabled='disabled' rows=2 style="width:100%" v-model='p.v' :placeholder='(p.c!=null&&p.c.length)?p.c:p.ph'>{{p.v}}</textarea>
							</template>
							<template v-else>
								<textarea :disabled='disabled' rows=2 style="width:100%" v-model='p.c'>{{p.c}}</textarea>
							</template>
						</td>
						<td v-if='charNew.stepShow==0'>
							<input :disabled='disabled' placeholder='0' title='Amount of memories to generate about this. Leave empty to not generate any memories for this parameter.' class='understroke' style='width:30px' v-model='p.memq'>
						</td>
						<td>
							<template v-if='p.n.length&&!disabled'>(<span class='nobg del' @click='charNewParamsDel(pey)'>x</span>)</template>
						</td>
					</tr>
				</template>
			</template>
		</table>
	</div>
	<template id='tmplCharNewMemSets'>
		<table class='charNewMemSets' v-if='charNew.parts.mem!=null'>
			<tr>
				<td colspan='2' class='center'>
					<span class='nobg green'>Custom topics to generate new memories:</span>
				</td>
			</tr>
			<template v-for='(mc,mey) in charNew.parts.mem.custom'>
				<tr>
					<td title='Topic' style='width: 100%'>
						<textarea :disabled='charNew.working' placeholder='Use this field to create one more topic for memories' v-model='mc.v'>{{mc.v}}</textarea>
					</td>
					<td title='Amount of memories to generate' style='width:40px;vertical-align:middle;'>
						<input :disabled='charNew.working' class='understroke' style='width:30px' v-model='mc.q'>
					</td>
					<td v-if='!charNew.working' title='Delete the topic' style='width:40px;vertical-align:middle;'><template v-if='mey!=charNew.parts.mem.custom.length-1'>(<span class='nobg del' @click='memSetsDel(charNew,mey)'>x</span>)</template></td>
				</tr>
			</template>
			<template v-if='charNew.stepShow>0&&charNew.parts.memCountT.hasOwnProperty("params")&&charNew.parts.memCountT["params"]>0'>
				<tr>
					<td colspan='3'>
						<div class='nobg green'>
							Topics below are not editable at this step as these use model generated content. If you wish to change the value, you can edit parsed parameters at the step 2 and then to regenerate the system prompt, to keep things consistent.
						</div>
					</td>
				</tr>
				<template v-for='(p,pey) in charNew.parts.params'>
					<tr v-if='p.memq!=""&&p.memq>0'>
						<td title='Topic' style='width: 100%'>
							<textarea disabled=1>{{p.memt.length?p.memt:`${p.n}: value that will be generated`}}</textarea>
						</td>
						<td title='Amount of memories to generate' style='width:40px;vertical-align:middle;'>
							<input :disabled='charNew.working' class='understroke' style='width:30px' v-model='p.memq'>
						</td>
						<td v-if='!charNew.working' title='Delete the topic' style='width:40px;vertical-align:middle;'>
							(<span class='nobg del' @click='p.memq=""'>x</span>)
						</td>
					</tr>
				</template>
			</template>
		</table>
	</template>
	<template id='tmplCharNewMemParsed'>
		<table width='100%' class='memParsed'>
			<tr>
				<td colspan='2' class='left'>
					<span class='left green nobg'>
						<template v-if='charNew.stepShow==3'>
							Parsed memories: {{charNew.parts.m.length}} / {{charNew.parts.memCountT.total}}
						</template>
						<template v-else>
							Memories: {{charNew.parts.m.length}} / {{charNew.parts.memCountT.total}}
						</template>
					</span>
				</td>
			</tr>
			<template v-if='charNew.parts.m.length'>
				<template v-for='(m,mey) in charNew.parts.m'>
					<tr>
						<td style='width:20px;vertical-align: middle;' class='middle right green'><div class='nobg'>{{mey+1}}:</div></td>
						<td style='width:100%'>
							<textarea :disabled='charNew.working' rows='4' v-model='charNew.parts.m[mey]'></textarea>
						</td>
						<td style='width:20px;vertical-align: middle;'>
							<template v-if='!this.charNew.working'>(<span class='nobg del' @click='memParsedDel(charNew,mey)'>x</span>)</template>
						</td>
					</tr>
				</template>
			</template>
			<template v-else-if='charNew.stepShow==3'>
				<tr>
					<td colspan='2' class='center'>
						<span class='nobg'>..nothing yet..</span>
					</td>
				</tr>
			</template>
		</table>
	</template>
	<template id='tmplCharNewSystemEdit'>
		<div class='left'>
			<span class='lnk nobg' @click='pToggleDo("charNewSys"+id)'>Show the prompt used for generation</span>
			<transition name='ta'>
				<div v-if='pState["charNewSys"+id]' :key='pState["charNewSys"+id]'>
					<div class='nobgt rightf'>System prompt</div>
					<textarea :disabled='charNew.working' rows='7' :id='"charNewSys"+id' v-model='charNew.parts.system[id].sys'></textarea>
					<span class='lnk nobgb' @click='charNewSystemReset(charNew,id)'>restore</span>
					<br><br>
					<template v-for='(r,rey) in charNew.parts.system[id].req'>
						<div class='rightf nobgt'>{{r.t}}</div><br>
						<textarea :disabled='charNew.working' rows='7' v-model='r.req'></textarea>
						<span class='lnk nobgb' @click='charNewReqReset(charNew,id,rey)'>restore</span>
						<br><br>
					</template>
				</div>
			</transition>
		</div>
	</template>
	<div id='tmplCss'>
<style id='css'>
html {
}
.tmpl {
	display: none;
}
* {
	font-size: 14px;
	font-family: Arial;
	transition: all 0.71s ease-out;
//	color: #e5e5e5;
}
::selection {
  color: #10ee10;
  background: #103510;
}
body {
	background-color: #141414;
	color: #e0e0e0;
	background-size: 100% auto;
	background-repeat: repeat-y;
}
textarea {
	text-size: 16px;
	//background-color: black;
	background-color: rgba(0,0,0,0.45);
	color: #e0e0e0;
//	color: white;
	width: 100%;
	box-sizing: border-box;
	border-color: silver;
	border-radius: 5px;
  border-image: linear-gradient(#103510, #141414, #103510) 2/3px 2px 3px 2px;
  box-shadow: 0px 0px 7px rgba(0,0,7,0.7);
  padding: 10 10 10 10;
}
textarea:focus {
	outline: #e0e0e0 solid 1px;
	background-color: rgba(0,0,0,0.45);
	border-color: silver;
}
input {
	text-size: 16px;
	background-color: rgba(0,0,0,0.45);
	color: #15ea15;
	accent-color: darkgreen;
	outline-color: transparent;
	box-sizing: border-box;
	border-color: transparent;
	border-width: 0 0 1 0;
	border-radius: 5px;
	padding: 4 3 2 3;
  text-align: center;
}
input:focus {
	outline: none;
}
input[type=checkbox] {
	accent-color: darkgreen;
	padding: 3 3 3 3;
}
input[type="file"] {
	display: none;
}
select {
	text-size: 16px;
	color: mediumseagreen;
	background-color: rgba(0,0,0,0.45);
	//background-color: black;
	box-sizing: border-box;
	border-color: #e0e0e0;
	//margin: 15 15 15 15;
	padding: 5 2 2 2;
  border-image: linear-gradient(#103510, #141414, #103510) 2/3px 2px 3px 2px;
}
#app {
	width: 100%;
}
li {
	margin-bottom: 7px;
}
#bg {
	position: absolute;
	z-index: -1;
	width: 100%;
	height: 100%;
}
.imgEmbed {
	width: 150px;
}
.imgBig {
	width: 100%;
}
.imgPrompt {
	width: 35px;
}
#imgAdd {
	padding-top: 0px;
}
#imgAddList {
	padding: 2 5 2 2;
}
.chatLogImg {
	padding: 2 2 2 5;
}
#chat {
	width: 800px;
	max-width: 800px;
	margin: auto;
	height: 100%;
	border-spacing: 13px 10px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/2px 0px 2px 0px;
}
#chat td {
	border-width: 0px;
	vertical-align: top;
	border-radius: 7px;
	padding: 7 10 5 10;
}
#chat #nicks td {
	text-align: left;
	padding: 2 5 2 5;
	vertical-align: middle;
}
.talkers {
	width: 100%;
	border-spacing: 0;
	text-align: center;
	padding: 0 0 0 0 !important;
	margin: 0 0 0 0 !important;
}
.talkers td {
	border-spacing: 0px;
	padding: 0 0 0 0 !important;
}
#talkersB {
	border-spacing: 0px 0px;
	width: 100%;
}
#talkersB td {
	border-width: 0px;
	vertical-align: top;
	padding: 0 0 0 0 !important;
}
#memGen {
	width: 100%;
}
.memParsed {
	width: 100%;
	border-spacing: 13px 10px;
}
#charNew {
	width: 100%;
	padding: 5 10 10 10;
	margin-top: 20px;
	& td {
		width: 50%;
		height: 100%;
	}
}
#charNewStep {
	width: 100%;
}
#charNewStep td {
	width: 33%;
}
#charNewHelp li {
	text-align: justify;
}
.charNewMemSets {
	width: 100%;
	border-spacing: 13px 10px;
}
.charNewParams {
	width: 100%;
	& td {
		vertical-align: middle!important;
	}
	& td:nth-child(1) {
		width: 120px !important;
		max-width: 120px !important;
		min-width: 120px !important;

		& input {
			width: 100%;
			min-width: 90px;
			text-align: right;
		}
	}
	& td:nth-child(3) {
		width: 30px !important;
	}
	& td:nth-child(4) {
		width: 30px !important;
	}
	& td:nth-child(2) {
		width: 100% !important;
		& input[type="range"] {
			width: 100%;
			min-width: 90px;
		}
	}
}
#chatLogC {
//	display: block;
	overflow: scroll;
//	max-height: 300px;
	scrollbar-color: mediumseagreen;
}
#chatC {
	background-size: 100% auto;
	background-repeat: repeat-y;
}
.chatRow {
}
.nobg {
	padding: 5 5 5 5;
	background-color: rgba(0,0,0,0.7);
	border-radius: 25px;
	box-shadow: 0px 0px 7px rgba(0,0,7,0.7);
}
.nobgb {
	padding: 0 5 5 5 !important;
	background-color: rgba(0,0,0,0.7);
	border-radius: 0px 0px 9px 9px !important;
	box-shadow: 0px 0px 7px rgba(0,0,7,0.7);
}
.nobgt {
	padding: 5 5 5 5 !important;
	background-color: rgba(0,0,0,0.7);
	border-radius: 9px 9px 0px 0px !important;
	box-shadow: 0px 0px 7px rgba(0,0,7,0.7);
}
#menu .nobg {
	padding: 1 1 1 1;
	background-color: rgba(0,0,0,0.75);
	display: block;
	width: 100%;
	font-weight: bold;
}
#chat #nicks * {
	font-size: 12px;
}
#chat #nicks input {
	width: 95px;
	font-size: 12px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#chat .nicku,#chat .nickai {
	font-size: 12px;
	font-style: italic;
	background-color: #101910;
	clear: both;
	padding: 10 10 10 10;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/2px 0px 2px 0px;
}
.filterDark {
	filter: brightness(50%);
}
.filterGray {
	filter: saturate(0%) brightness(60%);
}
.rangeRandom {
	filter: invert(100%) hue-rotate(180deg);
}
.gray {
	filter: saturate(0%) brightness(60%);
}
.msgUserList * {
	filter: saturate(0%);
}
.msgTextCont {
	height: 100%;
}
.msgTextCont:hover .nicku,.msgTextCont:hover .nickai {
	border-radius: 0px;
	border-width: 0px;
	border-image: linear-gradient(to right, #023502, #306530, #306030, #023502) 3/2px 1px 2px 1px;
  background: radial-gradient(85% 1110%, #054505,#002000);
}
.msg:hover,.lastmsg:hover {
 	background-color: #002500;
}
.msgNicks, .msgNicks * {
	font-size: 10px;
}
.msgNicks {
	margin-right: 15px;
	vertical-align: middle;
}
#chat .nicku {
	float: left;
	margin: 0 7 7 0;
}
#chat .nickai {
	float: right;
	margin: 0 0 7 7;
}
#chat .msgText {
	padding: 11 4 1 4;
	white-space: pre-wrap;
}
#chat .lastmsg {
}
#chat .next,#chat .prev {
	vertical-align: middle;
	min-width: 20px;
	font-weight: bold;
	text-align: center;
  padding: 2 2 2 2;
  height: 100%;
}
.next *,.prev * {
  color: #15c015;
}
.prevC,.nextC {
	display: flex;
	flex-direction: column;
	height: 100%;
	gap: 5px;
  background-color: #141414;
}
.prevC div,.nextC div {
	display: flex;
	justify-content: center;
	align-items: center;
	flex: 1;
  border-image: linear-gradient(#103510, #141414, #103510) 2/3px;
	padding: 7px;
}
.prevC div:hover,.nextC div:hover {
  background: radial-gradient(150% 200%, #052005, #141414);
}
.prevC div,.nextC div {
  border-radius: 7px;
}
#menu table {
	border-spacing: 0px 5px;
}
#menu table td {
	padding: 1px;
	padding-top: 4px;
	text-align: justify;
	white-space: nowrap;
}
#chat .msg, #chat .lastmsg {
	height: auto;
	border-image: linear-gradient(to right, #141414, #205520, #205520, #141414) 5/1px 0px 2px 0px;
}
#loadlabel {
  display: inline-block;
  cursor: pointer;
}
#loadRaglabel {
  display: inline-block;
  cursor: pointer;
}
.msgFooter {
	margin: 7 7 7 7;
	float: right;
	clear: none;
}
.rating {
	vertical-align: middle;
}
.rating * {
	font-size: 18px;
}
.litp {
	color: #15c015;
}
.litn {
	color: #d51515;
}
#contextFilter {
	text-align: right;
	padding: 0 10 0 0 !important;
	margin: 0 10 0 0 !important;
}
#contextFilterRow td {
	padding: 0 10 0 0 !important;
	margin: 0 10 0 0 !important;
}
#contextFilter * {
	text-align: right;
	font-size: 10px;
}
#contextFilter * input {
	padding-right: 2px;
	margin-right: 2px;
	width: 10px;
	height: 10px;
}
.understroke {
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#sysinstr {
	width: 100%;
	text-align: center;
	margin: 10 0 0 0;
	padding: 0 0 0 0;
}
#sysinstr td {
	text-align: center;
	border-spacing: 0px 0px;
	margin: 0 0 0 0;
	padding: 0 0 0 0;
}
#sets {
	max-width: 800px;
	width: 800px;
	text-align: center;
}
#sets .title {
	width: 400px;
	text-align: right;
}
#sets .def {
	width: 180px;
	vertical-align: middle;
}
#sets .val {
	width: 200px;
	overflow: clip;
	max-width: 200px;
	min-width: 200px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
	padding: 0px;
	margin: 7 10 5 10;
	vertical-align: middle;
}
#sets input {
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#sets .setsQ {
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
	width: 20px;
	padding: 0px;
	vertical-align: middle;
}
#setsQ div {
	color: silver;
}
#setsQ input {
	width: 30px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
	padding: 0px;
	margin: 2 2 2 2;
	vertical-align: middle;
}
#setsQ input[type='checkbox'] {
	width: 10px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
	padding: 0px;
	margin: 2 7 2 0;
	vertical-align: middle;
}
#sets .val input {
	border-width: 0 0 0 0;
	text-align: center;
}
#optRes {
	border-color: mediumseagreen;
	border-radius: 5px;
	border-spacing: 0px 15px;
}
#optResCur {
  margin-left: auto;
  margin-right: auto;
}
#optResCur td {
	padding: 7 10 5 10;
	border-width: 2px;
	border-radius: 5px;
  border-image: linear-gradient(#103510, #313531, #265126) 2/3px 2px 3px 2px;
}
.optResP {
	margin-left: 10px;
	margin-bottom: 5px;
	margin-top: -7px;
}
#optRes .header {
	font-size: 16px;
	color: mediumseagreen;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#optRes td {
	padding: 7 10 5 10;
	word-wrap: break-word;
	border-width: 2px;
	border-radius: 5px;
  border-image: linear-gradient(#103510, #313531, #265126) 2/3px 2px 3px 2px;
}
#optRun {
	font-size: 16px;
	font-weight: bold;
}
#optTimes input {
	width: 30px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#optL {
	width: 100%;
	//border-color: mediumseagreen;
	//border-radius: 5px;
  //border-image: linear-gradient(#103510, #141414, #103510) 2/3px 2px 3px 2px;
}
#optL .param {
	text-align: right;
	min-width: 175px;
	max-width: 200px;
}
#optL .start, #optL .end, #optL .step  {
	text-align: center;
	max-width: 55px;
	vertical-align: middle;
}
#optL .use {
	text-align: center;
	min-width: 35px;
}
#optL .start input, #optL .end input, #optL .step input {
	text-align: center;
	width: 55px;
}
#optL .round {
	text-align: center;
	min-width: 35px;
	max-width: 35px;
}
#optL .round input {
	text-align: center;
	width: 35px;
}
.nowrap * {
	white-space: nowrap;
}
.groups {
	color: mediumseagreen;
	font-style: italic;
}
.groupSel {
	font-weight: bold;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
.groupDel {
	color: #d51515;
}
.groupPN {
	font-size: 10px;
	vertical-align: middle;
	padding: 3px;
}
.nickDel {
	cursor: pointer;
	text-decoration: underline;
}
.del,.red {
	color: #d51515;
}
.del {
	cursor: pointer;
	text-decoration: underline;
}
.nickGroupAddList {
	margin: 2 2 2 2;
	padding: 4 3 2 3;
	width: 100%;
	font-size: 12px;
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
.userTypeCh {
	font-weight: bold;
}
.nickDelC {
}
.nickDel {
	color: #d51515;
}
#nicks {
	width: 200px;
}
#nicks .addTxt {
	vertical-align: middle !important;
	text-align: right;
	margin-right: 0px !important;
	padding-right: 0px !important;
	min-width: 90px;
	max-width: 90px;
}
#chat #nicks .addTxt *, #chat #nicks .nicksListTitle * {
	font-size: 10px;
}
#nicks .addVal {
	vertical-align: middle;
	min-width: 100px;
	padding-left: 0px !important;
}
#nicks .addVal {
	vertical-align: middle;
	min-width: 100px;
	padding-left: 0px;
	padding-right: 0px !important;
	margin-right: 0px !important;
}
#chat #nicks .addVal input {
	vertical-align: middle;
	width: 100px;
}
#nicks .addBtn {
	vertical-align: middle !important;
	padding-left: 0px !important;
	margin-left: 0px !important;
}
.nick {
	white-space: nowrap;
	padding: 5 0 5 0;
	display: inline-block;
}
.left {
	text-align: left;
}
.right {
	text-align: right;
}
.leftf {
	float: left;
	clear: none;
}
.rightf {
	float: right;
	clear: none;
}
.center {
	text-align: center;
	margin: 0 auto;
}
.justify {
	text-align: justify;
}
.middle {
	vertical-align: middle;
}
.nobreak {
	white-space: nowrap;
}
.bold {
	font-weight: bold;
}
.lnk, a {
	text-decoration: underline;
	color: mediumseagreen;
	cursor: pointer;
}
input[type="radio"] {
	accent-color: green;
}
.msgText[contenteditable]:focus {
  outline: 0px solid darkgreen;
}
.heardBy {
	display:block;
	clear: none;
	float: right;
	//min-width: 50%;
	text-align: right;
}
.heardBy * {
	font-size: 10px;
}
.heardBy input {
	width: 10px;
	height: 10px;
}
#prompt {
  padding: 11 7 11 7;
  margin: 0 0 0 0;
  border-width: 1px;
  outline: 0px;
}
#prompt:focus, #prompt:hover,#sys:hover,#sys:focus,#instr:hover,#instr:focus,#rag:hover,#rag:focus {
  background-color: #002500;
  outline: 0px;
}
#sysTitle {
	text-align:left;
	font-size: 12px;
	color: silver;
}
#instTitle {
	float: right;
	clear:none;
	font-size: 12px;
	color: silver;
}
#ragTitle {
	text-align:left;
	font-size: 12px;
	color: silver;
}
#ragC {
	width: 100%;
}
#remembered {
	padding: 5 10 10 10;
}
#ragC table {
	width: 100%;
	text-align: center;
	margin: 0 0 0 0;
	padding: 0 0 0 0;
}
#ragC td {
	width: 100%;
	margin: 10 0 0 0;
	padding: 0 0 0 0;
}
.small {
	font-size: 12px;
}
#howto {
	text-align: justify;
	margin-top: 20px;
}
#help {
	padding: 5 10 10 10;
}
.slide-fade-enter-active {
  transition: all .2s ease;
}
.slide-fade-leave-active {
  transition: all .2s;
}
.slide-fade-enter-from {
  transform: translateY(7px);
  opacity: 0;
}
.slide-fade-leave-to {
  transform: translateY(-7px);
  opacity: 0;
}
.ta-enter-active {
  transition: opacity .35s ease;
}
.ta-leave-active {
  transition: opacity .21s ease;
}
.ta-enter-from {
  opacity: 0;
  color: mediumseagreen;
}
.ta-leave-to {
  opacity: 0;
  color: mediumseagreen;
}
.tokens span,.tokens {
	font-size: 11px;
}
.tokens {
	vertical-align: middle;
}
#sets .headerC {
	padding-top: 7px;
	padding-bottom: 9px;
}
#sets .txt {
	padding: 10 14 10 10;
	background-color: #002500;
	border-radius: 14px;
}
#sets .setsRow {
}
#sets .header {
	border-image: linear-gradient(to right, #141414, #306530, #306030, #143514) 3/0px 0px 2px 0px;
}
#sets .header * {
	font-size: 16px;
}
#heading {
	text-align: center;
}
#heading * {
	font-size: 12px;
}
.header {
	font-size: 16px;
	font-color: mediumseagreen;
}
.nickSel * {
}
.nickSel * {
	font-size: 12px;
}
.nickSel input {
	width: 10px;
	height: 10px;
}
.models {
	font-size: 12px;
}
.green {
  color: mediumseagreen;
}
#chat .empty {
	font-size: 10px;
	font-style: italyc;
	vertical-align: middle;
}
#chat .error {
	font-size: 12px;
	font-style: italyc;
	vertical-align: middle;
	color: #d51515;

}
</style>
	</div>
</div>

<script type="module">

import { createApp,reactive,computed,ref,nextTick,inject,provide } from 'vue';


window.app=createApp({
	template:'#tmplChat',
	data() {
		return {
			def:{},
			prompt:	'',
			groups: [],
			group: 0,
			groupAddN: '',
			context: {1:true,2:true,0:false,3:true},
			turns: [
				{
					"role":'root',
					'branch':0,
					'branches':[{msg:0,msgs:[{
							"content":	'',
							"nick":		'',
							"nicks":{},
							an:{}
						}]}],
					'tree':{0:{ 0:0 }},//parent's branch:{selected msg:local branch growing from that msg}
				},
			],
			models: [],
			modelsEmb: [],
			pState: {
				sys:		1,
				instr:	0,
				sets:		0,
				pull: 	0,
				howto: 	0,
				optHelp:0,
				opt: 		0,
				menu:		1,
				control:1,
				ragU:		0,
				ragG:		0,
				charNew:0,
				ragMemGen:0,
			},
			configGroups: {
				ver:		{ name:'Version'									},
				url:		{ name:'Connection settings'			},
				logic:	{ name:'Chat logic features'			},
				stories:{ name:'Stories features'					},
				rag:		{ name:'Memories (rag) features'	},
				rating:	{ name:'Rating features'					},
				design:	{ name:'Design features'					},
				ui:			{ name:'User interface features'	},
				reply:	{ name:'Reply cleaning features'	},
				imgs:		{ name:'Vision features'					},
				ollama:	{ name:'Ollama settings'					},
			},
			configGlobal: {
				version:						{ g:'ver',name:'Version',v:'1.9.8b',def:'',d:'UI version, just for information and upgrades','f':'ro',qn:'ver',q:null,opt:false },
				themeWhite:					{ g:'design',name:'Invert colors',v:false,d:"Inverted colors, if you are weird person preferring white backgrounds, you may check this. But it looks scary, beware.",def:false,f:'cb',q:false,qn:'clrs',opt:false},

				rooms:							{ g:'logic',name:'Use single prompt to send the chat',v:true,def:true,d:"If true, all messages are concatenated and sent to AI as one big prompt, AI will take all the chat as a single input prompt generated by user. If it's off, chat is sent as a set of messages, then AI can see which messages were created by AI and which ones by user. Which one is better depends on the model.",f:'cb',q:false,qn:'sngl',opt:true},
				otherAiAsUser:			{ g:'logic',name:'Other AI personages are "users" for AI',v:true,d:"When multi-message mode is used to send chat log to AI (that is single-message format is off) mark messages of other AI characters as created by the user. If you have 3 personages, only the current character's messages are marked for AI as AI generated ones. Experimental thing, i think the reaction will be model dependant.",def:true,f:'cb',q:false,qn:'ai usr',opt:true},
				sysNick:						{ g:'logic',name:'System nick instructing model',v:'World',d:"Sometimes we inject special messages into the stuff sent to AI. For example, rating instructions. To do that we need to have some name of the user sending it. We could do it on behalf of AI but it's less flexible. This is the nick of that 'special person' that injects hidden messages for AI.",def:'World', f:'',q:false,qn:'s-nick',opt:false },

				stories:						{ g:'stories',name:'Stories: separate context memory per character',v:false,d:"In all of the other UI i know (on the moment of writing this) characters see all of the chat history. I came up with a new idea, with this feature every personage can have each own context within the chat. For example, you may talk to a character A and do various things. Then you can introduce character B and that character will not know anything about things you did with character A. Every message is marked with the list of characters that can see it. You define it when you send the message for both your message and AI's one. You can see the 'access list' under every message and change it. The chat log is automatically filtered when you choose your and ai chars for the next messages. You can change the filter mode under the chat log at the right. Obvious usage for this can be: two different stories intersecting at some point, where one group plans something or does something and another doesn't know about it. A classic scenario of talking on the phone. Or when character 'thinks' and you don't want other characters to know these thoughts, you can with one click remove them from the message's access list. In other words, it makes it possible to simulate real stories and there is no more need to persuade AI that it shouldn't be aware of something in the chat log :). It comes at a cost of more complicated interface. I've spent a lot of time, much more than coding, on coming up with this interface, to make it as convenient as possible and intuitive. It's still harder than usual one but i believe it's a good one and trust me, as obvious as it seems when you see it, it wasn't easy to form the idea into UI :). Turning this off will disable all existing limits and all characters will see everything.",def:false,f:'cb',q:false,qn:'strz',opt:true },
				storiesUI:					{ g:'stories',name:'Show stories UI',v:false,d:"Show or hide stories interface without disabling it under the hood. If you wish it to work but don't want to see it all the time, just disable it here. If you turn it on, it will automatically turn on the stories feature as well, to prevent the confusion. Stories feature is separate context per character, every message can have its own list of characters that can 'know/see' it.",def:false,f:'cb',q:true,qn:'strz-ui',opt:false },

				rag:								{ g:'rag',name:'Use memories (rag)',v:'true',d:'You can add unlimited memories to your characters by inserting it into rag field (Shift+F4, Shift+F5) but sometimes it causes repeatitive answers as AI tends to like replying in likeness to that data. Also, you may wish to turn it off if you do not have a second instand of Ollama running, as it would wipe the cache at every usage and getting new replies would be slow. Normally, you need to run second Ollama for embeddings calculations and configure it with URL for embeddings, then it shall work very fast.',def:true,f:'cb',q:true,qn:'rag',opt:true },
				ragUAmount:					{ g:'rag',name:'Number of personal memories (rag lines) to use',v:3,d:"Seaching in the memory of a character (rag) returns all of its content by separate paragraphs (lines) sorted by relevance, but the model can't remember everything, so we can't feed model with all that info. We have to choose only a certain number of top relevant (hopefully) lines found in memories. This value defines how many top relevant memory lines we will feed to the model before it replies.",def:3,f:'',q:false,qn:'ragUAmnt',opt:true },
				ragGAmount:					{ g:'rag',name:'Number of public knowledge (rag lines) to use',v:2,d:"Seaching in a public knowledge (rag) accesible to all characters returns all of its content by separate paragraphs (lines) sorted by relevance, but the model can't remember everything, so we can't feed model with all that info. We have to choose only a certain number of top relevant (hopefully) lines found in knowledge. This value defines how many top relevant lines we will feed to the model before it replies.",def:3,f:'',q:false,qn:'ragGAmnt',opt:true },
				ragMinSmlr:					{ g:'rag',name:'Minimum required similarity value for rag',v:0.45,d:"When you use memories/knowledge (rag) each line of your data stored there is returned with certain index of similarity, that is, how similar it is to your prompt. We return only N top most relevant entries, but even so they might be not relevant at all if memories have just nothing alike. In that case you can filter these off by setting minimal requires similarity level here. I set a default value to 0.45 to filter out most obvious unrelated stuff, but to be honest it can't be predefined as different embedding models have different scales, so you might need to check this yourself by looking at 'Remembered' section of memories panel during your chat. It also depends on how well you write the data for character memories, if you don't have enough generic synonyms there, the relevance will be slow. But in any case, here it is for you to use if needed. If it's empty, it's not used.",def:'0.45',f:'',q:false,qn:'ragMinSmlr',opt:true },
				ragPast:						{ g:'rag',name:'Number of past chat messages for similarity search in memories (rag)',v:2,d:"Using a single message to search in memories is fine with documents but is totally not enough for chats. Imagine your last message is just 'what?!' and nothing is found in rag relevant to that. To fix this, you can set how many last messages are going to be used for searching for something similar. But don't set it high as there is a limit to how much embedding model can make sense of. 2-3 messages is the best, i believe. 2 would mean your prompt + the last message from chat.",def:2,f:'',q:false,qn:'ragpast',opt:true },
				ragShuffle:					{ g:'rag',name:'Shuffle found top memories randomly',v:false,d:"To add randomness you can shuffle found top memories before adding them to AI's 'head'. It may make replies more random but at the cost of longer wait for a side-reply, as model will have to recalculate longer text each time instead of just using cache from the last attempt.",def:true,f:'cb',q:false,qn:'ragShfl',opt:true },

				hideEmptyOwn:				{ g:'ui',name:'Hide own empty replies',v:true,def:1,d:'Hide own empty replies (the ones where you just clicked enter). Setting this to false can be useful if you wish to branch a conversation at a turn of your empty reply. Otherwise these just irritate.','f':'cb',q:true,qn:'no emp',opt:false },
				showEmptyOwnSide:		{ g:'ui',name:'Force show own empty replies when there are side-replies',v:true,def:true,d:`Show own empty replies if there are alternative side-replies available, even if hideEmptyOwn is true. Otherwise you wouldn't be able to see prev/next branches if you've sent an empty message, because there would be no 'crossroads' message shown.`,'f':'ro',opt:false },
				setsQ:							{ g:'ui',name:'Show quick settings',v:true,d:"Shows fields for quick access to settings that you often mayy change. You can configure which one are in the list in settings.",def:true,f:'cb',q:null,opt:false },
				fKeys:							{ g:'ui',name:'Enable F1-F10 keyboard keys for menu',v:true,d:"Allows you to access the bottom menu functions with F1-F10 keys of your keyboard. You can disable it if you don't want to lose 'F5' for page reloading, etc",def:true,f:'cb',q:false,qn:'Fs',opt:false },
				tokensCount:				{ g:'ui',name:'Show token counts reported by ollama',v:false,d:'Show the count of tokens in messages. As it\'s broken in Ollama, disabled by default. Stores tokens per model as these differ.',def:false, f:'cb',q:false,qn:'tkns',opt:false },
				setsDescrShow:			{ g:'ui',name:"Show descriptions for configuration values",v:true,d:"Enables showing descriptions for each parameter below parameter's name, otherwise shows only as a tooltip.",def:true,f:'cb',q:null,opt:false},

				imgsLastOnly:				{ g:'imgs',name:'Send last message images only',v:true,d:"If this is checked, only the images added to your last (current) prompt are sent to AI. Otherwise all images from the chat history are sent. It's implemented as sending all images takes a lot of time for AI to re-evaluate them, also, when you use a single-message mode for the chat, there is no way to embed images into the middle of conversation and they all are perceived as the last ones. To avoid these rakes i've set this to 'true' by default.",def:true,f:'cb',q:false,qn:'imgLast',opt:true },

				emojiNo:						{ g:'reply',name: 'Auto-remove emojis',v:false,def:false,d:"Erase emojis from model's output",f:"cb",q:false,qn:'noemj',opt:false },
				resClean:						{ g:'reply',name:'Auto-clean reply from junk',v:true,d:"Should the reply be auto-cleaned of 'Name: ' and other known garbage.",def:true,f:'cb',q:false,qn:'cln',opt:false },
				resBufCleanSize:		{ g:'reply',name:'Buffer size before printing reply',v:10,d:"Buffer size that should be filled before it starts showing your the reply. It's needed to prevent jerking of the reply when we clean it from the litter of names and other marks.",def:10,f:'',q:null,opt:false },

				bgImg:							{ g:'design',name:'Background image',d:"You can load background image. If you use inverted colors scheme, you've to load an image with inverted colors ;)",def:'',f:'file',q:null,opt:false,unload:true,sess:false,v:'data:image/jpeg;base64,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'},
				bgFixed:						{ g:'design',name:'Fix background image position',v:true,d:"You can make the background image fixed or repeated vertically, as you like more. If this one is disabled, it's repeated. To make image look seemless in this case you can vertically mirror it at stitch to the bottom of your original image.",def:true,f:'cb',q:'bgFix',opt:false},
				msgFontSize:				{ g:'design',name:'Font size of the message text',v:'14px',d:'Font size of the message text. As it modifies the inline style and not the css itself, it might be slow on big chats and slow computers.',def:'14px',f:'',q:null,opt:false},
				taFontSize:					{ g:'design',name:'Font size of the input text areas',v:'14px',d:'Font size of the text in prompt, instr and system prompt text areas.',def:'14px',f:'',q:null,opt:false},
				chatHeight:					{ g:'design',name:'Height of the chat log',v:'',d:"If you prefer a fixed chat log height with a scroller inside, set this to the desired height of your chat log. The valus is in pixels, use only a number, like '300'.",def:'',f:'',q:'logHeigh',opt:false},

				url: 								{	g:'url',name:'URL',v:"http://127.0.0.1:11434",def:'http://127.0.0.1:11434',d:'URL of the Ollama service',q:null,opt:false,sess:true},
				urlEmb: 						{	g:'url',name:'Embeddings instance URL',v:"http://127.0.0.1:11434",def:'http://127.0.0.1:11434',d:"URL of the Ollama service to use for embeddings calculations. It can be the same but in that case every such request clears cache and causes prompt re-evaluation, so caching doesn't work with rag. I recommend running a second instance of Ollama on another port to handle embeddings.",q:null,opt:false,sess:true},

				instrWithSideRating:{ g:'rating',name:'Stil use "instr" for side-replies when side-rating is on ',v:true,d:"Shoud your instruction (instr) be used when you request side-message with rated examples (ctrl+right). Instruction may interefere with the examples as AI gets confused with what you want from it, there are bad examples, good examples and also an instruction for new reply, not mentioning the context. You may switch this off. It has effect only when you request for rated side-replies, otherwise this setting is not used.",def:true, f:'cb',q:false,qn:'s-rate',opt:false },
				badExForSideReply:	{ g:'rating',name:'Use that many -ed side replies for new ones',v:3,d:'When you ask for one more side message from AI clicking ">", you just get a reply generated on the context above. But if you click "ctrl+right", your rated messages are shown to AI as examples. However, showing many negative ones may have the opposite effect as AI just starts copying them. This number defines how many random bad messages from your last turn should be given to AI as an example of how it shouldn\'t talk. Also, setting this high will result in a serious reduction of context window memory. 0 means disable.',def:3,f:'',q:false,qn:'b-ex',opt:false },
				goodExForSideReply:	{ g:'rating',name:'Use that many +ed side replies for new ones',v:3,d:'Same as above, but for messages with good rating. Unlike with bad messages it is ok to have a lot of these but remember it eats the context memory. Unless you have unlimited vram, don\'t set this high. 0 means disabled.',def:3, f:'',q:false,qn:'g-ex',opt:false },
				replyWithRating:		{	g:'rating',name:'Use rating to instruct model',v:true,d:"Should attempt to instruct model to use the existing rated messages as style examples for replies. Some models react well, some do not. If you didn't rate any answers in the current branch, nothing is changed in the prompt, so if you don't use the rating and do not wish to pollute the prompt, no need to switch it off.",def:true, f:'cb',q:false,qn:'rate',opt:true },
			},
			settingsGlobal: {
				options: {
					temperature:		{g:'ollama',v:'',t:'n',def:0.8,d:'The temperature of the model. Increasing the temperature will make the model answer more creatively. (Default: 0.8)',q:true,qn:'temp',opt:true},
					num_ctx:				{g:'ollama',v:'',t:'n',def:2048,d:'Sets the size of the context window used to generate the next token. (Default: 2048)',q:true,qn:'ctx',opt:true},
					top_k:					{g:'ollama',v:'',t:'n',def:40,d:'Reduces the probability of generating nonsense. A higher value (e.g. 100) will give more diverse answers, while a lower value (e.g. 10) will be more conservative. (Default: 40)',q:true,opt:true},
					top_p:					{g:'ollama',v:'',t:'n',def:0.9,d:'Works together with top-k. A higher value (e.g., 0.95) will lead to more diverse text, while a lower value (e.g., 0.5) will generate more focused and conservative text. (Default: 0.9)',q:true,opt:true},
					num_thread:			{g:'ollama',v:'',t:'n',def:'',d:'Sets the number of threads to use during computation. By default, Ollama will detect this for optimal performance. It is recommended to set this value to the number of physical CPU cores your system has (as opposed to the logical number of cores).',q:false,qn:'thr',opt:true},
					repeat_last_n:	{g:'ollama',v:'',t:'n',def:64,d:'Sets how far back for the model to look back to prevent repetition. (Default: 64, 0 = disabled, -1 = num_ctx)',q:true,qn:'rep_l',opt:true},
					repeat_penalty:	{g:'ollama',v:'',t:'n',def:1.1,d:'Sets how strongly to penalize repetitions. A higher value (e.g., 1.5) will penalize repetitions more strongly, while a lower value (e.g., 0.9) will be more lenient. (Default: 1.1)',q:true,qn:'rep_p',opt:true},
					mirostat:				{g:'ollama',v:'',t:'n',def:0,d:'Enable Mirostat sampling for controlling perplexity. (default: 0, 0 = disabled, 1 = Mirostat, 2 = Mirostat 2.0)',q:false,qn:'m-t',opt:true},
					mirostat_eta:		{g:'ollama',v:'',t:'n',def:0.1,d:'Influences how quickly the algorithm responds to feedback from the generated text. A lower learning rate will result in slower adjustments, while a higher learning rate will make the algorithm more responsive. (Default: 0.1)',q:false,qn:'m-eta',opt:true},
					mirostat_tau:		{g:'ollama',v:'',t:'n',def:5,d:'Controls the balance between coherence and diversity of the output. A lower value will result in more focused and coherent text. (Default: 5.0)',q:false,qn:'m-tau',opt:true},
					num_gqa:				{g:'ollama',v:'',t:'n',def:'',d:'The number of GQA groups in the transformer layer. Required for some models, for example it is 8 for llama2:70b',q:false,qn:'gqa',opt:true},
					num_gpu:				{g:'ollama',v:'',t:'n',def:'',d:'The number of layers to send to the GPU(s). On macOS it defaults to 1 to enable metal support, 0 to disable.',q:false,qn:'gpu',opt:true},
					stop:						{g:'ollama',v:[''],t:'as',def:'',d:'Sets the stop sequences to use. When this pattern is encountered the LLM will stop generating text and return. Multiple stop patterns may be set by specifying multiple separate stop parameters in a modelfile. Each input here means one stop match',f:'mis',q:null,opt:false},
					tfs_z:					{g:'ollama',v:'',t:'n',def:1,d:'Tail free sampling is used to reduce the impact of less probable tokens from the output. A higher value (e.g., 2.0) will reduce the impact more, while a value of 1.0 disables this setting. (default: 1)',q:false,opt:true},
					num_predict:		{g:'ollama',v:'',t:'n',def:128,d:'Maximum number of tokens to predict when generating text. (Default: 128, -1 = infinite generation, -2 = fill context)',qn:'prdct',q:false,opt:false},
					seed:						{g:'ollama',v:'',t:'n',def:0,d:'Sets the random number seed to use for generation. Setting this to a specific number will make the model generate the same text for the same prompt. (Default: 0)',qn:'seed',q:false,opt:true},
				},
				req: {
					model:					{g:'ollama',v:{l:computed(()=>this.models),v:''},t:'sel',def:0,d:'Model that will generate the reply',f:'sel',q:true,qn:'mdl',opt:false,sess:'v'},
					keep_alive:			{g:'ollama',v:900,t:'n',def:"300",d:'Time to keep model cached in memory, a number in seconds, any negative number will keep the model loaded in memory, 0 will unload the model immediately after generating a response.',q:false,qn:'k-alv',opt:false},
					modelEmb:				{g:'ollama',v:{l:computed(()=>this.modelsEmb),v:''},t:'sel',def:0,d:'Model that will generate the embeddings for rag search',f:'sel',q:false,qn:'mdl-emb',opt:false,sess:'v'},
				}
			},
			stream:	true,
			nick: {
				s:-1,
				n:{
					u:'',
					a:'',
					s:'',
				}
			},
			amountNicks: { u:0,a:0,t:0,s:1,idNext:0 },
			nicks: {
				'-1':	{	t:'s',n:computed(()=>this.config.sysNick.v),id:'-1'	},
			},
			msgUserListOn:{},
			opt:					{'v':{},model:0,run:false,cancel:false},
			rag:					{},
			turn:					0,
			cancel:				0,
			working:			0,
			workingRag:		0,
			connection: 	0,
			connectionErr:'',
			modelPull: 		'stablelm2',
			mpull: 				[],
			ctrl: 				0,
			log:					0,
			chatHeight:		'300',
			imgs:					[],
			inited:				false,
			memNew: {
				working:	0,
				cancel:		0,
				sys:[],
				parts: {},
				sys:[
					{
						sys:`Replies should be strictly in the format: "<memory>generated memory</memory>". Your goal is to create the requested amount of a random yet consistent memories of a given person from the input data. Be creative and deep in psychology. It should be consistent with the data provided. Each memory should include the person's name. Each memory should be phrased in a first person. Each memory should have a lot of synonyms. Each one of the created memories should strictly be in this format: "<memory>generated memory</memory>".`,
						req:[{
							req:'Input data:\n{PARAMS}',
							t:	'Initial request'
						},{
							req:'Ready to generate.',
							t:	`Model's "reply" before specific requests`,
						},{
							req:'Now generate {AMOUNT} memories about: """{TOPIC}""". Consistent with everything above. clearly state the age in each memory. Format should be: "<memory>generated memory</memory>',
							t:	'Topic specific requests'
						}]
					}
				],
			},
			charNew:			{
				step:			0,
				stepShow:	0,
				working:	0,
				cancel:		0,
				u:				null,
				sys:[
					{
						sys:`This is for a computer game plot, so it's okay. You reply in the following strict format only: "<parameter_name>parameter value</parameter_name>".\nYour task is to create a set of new random yet fully consistent parameters defining a new person, combining each and all of the following key personal qualities: {COREPARAMS}.\nParameters to create (you have to do all of the parameters):\n{PARAMS}`,
						req: [{
								req:`please create a new system prompt strictly in the required format. Use these presets: {PARAMS}`,
								t:	"initial request",
							},{
								req:`Please use the data above and generate the following parameters:\n{PARAMS}`,
								t:	"follow up request if something was missing",
							}
						]
					},{
//					sys:`Your goal is to take input data and creatively rewrite it in a free form as a system prompt for the character.\nThe character's personality can vary from evil-terrible to great-saint but should clearly match each and every one of the key qualities defined in the input data.\nTake special care to make sure all of the key qualities are reflected throughout the system prompt you make.\nAs the first line of generated system prompt it should clearly tell "You are: name", throughout the text use second person addressing only.\nSecond paragraph devote to key qualities of the person.\nWhole text should have only factual information from the data provided, nothing else.\nThe size of a resulting text should be around 10000 symbols.\nIn the end of system prompt make up a description of character's psychological conflict in character's psyche using the contradictions in input data.\nBe sure to use each and every detail from the input data precisely.\nPlease put the whole resulting system prompt into "<prompt></prompt>" tag.`,
						sys:`Your goal is to take input data and creatively rewrite it in a free form as a system prompt for the person.\nThe person's personality can vary from evil-terrible to great-saint but should clearly match each and every one of the key qualities defined in the input data.\nTake special care to make sure all of the key qualities are reflected throughout the system prompt you make.\nAs the first line of generated system prompt it should clearly tell "You are: name", throughout the text use second person addressing.\nSecond paragraph devote to key qualities of the person.\nWhole text should have only factual information from the data provided, nothing else.\nThe size of a resulting text should be around 10000 symbols.\nIn the end of system prompt make up a description of person's psychological conflict in person's psyche using the contradictions in input data.\nBe sure to use each and every detail from the input data precisely.\nPlease put the whole resulting system prompt into "<prompt></prompt>" tag.`,
						req:[{
							req:'Key qualities: {COREPARAMS}\nOther parameters:\n{PARAMS}',
							t:	'Initial request'
						}],
					},{
						sys:`Replies should be strictly in the format: "<memory>generated memory</memory>". Your goal is to create the requested amount of a random yet consistent memories of a given person from the input data. Be creative and deep in psychology. It should be consistent with the data provided. Each memory should include the person's name. Each memory should be phrased in a first person. Each memory should have a lot of synonyms. Each one of the created memories should strictly be in this format: "<memory>generated memory</memory>".`,
						req:[{
							req:'Input data:\n{PARAMS}',
							t:	'Initial request'
						},{
							req:'Ready to generate.',
							t:	`Model's "reply" before specific requests`,
						},{
							req:'Now generate {AMOUNT} memories about: """{TOPIC}""". Consistent with everything above. clearly state the age in each memory. Format should be: "<memory>generated memory</memory>',
							t:	'Topic specific requests'
						}]
					}
				],
				parts: {},
				paramsDef: {
					epoch:						{ph:'Future intergalactict empire'},
					location:					{ph:'Holy feline empire'},
					name:							{ph:''},
					race:							{ph:'Cat daemons'},
					ethnicity:				{ph:'Siamese'},
					gender:						{ph:''},
					age:							{ph:'888'},
					face:							{ph:''},
					look:							{ph:''},
					voice:						{ph:''},
					height:						{ph:''},
					weight:						{ph:''},
					hobby:						{ph:''},
					habits:						{ph:''},
					relationships:		{ph:''},
					character:				{ph:''},
					psychotype:				{ph:''},
					temperament:			{ph:''},
					dreams:						{ph:''},
					fears:						{ph:''},
					likes:						{ph:''},
					dislikes:					{ph:''},
					preferences:			{ph:''},
					'current attire':	{ph:''},
					'specific gestures':	{ph:''},
					belongings:						{ph:''},
					'other details':			{ph:''},
				},
				paramsCore: [
					{n:'postive',pnl:'toxic',pnr:'charming',min:0,max:11,v:0,p:'',b:'',vp:'',vh:''},
					{n:'constructive',pnl:'destructive',pnr:'constructive',min:0,max:11,v:0,p:'',b:'',vp:'',vh:''},
					{n:'honest',pnl:'lying/deceitful/lieful',pnr:'honest',min:0,max:11,v:0,p:'',b:'',vp:'',vh:''},
				]
			},
		}
	},
	computed: {
		config() {
			const u=this.userS('a');
			if(u==null) return this.configGlobal;
			if(this.nicks[u].sets) return this.nicks[u].config;
			return this.configGlobal;
		},
		settings() {
			const u=this.userS('a');
			if(u==null) return this.settingsGlobal;
			if(this.nicks[u].sets) return this.nicks[u].settings;
			return this.settingsGlobal;
		},
		branchac() {
	    return this.turns[this.turn].branches[this.branch(this.turn)];
	  },
	},
	created() {
		window.addEventListener('beforeunload',this.close);
	},
	mounted() {
		this.w('mounting');
		
		this.charNew.parts=this.charNewTmpl(this.charNew),
		this.memNew.parts	=this.memNewTmpl(this.memNew),
		
		this.groupAdd('Every1',[]);
		
		this.userAdd('u','User');
		this.userAdd('a','AI');
		this.userAdd('u','World');
		
		this.groupAdd('1st set',[0,1,2]);
		this.group=1;
		

		for(const k in this.settings.options) {
			if(!this.settings.options[k].hasOwnProperty('name')) this.settings.options[k]["name"]=k;
		}
		for(const k in this.settings.req) {
			if(!this.settings.req[k].hasOwnProperty('name')) this.settings.req[k]["name"]=k;
		}

		this.rag['g']=this.ragStrct();
		for(const u in this.nicks) {
			this.rag[u]=this.ragStrct();
		}
		
		this.bgSet(this.config.bgImg.v);
		this.bgFix(this.config.bgFixed.v);
		
		this.charCreateReset(this.charNew);
		
		let def={};
		for(const k in this.$data) {
			this.copy(this.$data,def,k);
		} this.def=def;
		
		this.sessLoad();
		this.urlTest();
		this.inited=1;

		window.addEventListener("keyup",(event)=>{
			this.ctrl=((event.ctrlKey||event.metaKey)?this.ctrl:0);
		});
		window.addEventListener("keydown",(event)=>{
			if(this.opt.run) return;
			
			this.ctrl=((event.ctrlKey||event.metaKey)?1:0);
			
			const k=event.keyCode;
			this.w(`keycode detected: ${k}`);

			if(this.config.fKeys.v&&k>=112&&k<122) { //>
				if(!event.shiftKey) {
					if			(k===112) { this.pToggle('howto') 	}
					else if (k===113) { this.save() 						}
					else if (k===114) { this.click('loadlabel')	}
					else if (k===115) { this.pToggle('sys') 		}
					else if (k===116) { this.pToggle('instr') 	}
					else if (k===117) { this.list() 						}
					else if (k===118) { this.pToggle('pull')		} 
					else if (k===119) { this.prune() 						} 
					else if (k===120) { this.pToggle('sets') 		} 
					else if (k===121) {
						this.quit()
					}
				} else {
					if			(k===120) { this.optToggle() 						}
					else if (k===115) { this.pToggle('ragG') 				}
					else if (k===116) { this.pToggle('ragU') 				}
					else if (k===118) { this.pToggle("charNew")			} 
				}
				event.preventDefault();
				return;
			}
			
			if(k==27&&this.working==1) {
				this.cancel=1;
				if(this.charNew.working==1) this.charNew.cancel=1;
				if(this.memNew.working==1) 	this.memNew.cancel=1;
				return;
			}

			if((document.activeElement.tagName=='TEXTAREA'&&document.activeElement.value.length)||this.turn===0) return;
			if(document.activeElement.tagName=='INPUT') {
				return;
			}

			if(document.activeElement.className.includes('msgText')) {
				if(event.key==='Enter'&&!event.shiftKey) {
					document.activeElement.blur();
				}
				return;
			}

			if(k==38) {
				this.turnUp();
				return;
			} else if(k==40) {
				this.turnDown(event.shiftKey?1:0);
				return;
			}

			if (k===39) {
				this.listmsgs(1,this.turn);
			} else if (k===37) {
				this.listmsgs(0,this.turn);
			}
		});
		
		this.w('mounted')
	},
	provide() {
		return {
			config: this.config,
			nicks: this.nicks,
			groups: this.groups,
			nick: this.nick,
			group: this.group,
			amountNicks: this.amountNicks,
		}
	},
	watch: {
		'config.themeWhite.v'(v) {
			if(v) {
				document.getElementById('html').style.filter='invert(100%) hue-rotate(180deg)';
			} else {
				document.getElementById('html').style.filter='invert(0%) hue-rotate(0deg)';
			}
		},
		'settings.req.model.v.v'(v) {
			this.w(`changed model ${v}, updating defs in settings`);
			if(!this.models.length) return;
			if(this.models[v].ctx) {
				this.settings.options.num_ctx.def=`${this.models[v].ctx} in modelfile for ${this.models[v].n}`;
			} else {
				this.settings.options.num_ctx.def='2048';
			}
		},
		'settings.options.stop.v': {
			handler(v) {
				if(!v) return;
				if(v[v.length-1].length!=0) v.push('')
				for(let i=0;i<(v.length-1);i++) { //>
					if(v[i]==='') v.splice(i,1);
				}
			},
			deep:true,
		},
		'ctrl'(v) {
			this.w(`ctrl: ${v}`);
		},
		'context': {
			handler (v) {
				//this.turnLastFilteredGo();
			},
			deep:true
		},
		'config.stories.v'(v) {
			this.config.storiesUI.v=v;
		},
		'config.storiesUI.v'(v) {
			if(v) this.config.stories.v=v;
		},
		'config.bgImg.v'(v) {
			this.bgSet(v);
		},
		'config.bgFixed.v'(v) {
			this.bgFix(v);
		},
		'config.urlEmb.v'(v) {
			this.w('updating rag status as emb url changed');
			this.embed('test');
		},
		'charNew.parts.mem.custom': {
			handler(v) {
				if(!v) return;
				if(v[v.length-1].v.length!=0) v.push({q:1,v:'',c:''});
				for(let i=0;i<(v.length-1);i++) { //>
					v[i].q=(v[i].q+'').trim(); if(!/^(?:\d{1,4}|)$/.test(v[i].q)) v[i].q=1;
					if(v[i].v==='') this.memSetsDel(this.charNew,i);
				}
				this.memCount(this.charNew.parts);
			},
			deep:true,
		},
		'charNew.parts.params': {
			handler(v) {
				if(!v) return;
				if(v.length==0||v[v.length-1].n.length!=0) v.push({n:'',nph:'new custom param',ph:'desired val or empty for random',v:'',c:'',memq:'',memt:''});
				const rgname	=new RegExp('^\s*name\s*$','i');

				for(let i=0;i<(v.length-1);i++) { //>
					if(v[i].n==='') v.splice(i,1);
					const p=v[i];
					p.memq=(p.memq+'').trim(); if(!/^(?:\d{1,4}|)$/.test(p.memq)) p.memq=1;
					if(p.memq!=''&&p.memq>0&&p.c.length) {
						p.memt=`${p.n}: ${p.c}`;
					} else {
						p.memt='';
					}
					if(rgname.test(p.n)) {
						//this.w(`found name param: ${p.c}`);
						this.charNew.parts.name=v[i];
					}
				}
				this.memCount(this.charNew.parts);
			},
			deep:true,
		},
		'memNew.parts.mem.custom': {
			handler(v) {
				if(!v) return;
				if(v[v.length-1].v.length!=0) v.push({q:1,v:'',c:''});
				for(let i=0;i<(v.length-1);i++) { //>
					if(v[i].v==='') this.memSetsDel(this.memNew,i);
					v[i].q=(v[i].q+'').trim(); if(!/^(?:\d{1,4}|)$/.test(v[i].q)) v[i].q=1;
				}
				this.memCount(this.memNew.parts);
			},
			deep:true,
		},
	},
	methods: {
		sessLoad() {
			let sess=localStorage.getItem('sess');
			this.w({load_session:sess});
			try {
				sess=JSON.parse(sess);
				this.w({loaded_session:sess});
				if(sess==null) return;
				for(const s in sess) {
					for(const p in sess[s]) {
						this.sessRestoreParam(sess,s,p);
					}
				}
			} catch(e) {
				this.w(`couldn't parse session ${e}`);
			}
		},
		sessRestoreParam(sess,s,p) {
			let l={
				cfg:	this.configGlobal,
				opt:	this.settingsGlobal.options,
				req:	this.settingsGlobal.req,
				root:	this.$data
			};
			this.w(`sess restore ${s} ${p}: ${sess[s][p]}`);
			if(s==='root') {
				l[s][p]=sess[s][p];
			} else if(!l[s][p].sess) {
				return;
			} else if(l[s][p].sess==='v') {
				l[s][p].v.v=sess[s][p];
			} else {
				l[s][p].v=sess[s][p];
			}
			this.w({sess_restored:l[s]});
			//if(typeof o[p].v==="object") { o[p].v.v=sess } else { o[p].v=sess }
		},
		sessStoreParam(sess,o,p) {
			if(!o[p].sess) return;
			//const v=o[p].v;
			//sess[p]=(typeof v==="object")?v.v:v;
			if(o[p].sess==='v') {
				sess[p]=o[p].v.v;
			} else {
				sess[p]=o[p].v;
			}
		},
		sessSave() {
			if(!this.inited) return;
			let sess={VER:0.1};
			let store=[
				{ l:this.configGlobal,p:'cfg' },
				{ l:this.settingsGlobal.options,p:'opt' },
				{ l:this.settingsGlobal.req,p:'req' }
			];
			for(const s of store) {
				sess[s.p]={};
				for(const p in s.l) {
					this.sessStoreParam(sess[s.p],s.l,p);
				}
			}

			sess['root']={};
			for(let s of ['models','modelsEmb']) {
				(sess.root[s]=this[s]);
			}
			
			this.w({sessStore:sess});

			localStorage.setItem('sess',JSON.stringify(sess));
		},
		close() {
			this.sessSave();
		},
		delAtWork(o) {
			if(o.working) {
				alert("Can't delete while working");
				return 0;
			}
			return 1;
		},
		charNewSystemReset(o,id) {
			if(!this.delAtWork(o)) return;
			o.parts.system[id].sys=o.sys[id].sys;
		},
		charNewReqReset(o,id,rid) {
			if(!this.delAtWork(o)) return;
			o.parts.system[id].req[rid].req=o.sys[id].req[rid].req;
		},
		memSetsDel(o,id) {
			if(!this.delAtWork(o)) return;
			o.parts.mem.custom.splice(id,1);
		},
		memParsedDel(o,id) {
			if(!this.delAtWork(o)) return;
			o.parts.m.splice(id,1);
		},
		memGenParsedReset(o,f) {
			if(!f&&!this.delAtWork(o)) return;
			o.parts.m		=[];
			o.parts.tmp	=this.msgTmpl('-1',null,0);
		},
		charNewParamsDel(p) {
			if(!this.delAtWork(this.charNew)) return;
			if(this.charNew.parts.params[p].n=='name'&&!confirm(`Are you sure you wish to delete "name" parameter? Its value is used as the name in system prompt, in memories and at adding generated character to the system. If you delete it, system prompt will get something strange as name and the rest will use an empty value.`)) return;
			this.charNew.parts.params.splice(p,1);
		},
		async charCreateAuto() {
			if(this.working||this.charNew.working) return;
			this.charNew.parts.auto.working=this.charNew.working=this.working=1;
			this.charNew.parts.auto.amount=(this.charNew.parts.auto.amount+'').trim();
			if(!/^\d{1,4}$/.test(this.charNew.parts.auto.amount)) this.charNew.parts.auto.amount=1;
			this.w(`starting doing: ${this.charNew.parts.auto.amount} characters`);
			for(let i=1;i<=this.charNew.parts.auto.amount;i++) { //>
				this.charNew.parts.auto.at=i;
				if(this.charNew.cancel) break;
				this.w(`doing char: ${i}`);
				this.charNew.stepShow=this.charNew.step=0;
				for(let k=0;k<=3;k++) { //>
					if(this.charNew.cancel) break;
					this.w(`doing char ${i}, step: ${k}`);
 					await this.charCreateDo(k);
					this.scroll('charNew',1);
					this.charNew.stepShow=this.charNew.step;
				}
			}
			this.charNew.parts.auto.at=0;
			//this.pToggle('charNew');
			this.charNew.parts.auto.working=this.charNew.working=this.working=this.cancel=this.charNew.cancel=0;
		},
		async charCreate(m) {
			if(this.working||this.charNew.working) return;
			this.charNew.working=this.working=1;
			
			await this.charCreateDo(m);
			
			//this.charNew.stepShow=this.charNew.step;
			this.charNew.working=this.working=this.cancel=this.charNew.cancel=0;
		},
		async charCreateDo(m) {
			let ms=[],req='';
			let rgparams	=new RegExp('\{PARAMS\}','si');
			let rgcparams	=new RegExp('\{COREPARAMS\}','si');
			
			this.charNew.stepShow=this.charNew.step=m+1;
			
			if(m==0) {
				this.w("first step of character creation");
				for(const p of this.charNew.parts.params) {
					p.c='';p.memt='';
				}
				for(const p of this.charNew.parts.paramsCore) {
					this.charNewCoreParamCh(p);
				}
				
				let ps='',xmpl='',sys,paramsCount=0;
				
				let rgcv=this.charNewCoreParams2p();
				for(const r of rgcv) {
					ps+=`<${r.p}>${r.vh} ${r.p}</${r.p}>`;
				}
				
				for(let i of this.charNew.parts.params) {
					if(i.n===''||i.n==null) continue;
					this.w(`checking param ${i.n}`);
					paramsCount++;
					xmpl+=`<${i.n}>${i.n} value</${i.n}>\n`;
					if(i.v==='') continue;
					ps+=`<${i.n}>${i.v}</${i.n}>\n`;
				}
				
				if(!paramsCount) {
					alert('You have to define at least 1 parameter to generate');
					this.charNew.step=0;
				} else {
					this.w(`presets: ${ps}`);
					sys=this.charNew.parts.system[0].sys.replace(rgparams,xmpl).replace(rgcparams,rgcv.map(c=>`"${c.vh}"`).join(", "));
					req=this.charNew.parts.system[0].req[0].req.replace(rgparams,ps);

					this.charNew.parts.tmp=this.msgTmpl('-1',null,0);
					this.chatAiMsPush(ms,sys,'system');
					this.chatAiMsPush(ms,req,'user',[]);
					let i=0;
					while(i++<=10)  { //>
						if(this.charNew.cancel==1) break;
						await this.chatSend(this.charNew.parts.tmp,ms,this.charNewParse,null);

						let parsedCount=0,parseds='',ready={};req='';
						for(const p of this.charNew.parts.params) {
							if(p.n==null||p.n==='') continue;
							this.w(`checking param ${p.n}..`);
							if(p.c!=null&&p.c.length>0) {
								parsedCount++;
								this.w(`..found`);
								if(!ready[p.n]) parseds+=`<${p.n}>${p.c}</${p.n}>\n`;
								ready[p.n]=1;
							} else {
								this.w(`..absent`);
								req+=`<${p.n}>generated value</${p.n}>\n`;
							}
						}
						if(!Object.keys(ready).length) continue;
						this.chatAiMsPush(ms,parseds,'assistant',[]);
						if(parsedCount==paramsCount) break;
						req=this.charNew.parts.system[0].req[1].req.replace(rgparams,req);
						this.chatAiMsPush(ms,req,'user',[]);
					}
					
					this.charNew.step=2;
				}
			} else if(m==1) {
				let paramsCount=0,kq='',ps='';

				let rgcv=this.charNewCoreParams2p();
				this.w({ranges:rgcv});
				kq=rgcv.map(c=>`"${c.vh}"`).join(", ");
				
				for(const p of this.charNew.parts.params) {
					if(p.n==null||p.n===''||p.c==='') continue;
					ps+=` ${p.n}: ${p.c}\n`;
					paramsCount++;
				}
				this.w(`found ${paramsCount} parameters`);
				
				if(!paramsCount) {
					alert('You have to define at least 1 parameter to generate');
					this.charNew.step=0;
				} else {
					this.charNew.parts.sysKq='';
					this.charNew.parts.sys='';
					this.charNew.parts.tmp=this.msgTmpl('-1',null,0);
					this.chatAiMsPush(ms,this.charNew.parts.system[1].sys,'system');
					this.chatAiMsPush(ms,this.charNew.parts.system[1].req[0].req.replace(rgcparams,kq).replace(rgparams,ps),'user',[]);
				
					let i=0;
					const rgsys=new RegExp(`<prompt>([^<]+?)</prompt>`,'si');
					while(i++<10) { //>
						if(this.charNew.cancel==1) break;
						await this.chatSend(this.charNew.parts.tmp,ms,null,null);
						this.w(`got system prompt reply: ${this.charNew.parts.tmp.content}`);
						const tmp=rgsys.exec(this.charNew.parts.tmp.content);
						if(!tmp||!tmp[1]||tmp[1].trim().length<1000) continue; //>
						this.charNew.parts.sys=tmp[1].trim();
						this.w(`got parsed system prompt: ${this.charNew.parts.sys}`);
						break;
					}

					i=1; this.charNew.parts.sysKq=`Your key qualities:\n${rgcv.map(c=>` ${i++}. ${c.vh}`).join("\n")}\n\n`;
					
					if(this.charNew.parts.sys.length) {
						//this.charNew.parts.sys=`Your key qualities:\n${rgcv.map(c=>` ${i++}. ${c.vh}`).join("\n")}\n\n${this.charNew.parts.sys}\n\n`;
						this.charNew.parts.sys=`${this.charNew.parts.sys}\n\n`;
						this.charNew.parts.sys+=`Specific details of ${this.charNew.parts.name.c}:\n`+this.charNew.parts.params.filter(p=>p.n!=null&&p.n!='').map(p=>` ${p.n}: ${p.c}`).join('\n');
						this.charNew.step=3;
					}
				}
			} else if(m==2) {
				this.charNew.parts.tmp=this.msgTmpl('-1',null,0);
				
				await this.memGen(this.charNew,this.charNew.parts.system[2],this.charNew.parts.sys);
				
				this.w({memories:this.charNew.parts.m});
				
				this.charNew.step=4;
			} else if(m==3) {
				const id=this.userAdd('a',(this.charNew.parts.name.c??''));
				this.charNew.parts.u=id;
				this.charNew.parts.copy.userAdd=id;
				
				this.nicks[id].system=this.charNew.parts.sysKq+this.charNew.parts.sys;
				this.charNew.parts.copy.sysPrompt=1;
				
				this.userGroupAdd(this.group,id);
				this.charNew.parts.copy.add2group=1;
				
				this.groups[this.group].sel.a=id;
				this.charNew.parts.copy.select=1;

				await this.memGen2rag(this.charNew,id);
				this.charNew.parts.copy.embedding=1;

				this.charNew.step=5;
				this.charNew.stepShow=5;
			}
			
			if(this.charNew.step<3) { //>
				this.charNew.parts.sysKq='';
				this.charNew.parts.sys='';
			}
			if(this.charNew.step<4) { //>
				this.charNew.parts.m2do=[];
				this.charNew.parts.m=[];
			}
			if(this.charNew.step<5) { //>
				this.charNew.parts.u=null;
				this.charNew.parts.copy={};
			}
			
			this.charNew.parts.tmp='';
		},
		charNewCoreParamCh(r) {
			this.charNewCoreParamsCalc(r);
		},
		charNewCoreParamsCalc(r) {
			let p2w={
				100:'ultimately, totally',
				80:'most of the time',
				60:'very much, casually',
				40:'occasionaly',
				20:'rarely, a bit',
			},l={};r.c=r.v;
			if(r.c==0) {
				r.c=this.rand(1,11);
				this.w(`setting ${r.n} to random val: ${r.c}`);
			}
			if(r.c>6) {
				r.b	=1;
				r.p	=r.pnr;
				r.vp=(r.c-6)*20;
				r.vh=`${p2w[r.vp]} ${r.p} person`;;
			} else if (r.c<6) { //>
				r.b	=-1;
				r.p	=r.pnl;
				r.vp=(6-r.c)*20;
				r.vh=`${p2w[r.vp]} ${r.p} person`;
			} else {
				r.b	=0;
				r.p	=`${r.pnl}-${r.pnr}`;
				r.vp=0;
				r.vh=`not ${r.pnl} nor ${r.pnr} person`;
			}
			this.w({coreparamcalc:r});
			return r;
		},
		charNewCoreParams2p() {
			let rgcv=[...this.charNew.parts.paramsCore];
			rgcv.sort((a,b)=>(a.b>b.b?1:-1));
			this.w({rgcv:rgcv});
			return rgcv;
		},
		charCreateReset(o,m) {
			this.w('create reset');
			if(!this.delAtWork(o)) return;
			
			if(m&&!confirm("Are you sure you wish to delete all data in the current generation?")) return;
			this.w({'resetting charNew':o});
			o.step			=0;
			o.stepShow	=0;
			o.parts			=this.charNewTmpl(o);
			for(const k in o.paramsDef) {
				//this.w(`copy params ${k}`);
				o.parts.params.push({
					n:	k,
					ph:	o.paramsDef[k].ph,
					h:	o.paramsDef[k].h,
					v:	'',
					c:	'',
					memq: '',
					memt: ''
				});
			}
			for(const k in o.paramsCore) {
				//this.w(`copy core params ${k}`);
				this.copy(o.paramsCore,o.parts.paramsCore,k);
			}
		},
		charNewTmpl(o) {
			const mt=[
				{q:5,t:'good childhood memories'},
				{q:5,t:'bad childhood memories'},
				{q:5,t:'memories of last years'}
			];
			let t={
				auto: {
					amount: 1,
					working: 0,
					at: 0,
					total: 0,
				},
				u:			null,
				name:		'',
				copy:		{},
				sys:		'',
				sysKq:	'',
				params: [],
				paramsCore: [],
				system: [],
				req: [],
				...this.memTmpl(mt)
			};
			t.memCount.push({l:'params',t:'Parameter generated memories',tref:'params',q:0,qp:'memq',qv:'memt'});
			for(const s in o.sys) {
				this.copy(o.sys,t.system,s);
			}
			this.memCount(t);
			return t;
		},
		async memGen2rag(o,u) {
			if(!o.parts.m.length) return;
			if(this.rag[u].t.length) this.rag[u].t+='\n\n';
			this.rag[u].t+=`A memory of ${this.nicks[u].n}: `+o.parts.m.join(`\n\nA memory of ${this.nicks[u].n}: `);
			await this.ragU(u);
		},
		async memGen4rag(u) {
			let o=this.memNew;
			if(o.working) return;
			if(o.parts.memCountT.total==0) {
				alert("You have to add at least one topic for memory generation");
				return;
			}
			this.working=o.working=1;
			let data=this.nicks[u].system;
			if(this.memNew.parts.wMemories&&this.rag[u].t!=null&&this.rag[u].t.length) {
				data=`Description of ${this.nicks[u].n}: """${data}"""\n\nIt also should be consistent with these existing memories of ${this.nicks[u].n}: """${this.rag[u].t}"""`;
			}
			this.w({data:data});
			await this.memGen(o,o.parts.system[0],data);
			
			this.cancel=o.cancel=this.working=o.working=0;
		},
		async memGen(o,sys,udata) {
			let ms=[];
			let rgparams	=new RegExp('\{PARAMS\}','si');
			const rgtopic	=new RegExp(`\{TOPIC\}`,'gsi');
			o.parts.m2do	=[];
			this.memGenParsedReset(o,1);
				
			this.chatAiMsPush(ms,sys.sys,'system');
			this.chatAiMsPush(ms,sys.req[0].req.replace(rgparams,udata),'user',[]);
			this.chatAiMsPush(ms,sys.req[1].req,'assistant',[]);
			this.w({ms:ms});
			
			for(const m of o.parts.memCount) {
				for(const mc of this.memLnkDeref(o.parts,m.l)) {
					if(mc[m.qv]==null||mc[m.qv]==''||mc[m.qp]==null||mc[m.qp]=='') continue;
					o.parts.m2do.push(this.charNewMemTopicTmpl(mc[m.qp],mc[m.qv]));
				}
			}
			this.w({memories2do:o.parts.m2do});
			for(const mc of o.parts.m2do) {
				if(o.cancel==1) break;
				if(mc.v==''||mc.v==null) continue;
				if(!/^\d{1,4}$/.test(mc.q)) mc.q=3;
				await this.memGenDo(ms,o.parts.tmp,mc.q,3,sys.req[2].req.replace(rgtopic,mc.v),o);
			}
			this.w({memories:this.charNew.parts.m});
		},
		async memGenDo(ms,m,q,by,req,obj) {
			let i=0,remains=0,startpos=obj.parts.m.length,done=0,lastpos=obj.parts.m.length;
			const rgAm=new RegExp('\{AMOUNT\}','si');
			while(i++<10) { //>
				if(obj.cancel==1) break;
				
				done		=obj.parts.m.length-startpos;
				remains	=q-done;
				this.w(`starting cycle: required: ${q}, done: ${done}, remains: ${remains}, lastpos: ${lastpos}`); //>
				if(remains<=0) break; //>
				
				this.chatAiMsPush(ms,req.replace(rgAm,remains>by?by:remains),'user',[]);
				await this.chatSend(m,ms,this.memParse,obj);

				if(lastpos!=obj.parts.m.length) {
					const tmp=obj.parts.m.slice(lastpos).map(mem=>`<memory>${mem}</memory>`).join('\n');
					this.chatAiMsPush(ms,tmp,'assistant',[]);
					lastpos=obj.parts.m.length;
				} else {
					ms.pop();
				}
			}
		},
		memNewTmpl(o) {
			let m={
				u: null,
				system:	[],
				...this.memTmpl([])
			}
			for(const s in o.sys) {
				this.copy(o.sys,m.system,s);
			}
			this.memCount(m);
			this.w({'adding new mem tmpl':m})
			return m;
		},
		memTmpl(topics) {
			//don't use this. for data here
			let m={
				m:			[],
				k:			[],
				mem:		{
					custom:	[],
				},
				memCount: [],
				memCountT: {total:0},
				mem2do: [],
				wMemories: false,
			};
			for(const ml in m.mem){
				m.memCount.push({l:'mem.custom',t:'Custom topic memories',tref:'mems',q:0,qp:'q',qv:'v'});
			}
			for(const t of topics) {
				m.mem.custom.push(this.charNewMemTopicTmpl(t.q,t.t));
			}
			m.mem.custom.push(this.charNewMemTopicTmpl(1,''));
			return m;
		},
		charNewMemTopicTmpl(q,v) {
			return {q:q,v:v,c:''};
		},
		memLnkDeref(o,l) {
			let ml=o;
			//this.w({deref:o,l:l});
			for(const i of l.split('.')) {
				if(!/^[a-zA-Z0-9]{1,32}$/.test(i)) continue;
				ml=ml[i];
			}
			return ml;
		},
		memCount(o) {
			let used={total:0};
			for(let m of o.memCount) {
				used[m.tref]=0;
				for(const mi of this.memLnkDeref(o,m.l)) {
					//this.w({'check val of mem':mi,qv:m.qv,qp:m.qp});
					if(mi[m.qv]==null||mi[m.qv]==''||mi[m.qp]==null||mi[m.qp]=='') continue;
					//this.w({'recalculating mem':mi[m.qp]});
					used[m.tref]+=mi[m.qp]*1;
				}
				m.q=used[m.tref];
				used.total+=used[m.tref];
				//this.w({'memories':m,name:m.t});
			}
			o.memCountT=used;
			//this.w({'memories':o.memCount,total:o.memCountT});
		},
		memParse(c,o) {
			let rgmem=new RegExp(`<memory>(.+?)</memory>`,'gsi');
			let tmp;
			while(tmp=rgmem.exec(c)) {
				//this.w({parsing:tmp});
				if(tmp==null||!tmp[1].trim().length) continue;
				tmp[1]=tmp[1].trim();
				if(tmp[1]=='generated memory') continue;
				let exists=0;
				for(const m of o.parts.m) {
					if(m===tmp[1]) {
						exists=1;
						break;
					}
				}
				if(!exists) {
					o.parts.m.push(tmp[1]);
					this.w(`found: ${tmp[1]}`);
				}
			}
		},
		charNewParse(c) {
			let rg={};
			for(let p of this.charNew.parts.params) {
				//this.w(`extracting: ${p.n}`);
				rg[p]=new RegExp(`<${p.n}>([^<]+?)</${p.n}>`,'si');
				const res=rg[p].exec(c);
				if(res&&res.length>0) {
					if(p.c.length) continue;
					p.c=res[1].trim();
					//this.w(`found ${p.n}: ${p.c}`);
				}
			}
			//this.w({parts:this.charNew.parts.params});
		},
		quit() {
			if(confirm("Are you sure you wish to quit the game?")) {
				window.close();
				alert("You wish.");
			}
		},
		groupCh(id) {
			this.w(`changing group to ${id} ${this.groups[id]}`);
			this.group=id*1;
			//this.turnLastFilteredGo();
		},
		w(a) {
			if(!this.log) return;
			if(typeof a==='object') {
				console.log(JSON.stringify(a,null,2));
			} else {
				console.log(a);
			}
		},
		click(id) {
			const c=new MouseEvent('click',{view:window,bubbles:true,cancelable:true});
			document.getElementById(id).dispatchEvent(c);
		},
		tokensTotal(turn,model) {
			if(!this.config.tokensCount.v) return;
			
			return this.tokens(turn,model,'tp')+this.tokens(turn,model,'tr');
		},
		tokens(turn,model,id) {
			//this.w(`connection=${this.connection} this.model=${JSON.stringify(this.settings.req.model.v.v)} models=${JSON.stringify(this.models,null,2)}`)
			if(model==undefined) model=this.models[this.settings.req.model.v.v].n;
			return this.msga(turn)[id][model];
		},
		pToggleDo(id,v) {
			if(v==undefined) v=!this.pState[id];
			this.w(`toggling ${id} to ${v}`);
			this.pState[id]=v;
		},
		async pToggle(id,v) {
			this.pToggleDo(id,v);
			await nextTick();
			let to=0;
			if(id=='howto'||id=='sets') to=1;
			if(id=='sys'||id=='instr') id='sysinstr';
			this.scroll(id,1);
		},
		optToggle() {
			if(this.pState['opt']) {
				this.pToggle('opt');
				return;
			}
			this.opt.count={t:0,d:0};
			this.opt.res={};
			for(const m in this.settings.req.model.v.l) {
				this.w(`creating tune params for model ${m}`);
				if(!this.opt['v'].hasOwnProperty('m')) this.opt[m]={v:{},k:'',times:1};
				for(const j of [this.config,this.settings.options,this.settings.req]) {
					for(const key in j) {
						this.w(`filling in opt ${key}`);
						const i=j[key];
						if(!i.opt) continue;
						if(this.opt[m]['v'].hasOwnProperty(key)) continue;
						this.opt[m]['v'][key]={start:'',end:'',step:'',v:'',use:false,rnd:''};
					}
				}
				//this.opt.res[m]={v:[],k:[],count:0};
			}
			this.pToggle('opt');
		},
		msgFilter(turn,b,m) {
			const t=this.turns[turn];
			const msg=t.branches[b].msgs[m];
			if(!this.config.stories.v) {
				return 0;
			} else if(!this.context[0]&&!this.context[1]&&!this.context[2]) {
				return 1;
			} else if(!this.context[0]) {
				const u=this.userS("u"),a=this.userS("a");
				if(this.context[3]&&this.context[1]&&this.context[2]) {
					if(!msg.nicks[u]&&!msg.nicks[a]) return 1;
					if(!(msg.nicks[a]&&this.context[1])||!(msg.nicks[u]&&this.context[2])) return 1;
				} else {
					if(!msg.nicks[u]&&!msg.nicks[a]) return 1;
					if(!(msg.nicks[a]&&this.context[1])&&!(msg.nicks[u]&&this.context[2])) return 1;
				}
			}
		},
		msgSkipped(turn,b,m) {
			if(this.hideMsg(turn,b,m)) 		return 1;
			if(this.msgFilter(turn,b,m)) 	return 1;
			return 0;
		},
		hideMsg(turn,b,m) {
			const t=this.turns[turn];
			const msg=t.branches[b].msgs[m];
			
			if(t.role!=="user") return 0;
			if(!this.config.hideEmptyOwn.v) return 0;
			if(this.config.showEmptyOwnSide.v&&this.msgTotal(turn,b)>1) return 0; //force showing.
			if(this.msgSide(turn,b,m)) return 0;
			if(!this.msgEmpty(turn,b,m)) return 0;
			return 1;
		},
		listmsgs(m,turn) {
			this.w(`listing ${m} - turn ${turn}, m: ${m}, ctrl: ${this.ctrl} role: ${this.turns[turn].role}`);
			if(this.opt.run) return 0;
			if(this.userS('u')==null||this.userS('a')==null) return 0;
			if(m==1&&this.ctrl&&this.turns[turn].role==='assistant') m=2;
			if(m==2&&this.turns[turn].role==='user') m=1; //for right mouse click
			
			if			(m==0) {	this.msgMvLeft(turn)						}
			else if (m==1) {	this.msgMvRight(turn,0,true)		}
			else if (m==2) {	this.msgMvRight(turn,1,true)		}
		},
		optChUse(m,k) {
			const p=['start','end','step'];
			let found=0;
			const o=this.opt[m].v[k];
			for(let P of p) {
				if(o[P].length) found++;
			}
			o.use=(found==p.length?true:false);
		},
		optimizeCancel() {
			if(this.working) this.cancel=true;
			this.opt.cancel=true;
		},
		async optimizeRun() {
			if(this.turn<2) { //>
				alert('You need to have a chat log, before you may start this. It creates side-replies, so it needs to have some content for AI to create alternative versions of replies to it.');
				return;
			}
			if(this.turnRole(this.turn)==='user') {
				alert('You need to stop at the AI reply in your chat log, right now last message in the chat log belongs to you.');
				return;
			}
			const b=this.branchac; if(b.msg!=b.msgs.length-1) b.msg=b.msgs.length-1;
			this.opt.run=true;
			let menus=[0,0];
			if(this.pState['control']){ this.pToggleDo('control'); 	menu[2]=1 };
			if(this.pState['menu']) 	{ this.pToggleDo('menu'); 		menu[0]=1 };
			if(this.config.setsQ.v) 	{ this.config.setsQ.v=false;	menu[1]=1 };

			let opts={bak:{},v:{}};
			let ht={config:this.config,options:this.settings.options,req:this.settings.req}
			for(let m in this.settings.req.model.v.l) {
				this.w(`collecting combinations for model ${m} ${this.settings.req.model.v.l[m].tag}`)
				opts.v[m]=[];
				//let found=0;
				for(const i in ht) {
					for(const key in ht[i]) {
						if(!ht[i][key].opt) continue;
						if(!this.opt[m].v[key].use) continue;
						if(ht[i][key].f=='cb') {
							this.opt[m].v[key].start	=0;
							this.opt[m].v[key].end		=1;
							this.opt[m].v[key].step		=1;
							this.opt[m].v[key].rnd		='';
						} else {
							if(!/^\d{1,14}$/.test(this.opt[m].times)) {
								this.opt.run=false;
								alert(`Amount of replies per combination should be a sane value.`);
								scroll('optTimes');
								return;
							}
							if(!/^\d{0,16}$/.test(this.opt[m].v[key].rnd)) {
								this.opt.run=false;
								alert(`Field's ${ht[i][key].name} "Round up to N decimals" value ${this.opt[m].v[key].rnd} for model ${this.settings.req.model.v.l[m].n} is not a positive integer, please correct it.`);
								return;
							}
							for(const p of ['start','end','step']) {
								const val=this.opt[m].v[key][p];
								this.w(`checking params of ${key} ${p}=${val}`);
								if(!/^\d+(\.\d+)?$/.test(val)) {
									this.opt.run=false;
									alert(`Field's ${ht[i][key].name} ${p} value ${val} for model ${this.settings.req.model.v.l[m].n} is not numeric, please correct it.`);
									return;
								}
							}
						}
						opts['v'][m].push({
							key:key,
							lnk:ht[i][key],
							times:this.opt[m].times,
							...this.opt[m].v[key]
						});
						if(!opts.bak.hasOwnProperty(i)) opts.bak[i]={};
						if(!opts.bak[i].hasOwnProperty(key)) opts.bak[i][key]={lnk:ht[i][key],v:ht[i][key]['v']};
						this.w(`stored bak value: ${opts.bak[i][key]} for ${i} ${key}`);
					}
				}
				if(!opts.v[m].length) delete opts.v[m];
			}
			const t=this;
			let res=[];
			let ci=opts.length;
			async function optDo(p,i,opt,res,vals,idle) {
				t.w({index:i,p:p});
				const P=p[i];
				t.w({from:P.start,to:P.end,step:P.step});
				let v;
				for(let V=P.start*1;V<=P.end*1;V+=P.step*1) { //>
					if(P.rnd!=='') {
						v=t.rnd(V,P.rnd);
					} else {
						v=V;
					}
					t.w(`going with value ${p[i].key} ${v}`);
					P.lnk.v=v;
					vals[i]=v;
					if((p.length-1)>i) {  //>
						t.w(`this is (${i}) not the last level, going deeper`);
						await optDo(p,i*1+1,opt,res,vals,idle);
						continue;
					}
					if(t.opt.cancel) {
						t.w('cancelling opt');
						return;
					}
					opt.vals=vals;
					
					for(let tms=1;tms<=P.times;tms++) { //>
						opt.count.d++;
						if(idle) continue;

						t.w(`trying new iteration`);
						const coord=await t.msgMvRight(t.turn,0,true);
						const c=t.turns[coord[0]].branches[coord[1]].msgs[coord[2]].content;
						let found=0;
						for(let j=0;j<res.length;j++) { //>
							if(res[j]['c']!==c) continue;
							res[j].ids.push(coord[2]);
							res[j].v.push([...vals]);
							found=1;
						}
						if(!found) res.push({c:c,ids:[coord[2]],v:[[...vals]]});
					}
				}
			}
			this.w({valuesToTry:opts});

			this.opt.res={};
			for(const m in opts.v) {
				this.opt.res[m]={v:[],k:[],count:0};
				for(const i of opts.v[m]) { this.opt.res[m].k.push(i.lnk) }
			}
			
			function optsRestore(opts) {
				for(const i in opts.bak) {
					for(const k in opts.bak[i]) {
						t.w(`restoring in ${i} bak value of ${k} to ${opts.bak[i][k].v}`);
						opts.bak[i][k].lnk.v=opts.bak[i][k].v;
					}
				}
			}
			
			this.opt.vals	=[];
			this.opt.count={t:0,d:0};
			const modelbak=this.settings.req.model.v.v;
			
			for(const m in opts.v) {
				await optDo(opts.v[m],0,this.opt,this.opt.res[m].v,[],true);
			} this.opt.count.t+=this.opt.count.d; this.opt.count.d=0;
			
			for(const m in opts.v) {
				this.settings.req.model.v.v=this.opt.m=m;
				optsRestore(opts);
				await optDo(opts.v[m],0,this.opt,this.opt.res[m].v,[],false);
			} optsRestore(opts);
			
			this.w({opt:this.opt});
			this.settings.req.model.v.v=modelbak;
			this.opt.cancel	=false;
			this.opt.run		=false;

			if(menu[0]) this.pToggleDo('menu');
			if(menu[1]) this.config.setsQ.v=true;
			if(menu[2]) this.pToggleDo('control');
			await nextTick();
			this.scroll('optRes',true);
		},
		rnd(n,d) {
		  return Number(Math.round(n+'e'+d)+'e-'+d);
		},
		rand(min,max) {
			return Math.floor(Math.random()*(max-min+1))+min;
		},
		
		//db methods
		prune() {
			if(
				confirm("Are you sure you wish to permanently erase everything but the currently selected branch of messages? Again, this will erase all the alternative chat records. Proceed?")
				&&
				confirm("Are you really sure?")
			) {
				for(const i in this.turns) {
					if(i==0) continue;
					this.w({'pruning':i,'turn':this.turns[i]});
					if(this.turns[i].branch===-1) {
						this.w(`erasing turns up to ${i}`);
						this.turns=this.turns.slice(0,i);
						break;
					}
					let tmp=this.brancha(i);
					this.turnBranchSet(i,0);
					this.turns[i].branches=[];
					this.turns[i].branches.push(tmp);
					tmp=this.msga(i);
					this.turns[i].branches[0].msg	=0;
					this.turns[i].branches[0].msgs=[];
					this.turns[i].branches[0].msgs=[tmp];
					this.treeu(i);
					this.w(this.turns[i].branches);
				}
			}
		},
		load() {
			this.w('drop all changes since load');
			if(!confirm('Please do not trust files of other people, as they can inject something. The most obvious and easiest thing is to set your ollama url to something they control, so they can see your chat then. Another potential attack vector is some specially crafted prompt to exploit ollama, that can be in some of the fields sent to Ollama. In other words, load only your own chats. Load this file?')) return;
			this.connection=0; //to prevent partial updates to dom
			for(const i in this.def) {
				this.w(`restoring ${i}`)
				if(i=='def') continue;
				this.copy(this.def,this.$data,i)
			}
			
			const l=document.getElementById('load');
			let fr=new FileReader();
			let t	=this;
			let d;
			//as i do not copy structures per version, this upgrade is whacky :)
			//it may break if in future some structures get changed without updating this.
			//but so far it works and i don't want to make file bigger just with 
			//copying all these default tables per version.
			//if needed, then it has to be changed.
			function parse(d) {
				if(!d) {
					t.w('parsing loaded file');
					d=JSON.parse(fr.result);
					delete d.def;
					d.connection=0; //to prevent partial updates to dom
				} else {
					t.w(`recursive updating`);
				}
				t.w(d)
				
				//patch for 1.8 shift.
				if(t.$data.hasOwnProperty('configGlobal')) {
					t.config=t.configGlobal;
					t.settings=t.settingsGlobal;
					if(t.settingsGlobal.req.hasOwnProperty('model')) {
						t.model=t.settingsGlobal.req.model.v.v;
					}
					
				}
				let ver;
				if(d.hasOwnProperty('configGlobal')) {
					ver=d.configGlobal.version.v;
				} else if(d.hasOwnProperty('config')) {
					ver=d.config.version.v;
					t.def.config=computed(()=>t.def.configGlobal);
					t.def.settings=computed(()=>t.def.settingsGlobal);
				} else {
					ver=0;
					t.def.config=computed(()=>t.def.configGlobal);
					t.def.settings=computed(()=>t.def.settingsGlobal);
				}
				t.w(`new parser pass for ver: ${ver}`);
				
				if(ver==0) { //updating from version 0->1
					t.w('upgrading from version 0');
					
					t.copy(t.def,d,'configGlobal'); d.config=d.configGlobal; delete d.configGlobal;
					t.copy(t.def,d,'settingsGlobal'); d.settings=d.settingsGlobal; delete d.settingsGlobal;
					
					d.nicks={
						0:{	't':'u','n':d.nick,'id':0	},
						1:{	't':'a','n':d.nickai,'id':1	}
					};
					delete d.nick;
					delete d.nickai;
					t.updateAddParams(d,'nick');
					t.w({config:d.config})
					d.config.url.v=d.url;
					delete d.url;

					let tmp;
					tmp=d.system; delete d.system; d.system={'1':tmp};
					tmp=d.instr; delete d.instr; d.instr={'1':tmp};
					
					t.updateAddParams(d,'amountNicks');
					t.updateAddParams(d,'pState');
					
					for (const i in d.pState) {
						d.pState[i]=0;
					}
					delete d.sysHide;
					delete d.instrHide;
					delete d.pullHide;
					delete d.setingsHide;
					delete d.settings; //just delete old settings )
					t.copy(t.def,d,'settingsGlobal'); d.settings=d.settingsGlobal; delete d.settingsGlobal;
					d.config.version.v=1;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.1;
					//delete d.settings; //just delete old settings )
					t.copy(t.def,d,'settingsGlobal'); d.settings=d.settingsGlobal; delete d.settingsGlobal;
					d.config.version.v=1.1;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.1) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.2;
					t.updateAddParams(d,'config');
					for(const i in d.models) {
						if(d.models[i].n!=d.model) continue;
						d.model=i;
						break;
					}
					for(const t of d.turns) {
						for(const b of t.branches) {
							for(const m of b.msgs) {
								m.tp={};
								m.tr={};
							}
						}
					}
					let tmp={};
					t.w({'updating nicks':d.nicks});
					d.nicks['-1']				=t.nicks['-1'];
					d.amountNicks['s']	=t.amountNicks['s'];
					d.nick['s']					=t.nick.s;
					d.nick['n']['s']		=t.nick.n.s;
					t.w({'updated nicks':d.nicks,nick:d.nick,amountNicks:d.amountNicks})
					d.config.version.v=1.2;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.2) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.3;
					t.updateAddParams(d,'config');
					d.config.version.v=1.3;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.3) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.4;
					let tmp=t.msgTmpl(1,null,0); //just to get new fields
					for(const tu of d.turns) {
						if(tu.role==='root') continue;
						for(const b of tu.branches) {
							if(!b.msgs.length) continue;
							for(const m of b.msgs) {
								for(const i in tmp) {
									if(m.hasOwnProperty(i)) continue;
									m[i]=tmp.i
								}
								m.status	=t.msgStatusId('done');
							}
						}
					}
					t.updateAddParams(d,'config');
					d.config.version.v=1.4;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.4) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.5;
					t.settingsGlobal.options.stop.v=[d.settings.options.stop.v];
					d.settings.options=t.settingsGlobal.options;
					//if we change userAdd or structures this will need rewriting
					//clean current list
					for(const i in t.nicks) {
						if(i.id>1) delete t.nicks[i.id];
					}
					t.amountNicks['idNext']=2;
					//find max id in loaded.
					let maxId=1;
					for(const i in d.nicks) {
						d.nicks[i].del=0; //add del key
						if(i>maxId) maxId=i;
					}
					t.amountNicks['idNext']=maxId*1+1;
					let tmp=t.msgTmpl(1,null,0); //just to get new fields
					for(const tu of d.turns) {
						if(tu.role==='root') continue;
						let role;
						if(tu.role==='user') role='u'
						if(tu.role==='assistant') role='a';
						if(tu.role==='system') role='s';
						for(const b of tu.branches) {
							if(!b.msgs.length) continue;
							for(const m of b.msgs) {
								//set status done for all without of one
								if(!m.hasOwnProperty('status')) m.status=t.msgStatusId('done');
								if(m.status==null) m.status=t.msgStatusId('done');
								m.edited=0; //add edited key
								m.nId=null;
								//match name to ids
								for(const i in d.nicks) {
									if(m.nick===d.nicks[i].n) {
										m.nId=i;
										break;
									}
								}
								//if not found (deleted) add a deleted user
								if(m.nId==null) {
									//copy added deleted user to d
									t.nick['n'][role]=m.nick;
									t.userAdd(role,m.nick);
									let id=t.amountNicks['idNext']-1;
									t.nicks[id].del=1;
									d.nicks[id]=t.nicks[id];
									m.nId=id;
								}
							}
						}
					}
					t.updateAddParams(d,'config');
					d.config.version.v=1.5;
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.5) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.6;
					t.updateAddParams(d,'config');
					for(const i in d.config) { 
						if(!t.config.hasOwnProperty(i)) continue;
						for(const j of ['q','qn']) { d.config[i][j]=t.config[i][j] }
					}
					for(const i in d.settings.options) {
						for(const j of ['q','qn']) { d.settings.options[i][j]=t.settings.options[i][j] }
					}
					for(const i in d.settings.req) {
						for(const j of ['q','qn']) { d.settings.req[i][j]=t.settings.req[i][j] }
					}
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.6) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.7;
					t.w({n:d.nick});
					t.updateAddParams(d,'config');
					t.updateAddParams(d,'group');
					t.updateAddParams(d,'groupAddN');
					t.updateAddParams(d,'context');
					t.updateAddParams(d,'msgUserListOn');
					d.pState=t.pState;
					t.group=0;
					for(const u in t.nicks) {
						if(t.nicks[u].t=='s') continue;
						t.userDelDo(u);
						delete t.nicks[u];
					}
					t.w({'list of users before import':t.nicks,importing:d.nicks,sys:d.system});

					let tmp={system:{},instr:{}};
					for(const u in d.nicks) {
						if(d.nicks[u].t=='s') continue;
						if(d.nicks[u].del) continue;
						const id=t.userAdd(d.nicks[u].t,d.nicks[u].n);
						tmp.system[id]=d.system[u];
						tmp.instr[id]=d.instr[u];
						t.userGroupAdd(1,id);
					}
					d.system=tmp.system;
					d.instr=tmp.instr;
					d.groups=t.groups;
					d.nicks=t.nicks;
					d.group=1;
					d.amountNicks=t.amountNicks;
					
					for(const tu of d.turns) {
						for(const b of tu.branches) {
							if(!b.msgs.length) continue;
							for(const m of b.msgs) {
								m.nicks={};
								for(const u in d.nicks) {
									if(d.nicks[u].t!='u'&&d.nicks[u].t!='a') continue;
									m.nicks[u]=true;
								}
								m.nicksArr=t.msgUserListAll({nicks:m.nicks});
							}
						}
					}
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.7) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.config.version.v=1.8;
					for(const u in d.nicks) {
						d.nicks[u].system	=d.system[u];
						d.nicks[u].instr	=d.instr[u];
						d.nicks[u].setsDo	=false;
						d.nicks[u].sets		=false;
					}
					delete d.system;
					delete d.instr;
					delete t.system;
					delete t.instr;
					
					t.w(`upgraded to version ${d.config.version.v}`);
					parse(d);
					return;
				} else if (ver==1.8) {
					t.w(`upgrading from version ${d.config.version.v}`);
					d.settings.req.model={};
					t.copy(t.settingsGlobal.req,d.settings.req,'model');
					d.settings.req.model.v.v=d.model;
					d.configGlobal=d.config;
					d.settingsGlobal=d.settings;
					delete d.config;
					delete d.settings;
					delete d.model;
					delete d.message;
					for(let m of d.models) {
						m.n=`${m.n} (${m.ps} ${m.q})`;
					}

					d.configGlobal.version.v=1.9;
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver==1.9) {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.2';

					for(const p in t.configGlobal) {
						t.w(`updating key ${p} in config`);
						if(!d.configGlobal.hasOwnProperty(p)) continue;
						d.configGlobal[p].opt=t.def.configGlobal[p].opt;
						d.configGlobal[p].def=t.def.configGlobal[p].def;
						for(let u in d.nicks) {
							u=d.nicks[u];
							if(!u.hasOwnProperty('config')) continue;
							u.config[p].def=t.def.configGlobal[p].def;
							u.config[p].opt=t.def.configGlobal[p].opt;
						}
					}
					for(const s of ['options','req']) {
						for(const p in t.def.settingsGlobal[s]) {
							t.w(`processing param ${p}`);
							if(!d.settingsGlobal[s].hasOwnProperty(p)) continue;
							if(!d.settingsGlobal[s][p].hasOwnProperty('name')) d.settingsGlobal[s][p].name=p;
						
							d.settingsGlobal[s][p].opt=t.def.settingsGlobal[s][p].opt;
							d.settingsGlobal[s][p].def=t.def.settingsGlobal[s][p].def;
							for(let u in d.nicks) {
								u=d.nicks[u];
								if(!u.hasOwnProperty('settings')) continue;
								u.settings[s][p].def=t.def.settingsGlobal[s][p].def;
								u.settings[s][p].opt=t.def.settingsGlobal[s][p].opt;
								if(!u.settings[s][p].hasOwnProperty('name')) u.settings[s][p].name=p;
							}
						}
					}
					t.updateAddParams(d,'pState');
					t.updateAddParams(d,'opt');
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.2") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.3';
					for(const m in d.opt) {
						for(const p in d.opt[m].v) {
							d.opt[m].v[p].rnd='';
						}
					}
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.3") {
					d.configGlobal.version.v='1.9.4';
					parse(d);
					return;
				} else if (ver=="1.9.4") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.5';

					t.updateAddParams(d,'configGlobal');
					t.updateAddParams(d,'pState');
					d.modelsEmb=[];
					t.copy(t.def.settingsGlobal.req,d.settingsGlobal.req,'modelEmb');
					d.rag={};
					for(let u in d.nicks) {
						d.rag[u]=t.ragStrct();
						u=d.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						t.copy(t.def.settingsGlobal.req,u.settings.req,'modelEmb');
						t.copy(t.def.configGlobal,u.config,'urlEmb');
						delete u.config.urlProxy;
					}
					delete d.configGlobal.urlProxy;
					delete d.proxy;
					
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.5") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.6';

					d.rag['g']=t.ragStrct();
					t.updateAddParams(d,'configGlobal');
					d.configGlobal.stories.d=t.def.configGlobal.stories.d;
					if(d.configGlobal.stories.v) {
						d.configGlobal.storiesUI.v=true;
					} else {
						d.configGlobal.stories.v=true;
						d.configGlobal.storiesUI.v=false;
					}
					
					for(let u in d.nicks) {
						if(!d.rag.hasOwnProperty(u)) d.rag[u]=t.ragStrct();
						u=d.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						t.copy(t.def.configGlobal,u.config,'ragMinSmlr');
						t.copy(t.def.configGlobal,u.config,'storiesUI');
						t.copy(t.def.configGlobal,u.config,'bgImg');
						t.copy(t.def.configGlobal,u.config,'bgFixed');
						t.copy(t.def.configGlobal,u.config,'chatHeight');
						t.copy(t.def.configGlobal,u.config,'imgsLastOnly');
						t.copy(t.def.configGlobal,u.config,'rag');
						t.copy(t.def.configGlobal,u.config,'ragGAmount');
						t.copy(t.def.configGlobal,u.config,'ragUAmount');

						u.config.stories.d=t.def.configGlobal.stories.d;
						if(u.config.stories.v) {
							u.config.storiesUI.v=true;
						} else {
							u.config.stories.v=true;
							u.config.storiesUI.v=false;
						}
					}
					
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.6") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.7';
					
					t.updateAddParams(d,'configGlobal');
					for(const p in t.def.configGlobal) {
						d.configGlobal[p].g=t.def.configGlobal[p].g;
					}
					for(const s of ['options','req']) {
						for(const p in t.def.settingsGlobal[s]) {
							d.settingsGlobal[s][p].g=t.def.settingsGlobal[s][p].g;
						}
					}
					
					for(let u in d.nicks) {
						u=d.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						t.copy(t.def.configGlobal,u.config,'ragPast');
						u.config.version.v='1.9.7';

						for(const p in t.def.configGlobal) {
							if(!u.config.hasOwnProperty(p)) {
								t.copy(t.def.configGlobal,u.config,p);
							} else {
								u.config[p].g=t.def.configGlobal[p].g;
							}
						}
						for(const s of ['options','req']) {
							for(const p in t.def.settingsGlobal[s]) {
								if(!t.def.settingsGlobal[s].hasOwnProperty(p)) {
									t.copy(t.def.settingsGlobal[s],u.settings[s],p);
								} else {
									u.settings[s][p].g=t.def.settingsGlobal[s][p].g;
								}
							}
						}
					}
					
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.7") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);

					d.configGlobal.version.v='1.9.8';

					t.updateAddParams(d,'pState');
					t.copy(t.def,d,'memNew');
					t.copy(t.def,d,'charNew');

					d.charNew.parts	=t.charNewTmpl(d.charNew);
					d.memNew.parts	=t.memNewTmpl(d.memNew);

					t.charCreateReset(d.charNew);

					for(const tr of d.turns) {
						br: for(const b of tr.branches) {
							let rated=0;
							for(const m of b.msgs) {
								if(m.rating!=null&&m.rating!=='') {
									rated=1;
									break;
								}
							}
							b.rated=rated?true:false;
						}
					}
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				} else if (ver=="1.9.8") {
					t.w(`upgrading from version ${d.configGlobal.version.v}`);
					d.configGlobal.version.v='1.9.8b';

					d.settingsGlobal.req.model.sess='v';
					d.settingsGlobal.req.modelEmb.sess='v';
					for(let u in d.nicks) {
						if(!u.hasOwnProperty('settings')) continue;
						u.settings.req.model.sess='v';
						u.settings.req.modelEmb.sess='v';
					}
					t.w(`upgraded to version ${d.configGlobal.version.v}`);
					parse(d);
					return;
				}
				
				
				t.w('adding new config vars');
				t.updateAddParams(d,'configGlobal');
				
				for(let i in d) {
					t[i]=d[i]
				}
				
				t.w('restore data links to computed vals');
				t.nicks[-1].n											=computed(()=>t.config.sysNick.v);
				t.settingsGlobal.req.model.v.l		=computed(()=>t.models);
				t.settingsGlobal.req.modelEmb.v.l	=computed(()=>t.modelsEmb);
				for(let u in t.nicks) {
					u=t.nicks[u];
					if(!u.hasOwnProperty('settings')) continue;
					u.settings.req.model.v.l		=computed(()=>t.models);
					u.settings.req.modelEmb.v.l	=computed(()=>t.modelsEmb);
				}
				t.w(`finished upgrading to version: ${t.configGlobal.version.v}`);
				
				t.working					=0; t.cancel=0;
				t.charNew.working	=0; t.charNew.cancel=0;
				t.memNew.working	=0; t.memNew.cancel=0;
				
				t.urlTest(); //will do list
			}
			this.w(l.files[0])
			this.w(fr.addEventListener("load",function() { parse(d) }))
			fr.readAsText(l.files[0]);
		},
		save() {
			let name='';
			main: for(const i in this.nicks) {
				name+=this.nicks[i].n+'-';
			}
			name=name.slice(0,-1);
			name=name.replace(/[^\w0-9\.-]/gi,'');
			name.match(/^(.{1,64})/); 
			name=`chat.${name}.${Date().toString()}.json`;
			
			const blob=new Blob([JSON.stringify(this.$data)],{ type: "text/json" });
			const l		=document.createElement("a");
			l.download						=name;
			l.href 								=window.URL.createObjectURL(blob);
			l.dataset.downloadurl	=["text/json",l.download,l.href].join(":");

			l.dispatchEvent(
				new MouseEvent("click",{
					view: window,
					bubbles: true,
					cancelable: true,
				})
			)
			l.remove()
		},
		optResSave() {
			const name=`Optimize_results.${Date().toString()}.html`;
			const blob=new Blob(["<html>"+document.getElementById('css').outerHTML+"<body>"+document.getElementById('optRes').outerHTML+"</body></html>"],{ type: "text/html" });
			this.w({blob:blob});
			const l								=document.createElement("a");
			l.download						=name;
			l.href 								=window.URL.createObjectURL(blob);
			l.dataset.downloadurl	=["text/html",l.download,l.href].join(":");

			l.dispatchEvent(
				new MouseEvent("click",{
					view: window,
					bubbles: true,
					cancelable: true,
				})
			)
			l.remove()
		
		},
		list() {
			if(this.working) {
				this.w('working right now, leaving');
				return;
			}
			this.working=1;
			this.w(`listing models`);
			
			fetch(this.url()+"/api/tags",{
				"method": "GET",
			}).then(r=>{
				if(!r.ok) throw new Error(r.statusText);
				return r.text();
			}).then(async(r)=>{
				let res='';
				this.w(`parsing list reply`);
				try { res=JSON.parse(r) } catch (error) { console.error(`error: ${error}`) }
				let old={
					model:		[...this.models],
					modelEmb:	[...this.modelsEmb]
				};
				this.w({oldModels:old});
				this.models	=[]; this.modelsEmb	=[];
				this.w({modelsDL:res});
				let mdls=[];
				for(const m of Object.keys(res.models).sort((a,b)=>{
					return res.models[a].name.localeCompare(res.models[b].name.toLowerCase());
				})) {
					let md=res.models[m];
					mdls.push({
						tag:	md.name,
						n:		`${md.name} (${md.details.parameter_size} ${md.details.quantization_level})`,
						mt:		md.modified_at,
						s:		md.size,
						ps:		md.details.parameter_size,
						q:		md.details.quantization_level,
						ctx:	null,
					});
					await this.modelData(mdls,mdls.length-1);
					this.w(`processed model ${md.name}`);
				}
				this.w('processed new models');
				for(const m of mdls) {
					if(m.emb) {
						this.modelsEmb.push(m);
					} else {
						this.models.push(m);
					}
				}
				
				if(!this.models.length) {
					this.w('no models found');
					this.working			=0;
					this.connection		=1;
					this.connectionErr='';
					this.pToggle('pull',1);
					return;
				}
				
				//this section had too many copy-pastes, one day it needs to be redone )).
				//but we can just wait 1-2 years till llm can do that, right? )
				//thank you, llm of the future! ))
				var horror={model:'models',modelEmb:'modelsEmb'};
				for(const i in horror) {
					if(!this.settingsGlobal.req[i].v.l.length) {
						this.settingsGlobal.req[i].v.v='';
						continue;
					}
					let m=this.settingsGlobal.req[i].v.v;
					let found=-1;

					if(!old[i].length) {
						this.w(`no old model list found for ${i}`);
					} else if(m>(old[i].length-1)) {
						this.w(`selected ${m} value ${m} for strange reason is larger than old array: ${old[i].length-1}`);
					} else if(m!=null&&m!=='') {
						this.w(`searching for previously selected models in new list ${i} ${m} ${old[i].length}`);
						this.w({old:old});

						for(let M=0;M<this.$data[horror[i]].length;M++) { //>
							if(old[i][m].n===this.$data[horror[i]][M].n) {
								found=M;
								this.w(`found matching model #${M} ${this.$data[horror[i]][M].n}`)
								break;
							}
						}
					} else {
						this.w(`no model selected globaly, skipping and setting the first one`);
					}
					
					if(found==-1) found=0; this.settingsGlobal.req[i].v.v=found;
					this.w(`globally set model ${this.$data[horror[i]][this.settingsGlobal.req[i].v.v].n}`);
				}
				
				for(const i in horror) {
					this.w(`setting ${i}`);
					for(let u in this.nicks) {
						u=this.nicks[u];
						if(!u.hasOwnProperty('settings')) continue;
						if(!u.settings.req[i].v.l.length) {
							u.settings.req[i].v.v='';
							continue;
						}
						let found=-1;
						let us=u.settings.req[i].v;
						if(!old[i].length) {
							this.w(`no old model list found for ${i}`);
						} else if(us.v>(old[i].length-1)) {
							this.w(`selected ${i} value ${us.v} for strange reason is larger than old array: ${old[i].length-1}`);
						} else if(us.v!=null&&us.v!=='') {
							for(let m=0;m<this.$data[horror[i]].length;m++) { //>
								if(old[i][us.v].n===this.$data[horror[i]][m].n) {
									found=m;
									this.w(`found matching model #${m} for user ${u.n}`);
									break;
								}
							}
						}
						if(found==-1) found=0; us.v=found;
						this.w(`user ${u.n} set model ${this.$data[horror[i]][us.v].n}`);
					}
				}
				
				this.w({'models':this.models.length});
				this.connectionErr	='';
				this.connection			=1;
				this.cancel					=0;
				this.working				=0;
				
			}).catch((error)=>{
				this.cancel	=0;
				this.working=0;
				this.connectionErr=error.message;
				this.connection=0;
				this.w(`listing conneciton err: ${error.message}`);
				return;
			});
		},
		async modelData(mdls,id) {
			return fetch(this.url()+"/api/show",{
				"method": "POST",
				'body': JSON.stringify({ name:mdls[id].tag }),
			}).then(r=>{
				if(!r.ok) throw new Error(r.statusText);
				return r.text();
			}).then(r=>{
				let res='';
				try { res=JSON.parse(r) } catch (error) { console.error(`error: ${error}`) }
				this.w({'pulled model data':res});
				if(res.hasOwnProperty('parameters')) {
					this.w({'has parameters specified':res.parameters});
					let tmp=res.parameters.match(/.*num_ctx\s+(\d+)/);
					if(tmp&&tmp[1]) {
						this.w(`modelfile of ${mdls[id].n} has num_ctx: ${tmp[1]}`);
						mdls[id]['ctx']=tmp[1];
					}
				}
				if(res.details.hasOwnProperty('family')) {
					let tmp=res.details.family.match(/\bbert\b/i);
					mdls[id].emb=tmp==null?false:true;
					this.w(`${mdls[id].n} embedded status: ${mdls[id].emb}`);
				}
			}).catch((error)=>{
				this.connectionErr=error.message;
				this.connection=0;
				return;
			});
		},
		loadFile(n) {
			this.w(`loading file for ${n}`);

			const l=document.getElementById('load'+n);
			let fr=new FileReader();
			let t	=this;
			let d;
			async function parse(n,d) {
				t.w(`loading: ${n}`);
				if(n==='bgImg') {
					//fetch('/img.jpg').then((r)=>{
					//	return r.blob();
					//}).then((r)=>{
						//document.getElementById('bg').style.backgroundImage="url("++")";
						//this.bgImg=URL.createObjectURL(r);
					//});
					console.log('loading'+n);
					t.config.bgImg.v=d;//URL.createObjectURL(d);
					t.bgSet(t.config.bgImg.v);
				} else if (n==='img') {
					t.imgs.push(d.replace('data:','').replace(/^.+,/,''));
					t.w(`loaded images ${t.imgs.length}`);
				}
			}
			this.w(`file: ${l.files[0]}`);
			this.w(fr.addEventListener("load",function() { parse(n,fr.result) }))
			fr.readAsDataURL(l.files[0]);
			//fr.readAsBinaryString(l.files[0]);
		},
		bgFix(v) {
			if(v) {
				document.getElementById('body').style.backgroundAttachment='fixed';
			} else {
				document.getElementById('body').style.backgroundAttachment='scroll';
			}
		},
		bgSet(d) {
			document.getElementById('body').style.backgroundImage	=`url(${d})`;
			document.getElementById('body').style.backgroundSize	='100% auto';
			document.getElementById('body').style.backgroundRepeat='repeat-y';
		},
		pull() {
			this.working			=1;
			this.connectionErr='';
			
			fetch(this.url()+"/api/pull",{
				"method": "POST",
				"body": JSON.stringify({
					'name':	this.modelPull,
				})
			}).then(r=>{
				if(!r.ok) throw new Error(r.statusText);
				return r.body;
			}).then(r=>{
				this.w('dissecting response');
				const t				=this;
				const decoder	=new TextDecoder('utf-8');
				const reader	=r.getReader();
				let res='',buf='';
				this.mpull=[{status:''}];
				
				reader.read().then(function processText({done,value}) {
					if(done) {
						t.w({'Stream complete':res});
						t.cancel=0;
						return true;
					}
					if(t.cancel) {
						t.w('cancelling');
						reader.cancel();
						reader.releaseLock();
						t.cancel=0;
						return 'cancel';
					}
					buf					=decoder.decode(value);
					const chnks	=buf.trim().split('\n');
					//t.w(buf);

					for (const ch of chnks) {
						try { res=JSON.parse(ch) } catch (error) { t.w(`error: ${error}`) }
						if(res.hasOwnProperty('error')) {
							reader.cancel();
							reader.releaseLock();
							t.cancel=0;
							return res.error;
						}
						if(res.status!=t.mpull[t.mpull.length-1].status) {
							t.mpull.push({'status':res.status});
						}
						let p=t.mpull[t.mpull.length-1];
						if(res.status&&res.total) {
							p.total	=res.total;
							p.done	=res.completed;
							if(!p.done) {
								p.prcnt	=0
							} else {
								p.prcnt	=Math.floor(100/(p.total/p.done))
							}
						}
					}
					return reader.read().then(processText);
				}).then(r=>{
					t.w(`model pull attempt is finished, status ${r}`);
					t.working	=0;
					t.cancel	=0;
					if(r===true||r==='cancel') {
						t.connectionErr='';
						t.pToggle('pull',0);
						t.list();
					} else {
						t.connectionErr=r;
					}
				}).catch((error)=>{
					t.working=0;
					t.cancel=0;
					t.connectionErr=error.message;
					t.connection=0;
					return;
				});
			})
		},
		updateAddParams(d,p) {
			this.w(`updateAddParams for key ${p}`);
			if(!d.hasOwnProperty(p)) {
				this.w(`loaded file doesn't have whole section ${p}, importing`);
				d[p]=this['def'][p];
				return;
			}
			for(let i in this['def'][p]) {
				this.w(`checking property ${i}`)
				if(d[p].hasOwnProperty(i)) {
					this.w(`skipping param ${i}, already exists in loaded file`);
				} else {
					this.w(`adding param ${i} to loaded file`);
					d[p][i]=this['def'][p][i]
				}
			}
		},
		shuffle() {
			return ([...arr], n = 1) => {
				let m = arr.length;
				while (m) {
					const i = Math.floor(Math.random() * m--);
					[arr[m], arr[i]] = [arr[i], arr[m]];
					return arr.slice(0, n);
				};
			}
		},

		//rag methods
		loadRag() {
			this.w('starting loading rag');

			const l=document.getElementById('loadRag');
			let fr=new FileReader();
			let t	=this;
			let d;
			async function parse(d) {
				t.w({parsing:d});
				for(const l of d.split('\n')) {
					t.w(`embedding ${l}`)
					t.rag[-1].v.push(await t.embed(l));
				}
			}
			this.w(`file: ${l.files[0]}`);
			this.w(fr.addEventListener("load",function() { parse(fr.result) }))
			fr.readAsText(l.files[0]);
		
		},
		ragStrct() {
			return {
				v:				[],
				t:				'',
				doing:		false,
				done:			0,
				total:		0,
				last:			[],
				modelEmb:	'',
				err:			null
			};
		},
		async ragU(u) {
			if(u==null) return;
			this.workingRag	=true;
			this.w(`updating rag for user ${u}`);

			let r=this.rag[u],p=[]; const old=r.v;
			r.modelEmb=this.settings.req.modelEmb.v.l[this.settings.req.modelEmb.v.v].tag;
			r.v=[];
			txt: for(let l of this.rag[u].t.split('\n')) {
				l=l.trim(); if(!l.length) continue;
				for(const o of old) {
					if (o[1]===l) {
						this.w(`using existing embedding for ${l}`);
						r.v.push(o);
						continue txt;
					}
				}
				p.push(l);
			}
			r.done=0; r.total=p.length; r.doing=true;
			this.w(`rag paragraphs: ${p.length}`);
			for(let P=0;P<p.length;P++) { //>
				const e=await this.embed(p[P]);
				if(!e.length) continue;
				r.v.push(e);
				r.done=P+1;
			}
			r.doing					=false;
			this.workingRag	=false;
		},
		cosine(A,B) {
			let dotproduct=0,mA=0,mB=0;

			this.w(`cosine ${A.length} ${B.length}`);
			for(let i=0;i<A.length;i++) {//>
				dotproduct+=A[i]*B[i];
				mA+=A[i]*A[i];
				mB+=B[i]*B[i];
			}
			mA=Math.sqrt(mA); mB=Math.sqrt(mB);

			let s=dotproduct/(mA*mB);
			this.w(`cosine ${dotproduct} ${mA} ${mB}`)
		
			return s;
		},
		async embed(txt) {
			if(txt==null||!txt.length||!this.settings.req.modelEmb.v.l.length) return;
			let opt						={};
			opt['model']			=this.settings.req.modelEmb.v.l[this.settings.req.modelEmb.v.v].tag;
			opt['prompt']			=txt.trim();
			this.w({opt:opt});
			const t=this;
			
			let r,d;
			try {
				r=await fetch(t.config.urlEmb.v+"/api/embeddings",{
					"method": "POST",
					"body": 	JSON.stringify(opt)
				});
				if(!r.ok) throw new Error(r.statusText);
			} catch(err) {
				t.w(`Error: ${err}`);
				t.rag.err=`${err}`;
				return [];
			}
			t.rag.err=null;
			d=await r.json();
			t.w(`embed received ${d.embedding}`);
			return [d.embedding,txt];
		},

		//group methods
		//user methods
		userGroupDel(g,i) {
			if(g==0&&!confirm(`This is the list of all users, if you delete character "${this.nicks[i].n}", it will be gone permanently. The messages will stay but not the character. Are you sure you wish to delete this character?`)) {
				return;
			}
			this.userGroupDelDo(g,i);
		},
		userGroupDelDo(g,i) {
			if(!this.groups[g].u[i]) return 0;
			this.w(`removing user ${i} from group ${g}`)
			const n=this.nicks[i];
			if(this.groups[g].sel[n.t]==i) {
				this.w(`user is the selected one in the group, removing.`);
				for(const j in this.groups[g].u) {
					this.w(`comparing nick ${j} with ${i}`);
					if(j==i||this.nicks[j].t!=n.t) continue;
					this.w(`found matching role user "${this.nicks[j].n}" with id ${j} in group ${g}`);
					this.groups[g].sel[n.t]=j;
					break;
				}
				if(this.groups[g].sel[n.t]==i) {
					this.w(`we have not found any other user of this type in the group, setting selected one to null`);
					this.groups[g].sel[n.t]=null;
				}
			} else {
				this.w(`user ${i} is not selected one`);
			}
			for(const u in this.groups[g].u) {
				delete this.groups[g].u[u][i];
			}
			
			this.groups[g].an[n.t]--;
			this.groups[g].an['t']--;
			delete this.groups[g].u[i];
		},
		userDel(i) {
			if(confirm(`Are you Really sure you wish to completely delete "${this.nicks[i].n}"? It won't affect the existing chat but will delete the nick and its system and instruction messages.`)) {
				this.userDelDo(i)
			}
		},
		userDelDo(i) {
			const t=this.nicks[i].t;
			for(const g in this.groups) {
				this.userGroupDelDo(g,i);
			}
			this.amountNicks['t']--;
			this.amountNicks[t]--;
			this.nicks[i].del=1;

			for(const t of this.turns) {
				for(const b of t.branches) {
					for(const m of b.msgs) {
						delete m.nicks[i];
						m.nicksArr=this.msgUserListAll({nicks:m.nicks}); //caches are so caches.
					}
				}
			}
		},
		userGroupAdd(g,u) {
			if(u==null) return;
			this.w(`adding user ${u} to group ${g}`);
			const t=this.nicks[u].t;
			this.groups[g].an['t']++;
			this.groups[g].an[t]++;
			this.groups[g].u[u]={};
			for(const i in this.groups[g].u) {
				this.groups[g].u[u][i]=true;
				this.groups[g].u[i][u]=true;
			}
			if(this.groups[g].sel[t]===null) {
				this.groups[g].sel[t]=u;
			}
		},
		groupDel(g) {
			if(this.groups.length<=1) { //>
				alert('Can not delete the only group.');
				return;
			}
			for(const i in this.groups) {
				if(i==g) continue;
				this.group=i*1; //yep
				break;
			}

			this.w(`new chosen group is ${this.group}`);
			for(const u in this.groups[g].u) {
				this.userGroupDel(g,u);
			}
			this.groups.splice(g,1);
		},
		userAdd(t,n) {
			const id=this.amountNicks['idNext']++;
			this.amountNicks['t']++;
			this.amountNicks[t]++;
			this.nicks[id]		={ t:t,n:n,'id':id,del:0,system:'',instr:'',sets:false,setsDo:false };
			this.nick['n'][t]	='';
			this.rag[id]=this.ragStrct();
			this.userGroupAdd(0,id);
			return id;
		},
		userVis(t,id) {
			//this.w(`checking vis of ${id}`);
			const u=this.nicks[id];
			//this.w(`checking vis of ${id} ${u.n}: ${u.del}`);
			if(t!==u.t) return 0;
			if(u.del==1) return 0;
			//if(!this.groups[this.group]) return 0;
			//if(!this.groups[this.group].u[u.id]) return 0;
			return 1;
		},
		userCh(t,v) {
			this.w(`userch ${t}`);
			if(t==='u') {
				this.w('chosen user nick has changed, let us update side msg if it is open and turns');
				//this.turnLastFilteredGo();
				const tbm=this.tbma(this.turn);
				if(this.msgSide(...tbm)) this.msgSideNickUpdate(...tbm);
			}
		},
		userAiCh(v) {
			this.w('chosen ai nick has changed, let us update turns');
			//this.turnLastFilteredGo();
		},
		userTypeCh(u) {
			const t	=this.nicks[u].t;
			const tn=(t=='u'?'a':'u');
			this.nicks[u].t=tn;
			//sigh, these had to be auto but..
			for(const g in this.groups) {
				if(!this.groups[g].u[u]) continue;
				this.groups[g].an[t]--;
				this.groups[g].an[tn]++;
				if(this.groups[g].sel[t]==u) {
					for(const j in this.groups[g].u) {
						if(this.userVis(t,j)) {
							this.groups[g].sel[t]=j;
							break;
						}
					}
					if(this.groups[g].sel[t]==u) this.groups[g].sel[t]=null
				}
				if(this.groups[g].sel[tn]==null) this.groups[g].sel[tn]=u;
			}
			this.amountNicks[t]--;
			this.amountNicks[tn]++;
		},
		groupAdd(n,u) {
			if(!n.length) {
				alert('Please, give it a name');
				return;
			}
			this.groups.push(this.groupTmpl(n,u));
			for(const i of u) {
				this.userGroupAdd(this.groups.length-1,i);
			}
			this.group=this.groups.length-1;
		},
		groupTmpl(n,u) {
			let g={u:{},sel:{u:null,a:null,s:null},an:{u:0,a:0,s:0,t:0}};
			g.n	=n;
			return g;
		},
		groupPrev() {
			if(this.group>0) this.group--;
		},
		groupNext() {
			if(this.group<(this.groups.length-1)) this.group++; //>
		},
		userS(t) {
			const u=this.userSelected(t);
			//this.w(`returning select user ${t}=${u}`);
			return u;
		},
		userSelected(t) {
			if(!this.groups[this.group]) return null;
			return this.groups[this.group]['sel'][t];
		},
		copy(o,on,k) {
			//this.w({parsing:o})
			if(o[k]==null) {
				on[k]=null
			} else if(Array.isArray(o[k])) {
				on[k]=[];
				//this.w(`copying arr ${k}`);
				for(const i in o[k]) { this.copy(o[k],on[k],i) }
			} else if(typeof o[k]==='object') {
				on[k]={};
				//this.w(`copying object ${k}`);
				for(const i in o[k]) { this.copy(o[k],on[k],i) }
			} else {
				//this.w(`copying val ${k}`);
				on[k]=o[k];
			}
		},
		userSetsPerAi(id) {
			if(id==null) return;
			const u=this.nicks[id];
			console.log(`personal sets sets for ${id}: ${u.setsDo}`)
			if(u.setsDo) {
				if(!u.hasOwnProperty('settings')) {
					u.config							={...this.configGlobal};
					u.settings={};
					u.settings['req']			={...this.settingsGlobal.req};
					u.settings['options']	={...this.settingsGlobal.options};
					this.copy(this.$data,u,'settingsGlobal');
					this.copy(this.$data,u,'configGlobal');
					u.settings=u.settingsGlobal; 	delete u.settingsGlobal;
					u.config	=u.configGlobal; 		delete u.configGlobal;
					u.settings.req.model.v.l=computed(()=>this.models);
					u.settings.req.modelEmb.v.l=computed(()=>this.modelsEmb);
				}
			}
			u.sets=u.setsDo;
		},
		
		//turn methods
		tbma(t) {
			return [t,this.branch(t),this.brancha(t).msg];
		},
		async turnUp() {
			event.preventDefault();

			if(this.turn<=1) return; //>
			const start=this.turn;

			let atVisible=!this.msgSkipped(...this.tbma(this.turn));
			while(!atVisible&&this.turn>1) {
				this.turn--;
				atVisible=!this.msgSkipped(...this.tbma(this.turn));
			}
			if(start!==this.turn) return;
			this.turn--;
			while(this.msgSkipped(...this.tbma(this.turn))&&this.turn>1&&atVisible) {
				this.w(`we went up one message at turn ${this.turn} but it's hidden, let's go higher`)
				atVisible++;
				this.turn--;
			}
			this.w(`stop at turn ${this.turn}`);
			await nextTick();
			this.scroll(null,0);
		},
		async turnDown(m) {
			event.preventDefault();

			const last=this.turnLast(this.turn);
			let lastv=null;
			
			if(m) {
				this.turn=last;
				await nextTick();
				this.scroll(null,0);
				return;
			}
			
			if(!this.turnNotLast(this.turn)) return;
			
			lastv=this.turn;
			let t=this.turn+1;
			while(t<=last) { //>
				this.w(`trying next turn ${t}`);
				if(!this.msgSkipped(...this.tbma(t))) {
					lastv=t;
					break;
				}
				t++;
			}
			if(t>last) t=last;
			//this.turn=lastv; //it was a different logic attempt but interface was not good
			this.turn=t;
			
			await nextTick();
			this.scroll(null,0);
		},
		turnLastFilteredGo() {
			this.turnDown(1)
		},
		turnNotLast(t) {
			if(t>=(this.turns.length-1)) return null;
			if(this.turns[t+1].branch==-1) return null;
			return 1;
		},
		turnOff(t) {
			this.turnBranchSet(t,-1);
		},
		turnwhose(turn) {
			this.w(`searching for whose turn is at ${turn}`);
			let prev	=this.turns[turn-1];
			let ai		=prev.role=='user'?1:0;
			this.w(`new turn type is ai: ${ai}`);
			return ai;
		},
		turnnew(turn,u,g) {
			turn++;
			this.w(`generating new turn #${turn}`);
			if(this.turns[turn]) {
				this.w(`next turn is already there, skipping creation of the turn`);
			} else {
				this.w(`the turn ${turn} doesn't exist, let's create it`);
				let ai=this.turnwhose(turn);
				this.turns.push({
					'role':	(ai?'assistant':'user'),
					'branches':[],
					'branch':0,
					'tree':{},
				});
				this.turns[this.turns.length-1].tree[this.turns[turn-1].branch]={};
			}
			this.turn=turn;
			this.w(`set turn to ${turn}`);
			this.w(`initialize the first branch at turn ${turn}`);
			this.branchNew(turn,u,g);
			this.w({'current turn':this.turns[turn]});
		},
		turnBranchSet(t,b) {
			this.turns[t].branch=b;
		},
		turnLast(t) {
			const start=t;
			while(this.turns[t]&&this.turns[t].branch!==-1) {
				t++;
			}
			this.w(`turn last ${t} turn start ${start}`)
			return t-1;
		},
		turnRole(t) {
			return this.turns[t].role;
		},
		
		send(e,m,i) {
			if(e.key==='Enter'&&e.shiftKey) {
				return;
			}
			this.chat(m,i,true);
		},
		edit(e,m,i) {
			//e.preventDefault();
			this.w(e);
			if(m==='c') {
				this.w(`setting content from ${this.msga(i).content} to ${e.target.innerText.trim()}`);
				let txt=e.target.innerText.trim()??'';
				this.msga(i).edited	=1;
				this.msga(i).content=txt;
				e.target.innerText=txt;
			} else if (m==='n') {
				this.msga(i).nick=e.target.innerText.trim()??'';
			}
		},
		
		//branch methods
		branchNew(turn,u,g) {
			this.w(`adding new branch at ${turn}`)
			if(!this.turns[turn]) return;
			const prev	=this.turns[turn-1];
			const prevm =prev.branches[prev.branch].msg;
			let bnew		=0;
			let b				='';
			if(!this.turns[turn].tree[prev.branch]) bnew=1;
			if(!bnew) {
				b			=this.turns[turn].tree[prev.branch][prevm];
				bnew	=(b&&this.turns[turn].branches[b])?0:1;
			}
			if(!bnew) {
				this.w(`branch for the msg ${prevm} in turn ${turn} already exists: ${b}`);
			} else {
				this.w(`creating new branch at turn ${turn}`)
				this.turns[turn].branches.push(this.branchTmpl(turn,u,g));
				b=this.turns[turn].branches.length-1;
			}
			this.turnBranchSet(turn,b);
			this.w(`new branch id: ${b}`);
			this.w({'created branch in turn':turn,'branch':this.turns[turn].branches[this.turns[turn].branch]});
			if(bnew) this.treeu(turn);
		},
		branchTmpl(turn,u,g) {
			this.w(`adding branch to turn ${turn}`);
			return { rated:false,msg:0,msgs:[this.msgTmpl(u,null,g)] }
		},
		branch(turn) {
			return this.turns[turn].branch
		},
		brancha(turn) {
			//console.trace();
	    return this.turns[turn].branches[this.branch(turn)];
		},
		branchNested(turn) {
			this.w(`searching for nested branch at ${turn} for parent active message`);
			const prev=turn-1;
			const bprev=this.branch(prev);
			const tr	=this.turns[turn].tree[bprev]; //tree[prev branch id]
			this.w({'index value for parent branch':bprev,'tr':tr});
			if(!tr) return [null,null];
			const bn=tr[this.brancha(prev).msg]; //prev turn's branch/msg -> this branch id
			this.w(`index value of a local branch for the active message in parent branch: ${bn}`);
			if(bn==undefined) return [null,null];
			return [bn,this.turns[turn].branches[bn]];
		},
		branchu(turn) {
			this.w(`updating active branches ${turn}`);
			let turnIncomplete=this.turns.length;
			for(let i=turn+1;i<this.turns.length;i++) {//>
				this.w(`processing turn ${i}`);
				let [bn,b]=this.branchNested(i);
				if(bn==undefined||!this.msgInited(i,bn,b.msg)) {
					turnIncomplete=i;
					this.w({'leaving updating, setting turn':turnIncomplete,'branch':b});
					break;
				}
				this.w(`updating turn: ${i}, branch ${this.turns[i].branch} -> ${bn} (content: ${b.msgs[b.msg].content})`);
				this.turnBranchSet(i,bn);
			}
			
			for(let i=turnIncomplete;i<this.turns.length;i++) {//>
				this.w(`dropping branch for turn ${i}`);
				if(this.turns[i].branch==-1) break; //optimization, tho probably we don't even have to mark everything below? just 1.. 
				this.turnOff(i);
			}
			this.turn=turnIncomplete-1;
			this.w(`branchu sets turns to ${this.turn}`);
		},
		treeu(turn) {
			this.w(`updating index tree at ${turn}`);
			let prev=this.turns[turn-1];
			this.w({'parent branch':prev.branches[prev.branch]});
			if(!this.turns[turn].tree[prev.branch]) this.turns[turn].tree[prev.branch]={};
			this.turns[turn].tree[prev.branch][prev.branches[prev.branch].msg]=this.turns[turn].branch;
		},
		
		
		//msg methods
		msgTmpl(u,c,g) {
			this.w(`adding message template for ${u}`);
			let nicks={};
			if(g!=null) {
				for(const i in this.groups[g].u[u]) {
					if(!this.groups[g].u[u][i]) continue;
					this.w(`adding user ${i} to visible list`);
					nicks[i]=true;
				}
			}
			nicks[u]=true;
			return {
				'content':	(c!=undefined?c:null),
				'nick':			this.nicks[u].n,
				'nId':			u,
				'tp':				{},
				'tr':				{},
				'rating':		null,
				status:			this.msgStatusId('new'),
				edited:			null,
				nicks: 			nicks, //for easier access
				nicksArr:		this.msgUserListAll({nicks:nicks}) //to avoid sorting every time chat is updated
			}
		},
		msgNew(turn,u,u2,c,g) {
			this.w(`adding new message to turn ${turn}`);
			let b=this.brancha(turn)
			let m=this.msgTmpl(u,c,g);
			b.msgs.push(m);
			b.msg=this.msgTotal(turn,this.branch(turn))-1;
			this.branchNew(turn+1,u2,g);
		},
		msgGet(t,b,m) {
			return this.turns[t].branches[b].msgs[m];
		},
		msgWaiting(m) {
			if(m.status==null)	return 1;
			if(m.status==0)			return 1;
			return 0;
		},
		msgTotal(t,b) {
			return this.turns[t].branches[b].msgs.length;
		},
		msgEmpty(t,b,m) {
			const msg=this.msgGet(t,b,m);
			if(msg.images&&msg.images.length) return 0;
			if(!msg.content) return 1;
			if(!msg.content.length) return 1;
			return 0;
		},
		msgMvLeft(t) {
			let b=this.brancha(t);
			if(b.msg==0) return;
			b.msg--;
			this.branchu(t);
			this.turn=t;
			this.msgSideNickUpdate(...this.tbma(t));
		},
		async msgMvRight(t,wSideRating,aw) {
			this.w(`moving right at turn ${t}, siderating: ${wSideRating}`);
			let b=this.brancha(t);
			if(!this.msgLast(t,this.turns[t].branch)&&!wSideRating) {
				this.w(`it's not the last message: {b.msg}`);
				b.msg++;
				this.branchu(t);
				this.turn=t;
				this.msgSideNickUpdate(...this.tbma(t));
				return;
			}
			//add new message
			if(this.working) {
				this.w('working right now, leaving');
				return 0;
			}
			if(this.msgSide(t,this.turns[t].branch,b.msg)) return;
			let res;
			if(!aw) {
				this.chat((wSideRating?3:2),t,aw);
			} else {
				res=await this.chat((wSideRating?3:2),t,aw);
			}
			return res;
		},
		msgSide(t,b,m) {
			const msg=this.msgGet(t,b,m)
			if(msg.side==1) return 1;
			return 0;
		},
		msgLast(t,b) {
			let br=this.turns[t].branches[b];
			if(br.msg>=(this.msgTotal(t,b)-1)) return 1;
			return 0;
		},
		msgIndex(t,b) {
			return this.turns[t].branches[b].msg;
		},
		msgMore(t,b) {
			return this.msgTotal(t,b)-this.msgIndex(t,b)-1;
		},
		msgaStatusSet(t,s) {
			let tmp=this.tbma(t);
			this.msgStatusSet(...tmp,s);
		},
		msgStatusSet(t,b,m,s) {
			let msg=this.msgGet(t,b,m);
			this.msgStatusSetDo(msg,s);
		},
		msgStatusSetDo(m,s) {
			m.status=this.msgStatusId(s);
			if(this.msgWaiting(m)) {
				m.waiting=1;
			} else {
				delete m.waiting;
			}
		},
		msgStatusId(m) {
			if(m==='new') 		return null;
			if(m==='waiting') return 0;
			if(m==='done') 		return 1;
			if(m==='cancel') 	return 2;
			if(m==='loading') return 3;
			if(m==='error') 	return 4;
			throw new Error(`unknown status ${m}`);
		},
		msgInited(t,b,m) {
			let msg=this.msgGet(t,b,m);
			return msg.status!=this.msgStatusId('new');
		},
		msgSideNickUpdate(t,b,m) {
			//as we store non-normalized links, we have to update manually.
			if(!this.msgSide(t,b,m)) return 0;
			if(this.turns[t].role!=='user') return 0;
			this.w(`it's an unsent user side message, let's update the nick`);
			this.msgNickSet(t,b,m,this.userS("u"));
		},
		msgNickSet(t,b,m,u) {
			const msg=this.msgGet(t,b,m);
			msg.nick=this.nicks[u].n;
			msg.nId	=u;
		},
		scroll(id,top) {
			this.w(`scroll to ${id}`);
			let to=top?"start":"end";
			try {
				if(!id) {
					if(this.config.chatHeight.v!=''&&this.config.chatHeight.v>0) document.getElementById('chatLogEnd').scrollIntoView({ behavior:'smooth',block:to,inline:"nearest" });
					document.getElementById('prompt').scrollIntoView({ behavior:'smooth',block:to,inline:"nearest" });
				} else {
					document.getElementById(id).scrollIntoView({ behavior:'smooth',block:to,inline:"nearest" });
				}
			} catch(e) {
				this.w(`couldn't find id to scroll to: ${id}`)
			}
		},
		msgRating(i,v) {
			const m=this.msga(i);
			if(m.rating==v) {
				m.rating=null;
			} else {
				m.rating=v;
			}
			let brated=0;
			for(let j of this.msgsa(i)) {
				if(j.rating!=null&&j.rating!=='') {
					brated=1;
					break;
				}
			}
			this.brancha(i).rated=brated?true:false;
			this.w(`branch is rated=${this.brancha(i).rated}`);
		},
		msga(turn) {
			let b=this.brancha(turn);
			return b.msgs[b.msg];
		},
		msgsa(turn) {
			return this.brancha(turn).msgs;
		},
		msgFilterRow(t) {
			const msg=this.msga(t);
			if(this.msgFilter(...this.tbma(t))) {
				return "filterGray"
			}
		},
		msgUserAdd(msg,u,id) {
			msg.nicks[u]=true;
			msg.nicksArr=this.msgUserListAll({nicks:msg.nicks}); //re-sort
			this.w(`delete add user list ${id}`)
			delete this.msgUserListOn[id];
		},
		msgUserDel(msg,u) {
			if(!confirm(`Are you sure you wish to delete character ${this.nicks[u].n} from the access list of this message? If you do that, this character will not see the message anymore.`)) return 0;
			delete msg.nicks[u];
			msg.nicksArr=this.msgUserListAll({nicks:msg.nicks}); //re-build to remove erased one
		},
		msgUserListAvail(msg,t,g) {
			let users=[];
			for(const u in this.groups[g].u) {
				//this.w(`${this.userVis(t,u)} ${!msg.nicks.hasOwnProperty(u)}`)
				if(this.userVis(t,u)&&!msg.nicks.hasOwnProperty(u)) {
					users.push(u);
				}
			}
			//this.w({'available users':users});
			return users.sort((a,b)=>(this.nicks[a].n.localeCompare(this.nicks[b].n)));
		},
		msgUserListAllAvail(msg,g) {
			let users=[];
			users.push(...this.msgUserListAvail(msg,"u",g));
			users.push(...this.msgUserListAvail(msg,"a",g));
//			this.w(`${users}`);
			return users;
		},
		msgUserList(msg,t) {
			let users=[];
			for(const u in msg.nicks) {
				this.w(`checking if ${u} ${t} is visible the msg list`);
				if(this.userVis(t,u)&&msg.nicks[u]) users.push(u);
			}
			return users.sort((a,b)=>(this.nicks[a].n.localeCompare(this.nicks[b].n)));
		},
		msgUserListAll(msg) {
			let users=[];
			users.push(...this.msgUserList(msg,"u"));
			users.push(...this.msgUserList(msg,"a"));
			this.w(`list all users of the message: ${users}`);
			return users;
		},

		//chat methods
		async chat(m,turn,aw) {
			if(event!=null) event.preventDefault();
			if(this.working||this.workingRag) {
				this.w('can not do chat, working already');
				return;
			}
			this.working=1;
			this.w(`chat mode: ${m} turn: ${turn}`);
			let prompt=this.prompt.trim();
			let rag=this.config.rag.v;
			if(!turn) {
				turn=this.turn;
				this.w(`turn is not defined, getting current one: ${turn}`);
				if(this.turnRole(turn)==='user') {
					this.w('we are at the user turn, so let us check if it is a side message or not');
					if(!this.msgSide(...this.tbma(turn))) {
						this.w("it's not a side message and the current turn belongs to a user, can't send two user turns in line");
						alert("You can not reply to your own message");
						this.working=0;
						return;
					} else if(this.turnNotLast(turn)) {
						this.w(`it's not the last turn, let's convert this to a side message request`);
						this.chatUserSide(turn,prompt);
					}
				} else {
					this.w("it's a reply to AI turn, let's see if we need to make it a side message or a first one");
					if(this.turnNotLast(turn)) {
						this.w(`it's not the last turn, let's convert this to a side message request`);
						this.turn=turn=turn+1;
						this.chatUserSide(turn,prompt);
					}
				}
			}
			let ms=[];
			const side=this.msgSide(...this.tbma(turn));
			this.w(`chat at turn ${turn}`);
			const uid=this.userS("u"),aid=this.userS("a");
			this.w(`reply by user ${uid} (${this.nicks[uid].n})`);
			let tbm=[];
			
			if(m===1) {
				this.w('user is sending new msg');
				if(side) {
					this.w(`it's a user side message, turn--`);
					turn--;
				} else {
					this.w("create a next turn/branch");
					this.turnnew(turn,uid,this.group);
				}
				
				turn++;
				let b=this.brancha(turn);
				//empty message was already created with the branch creation, 
				//either at new turn creation or with the parent side message creation.
				b.msgs[b.msg]=this.msgTmpl(uid,prompt,this.group); 
				this.msgaStatusSet(turn,'done');
				this.prompt='';
				this.turnnew(turn,aid,this.group);
				tbm=this.tbma(turn+1);
				ms=await this.chatForAi(turn,this.config.rooms.v,aid,0,rag);
				turn++;
			} else if (m===2||m===3) {
				this.w('user is asking for a new side message');
				this.prompt='';
				if(this.turnRole(turn)==='user') {
					this.chatUserSide(turn,null);
					this.working=0;
					return;
				} else {
					this.msgNew(turn,aid,uid,null,this.group);
					this.branchu(turn);
					tbm=this.tbma(turn);
					this.w(`user is asking for a new ai message, mode=${m}`);
					const redo=m===3?1:0
					ms=await this.chatForAi(turn-1,this.config.rooms.v,aid,redo,rag);
				}
			}
			
			if(aw) {
				await this.chatSend(this.msgGet(...tbm),ms,null,null);
				this.w('finished waiting for chatsend');
			} else {
				this.chatSend(this.msgGet(...tbm),ms,null,null);
				this.w('not waiting for chatsend');
			}
			this.working=0;
			if(!this.opt.run) this.scroll(null,0);
			
			return tbm;
		},
		async chatSend(m,msgs,func,d) {
			let opt						=this.chatOptions();
			opt['messages']		=msgs;
			opt['stream']			=this.stream;
			this.w({body:opt});
			this.msgStatusSetDo(m,'waiting');
			const t=this;
			let res='',buf='',r=''; m.content='';
			try {
				r=await fetch(t.url()+"/api/chat",{
					"method": "POST",
					"body": 	JSON.stringify(opt)
				});
				if(!r.ok) throw new Error(r.statusText);
			} catch(err) {
				t.w(`error: ${err}`);
				t.connectionErr=`${err}`; //weird but lol
				t.connection=0;
				t.cancel		=0;
				m.content=`${err}`;
				t.msgStatusSetDo(m,'error');
				return;
			};

			const reader	=r.body.getReader();
			const decoder	=new TextDecoder('utf-8');
			const rrtp		=new RegExp(`${t.rgEsc(t.chatRatingMod(1,''))}`,'g');
			const rrtm		=new RegExp(`${t.rgEsc(t.chatRatingMod(0,''))}`,'g');
			const rn			=new RegExp('^\\s*(?:as )?'+t.rgEsc(m.nick)+':[\\s\\r\\n]*','gim');
			const remoji	=new RegExp('[\\p{Extended_Pictographic}\\p{Emoji_Modifier_Base}\\p{Emoji_Presentation}]*','gum');

			main: while(true) {
				const {done,value}=await reader.read();
				t.w('dissecting response');
				
				if(done) {
					m.content+=buf;
					t.w({'Stream complete':res});
					//there is a bug when ollama might not send anything for prompt_eval_count
					if(res.hasOwnProperty('eval_count')) m.tr[t.models[t.settings.req.model.v.v].n]=res.eval_count;
					if(res.hasOwnProperty('prompt_eval_count')) m.tp[t.models[t.settings.req.model.v.v].n]=res.prompt_eval_count;
					t.msgStatusSetDo(m,'done');
					t.cancel=0;
					break;
				}
				
				if(t.cancel) {
					t.w('cancelling');
					m.content+=buf;
					t.msgStatusSetDo(m,'cancel');
					reader.cancel();
					reader.releaseLock();
					break;
				}

				//careful here, if there is some proxy halving stream, it may break :)
				const chnks=decoder.decode(value).trim().split('\n');
				//t.w({cnks:chnks})
			
				for (const ch of chnks) {
					try { res=JSON.parse(ch) } catch (error) {
						t.w({'error':error,data:ch});
						t.connectionErr=`${error}`; //weird but lol
						t.connection=0;
						m.content+=error;
						t.msgStatusSetDo(m,'error');
						break main;
					}
					buf+=res.message.content;
					//t.w(`${buf} ${rn}`)
					buf=buf.replace(rrtp,'').replace(rrtm,'').replace(rn,'');
					if(t.config.emojiNo.v) buf=buf.replace(remoji,'');
					m.trm++;
					if(m.status==0) {
						if(t.config.resClean.v) {
							if(buf.length<t.config.resBufCleanSize.v) {//>
								t.w(`accumulating buffer at start ${buf}`);
								//return reader.read().then(processText);
								continue;
							}
						}
						t.msgStatusSetDo(m,'loading');
					}
					m.content+=buf;
					if(func!=null) {
						func(m.content,d);
					}
					buf='';
				}
				//return await reader.read().then(processText);
			}

			t.cancel=0;
			t.w(`chat received`);
			if(t.config.resClean.v) {
				m.content=m.content.trim().replace(rrtp,'').replace(rrtm,'').replace(rn,'');
			}
			if(t.config.emojiNo.v) buf=buf.replace(remoji,'');
			//t.working=0;
		},
		async chatForAi(turn,rooms,u,redo,rag) {
			let ms=[],add=[],sh=this.shuffle();

			this.w(`building list of chat for ai ${u} ${this.nicks[u].n}, up to ${turn}`);

			let adds={
				sys:'',
				rag:[],
				instr:'',
				nredo:[],
				predo:[],
				wRating:''
			};

			if(this.imgs.length) {
				this.w(`The prompt has ${this.imgs.length} images, let's add.`);
				this.msga(turn).images=[];
				for(const img of this.imgs) {
					this.msga(turn).images.push({c:img,s:0});
				}
				this.imgs=[];
			} else { this.w(`no images in the prompt`) }
			
			let final=[];
			for(let i=1;i<=turn;i++) { //>
				if(this.msga(i).content===''&&rooms) {
					this.w(`skipping empty msg #${i} from ${this.nicks[this.msga(i).nId].n}`);
					continue;
				}
				const tmp=this.chatAiTurn2Ms(turn,i,u);
				if(tmp) final.push(tmp);
			}
			const finalTurn=final.length-1;
			
			this.w(`We got ${finalTurn+1} chat log messages, now let's process additional parts`);
			
			adds['sys']=this.nicks[u].system??'';

			if(this.config.replyWithRating.v) {
				this.w('Reply with rating is enabled in config');
				let ratingUsed=0;
				for(let i=1;i<=turn;i++) { //>
					if(this.config.stories.v&&!this.msga(i).nicks[u]) continue;
					const rating=this.msga(i).rating;
					//this.w(`checking rating ${rating}`);
					if(rating!=null&&rating!=='') {
						this.w(`found a set rating ${rating}`)
						ratingUsed++;
						break;
					}
				}
				if(ratingUsed) {
					this.w('rating is used, modyfying the system prompt');
					adds.wRating=1;
				} else {
					this.w("rating is enabled but not used, skipping adding the task for AI");
				}
			} else { this.w(`Rating is disabled in config`) }
			
			this.rag[u].last=[];
			this.rag['g'].last=[];
			if(rag) {
				this.w("rag is enabled");
				if(!this.settings.req.modelEmb.v.l.length) {
					alert("You have enabled memories (rag) feature but you've not downloaded any models for embeddings. Please pull at least one embedding model, like 'nomic-embed-text' or anything else with 'embed' in its name. Also, don't forget to run a second instance of Ollama on a different port and to configure 'Embeddings URL' in settings by pointing it to that URL. This way your prompts will not slow down when you use 'memories'. I will switch off your rag setting for now, to prevent showing you this message next time. Enjoy.");
					this.configGlobal.rag.v=false;
					for(const nick in this.nicks) {
						if(!this.nicks[nick].hasOwnProperty('settings')) continue;
						this.nicks[nick].config.rag.v=false;
					}
				} else {
					this.w(`searching in rag for prompt: ${this.msga(turn).content}`);
					let ragp=1;
					if(!/^(\d{1,14})$/.test(this.config.ragPast.v)) {
						this.config.ragPast.v=this.config.ragPast.def;
						alert(`You have a bad configured value for the ${this.config.ragPast.name} parameter, resetted it to: ${this.config.ragPast.v}`);
					}
					ragp=this.config.ragPast.v;
					this.w(`rag past messages to use: ${ragp}`);
					let rags=[];
					if(ragp>0) {
						for(let i=finalTurn;i>=0;i--) {
							rags.push(final[i].content);
							ragp--;
							if(ragp==0) break;
						}
					}
					this.w({'rag search content':rags});
					
					if((this.rag['g'].t.length+this.rag[u].t.length)==0) {
						this.w('global and user rags are empty, skipping rag');
					} else if(rags.length==0) {
						this.w('rag prompt is empty, skipping rag');
					} else {
						let e=await this.embed(`please find top related content to: """${rags.join("\n")}"""`); //
						if(!e.length) {
							alert("You have enabled memories (rag) feature but the embedding url returns an error. Please fix the issue and re-enabled rag. For now the rag is going to be disabled.");
							this.configGlobal.rag.v=false;
						} else {
							const memb=this.settings.req.modelEmb.v.l[this.settings.req.modelEmb.v.v].tag;
							let rv={g:[]}; rv[u]=[];
							let ra	={};
							let min ='';
							if(/^\d{1,14}(:?\.\d{1,14})?$/.test(this.config.ragMinSmlr.v)) {
								min=this.config.ragMinSmlr.v;
							} else if(this.config.ragMinSmlr.v!==''&&this.config.ragMinSmlr.v!=null) {
								alert("You have a wrong value for 'Minimum required similarity value', ignoring it");
							}
							this.w(`lowest similarity configured is: ${min}`);
							
							ra[u]		=/^\d{1,14}$/.test(this.config.ragUAmount.v)?this.config.ragUAmount.v:2;
							ra['g']	=/^\d{1,14}$/.test(this.config.ragGAmount.v)?this.config.ragGAmount.v:2;
							for(const r of ['g',u]) {
								if(memb!=this.rag[r].modelEmb) {
									this.w(`embedding model has changed from ${this.rag[r].modelEmb} -> ${memb}, let's re-evaluate rag`);
									this.rag[r].v=[];
									await this.ragU(r);
								}
								for(let i=0;i<this.rag[r].v.length;i++) { //>
									const R=this.rag[r].v[i];
									const cos=this.cosine(R[0],e[0]);
									this.w(`got cos=${cos} for ${e[1]}=${R[1]}`);
									if(min!==''&&cos<min) { //>
										this.w(`Similarity is lower than defined ${cos}<${this.config.ragMinSmlr.v}`); //>
										continue;
									}
									rv[r].push({i:i,cos:cos});
								}
								this.w({rv:rv});
								if(rv[r].length) {
									const upto=rv[r].length>ra[r]?ra[r]:rv[r].length;
									this.w(`rag amount: ${ra[r]}, rag upto: ${upto}`);
									rv[r]=rv[r].sort((a,b)=>(a.cos>b.cos?-1:1)).slice(0,upto);
									this.w({ragtouse:rv[r]});
									if(this.config.ragShuffle.v) {
										this.w('shuffling the rag results as requested in config');
										rv[r]=sh(rv[r],upto);
									} else {
										this.w('shuffling is disabled, using rag as is');
									}
									for(const R of rv[r]) {
										this.rag[r].last.push({
											t:this.rag[r].v[R.i][1],id:R.i,
											cos:R.cos
										});
										adds.rag.push(this.rag[r].v[R.i][1]);
									}
								}
								this.w({'rag last of user':r,is:this.rag[r].last});
							}
						}
					}
				}
			} else { this.w(`memories are disabled in config`) }

			if(this.nicks[u].instr.length) {
				this.w(`we have instr text, let's see if we should add it: redo=${redo}, allow instr with side-rating:${this.config.instrWithSideRating.v}`);
				if(
							(redo&&this.config.instrWithSideRating.v)
						||(!redo)
				) {
					this.w(`got instr`);
					adds.instr=this.nicks[u].instr;
				} else {
					this.w(`instr is not appliable`);
				}
			} else { this.w('instr is empty') }
			
			if(redo) {
				this.w("processing redo");
				let good=[],bad=[];

				for(const m of this.msgsa(turn+1)) { //>
					if(this.config.stories.v&&!m.nicks[u]) continue;
					if(m.nId!=u) continue;
					if			(m.rating==1) { good.push(m.content) }
					else if	(m.rating==0) { bad.push(m.content)  }
				}
				
				let exQ=this.config.badExForSideReply.v
				if(bad.length&&exQ>0) {
					for(const i of sh(bad,exQ)) {
						adds.nredo.push(this.chatAiMsTmpl(i,'assistant',this.nicks[u].n,0,null).content);
					} 
				}
				
				exQ=this.config.goodExForSideReply.v;
				if(good.length&&exQ>0) {
					for(const i of sh(good,exQ)) {
						adds.predo.push(this.chatAiMsTmpl(i,'assistant',this.nicks[u].n,1,null).content);
					}
				}
				this.w("finished taking redos");
			} else { this.w(`redo is disabled in config`) }
			
			this.w({adds:adds});
			this.w('starting templating the adds');
			
			let msgs={u:[],s:[]};
			if(adds.rag.length) {
				msgs.u.push(`(in my mind i search for something relevant: """${adds.rag.join('\n')}""")`);
			}
			if(adds.nredo.length) {
				msgs.u.push(
					`in my reply i shall avoid messages like these: ${
							adds.nredo.map(arr=>'"""'+arr+'"""').join(', ')
					}`
				);
			}
			if(adds.predo.length) {
				msgs.u.push(`Here are ready reply ideas in my head, i'll improvise keeping their logic, style and mood: ${adds.predo.map(arr=>'"""'+arr+'"""').join(", ")}`);
			}
			if(adds.instr.length) {
				msgs.u.push(`Main thing on my mind: """${adds.instr}"""`);
			}
			if(adds.wRating==1) {
				msgs.s.push(`Task: Messages with ${this.chatRatingMod(0,'')} are bad, imitate ${this.chatRatingMod(1,'')} messages in style, size, manner. Do not use ${this.chatRatingMod(1,'')} and ${this.chatRatingMod(0,'')} in your own messages. `);
			}
			if(finalTurn>=0) {
				//as ${this.nicks[u].n} 
				msgs.s.push(`Now, react to """${final[finalTurn].content}""", 1 in-character reaction only`);
			}
			if(msgs.u.length) {
				this.chatAiAdd(add,u,msgs.u.join("\n"),null);
			}
			if(msgs.s.length) {
				if(!msgs.u.length) this.chatAiAdd(add,u,"\n",null);
				this.chatAiAdd(add,this.nick['s'],msgs.s.join("\n"),null);
			}
			
			this.w({'templated adds are':add});
			
			for(const i of add) {
				final.push(this.chatAiMsTmpl(i.content,i.role,i.nick,i.rating,null));
			}
			
			this.w(`added adds, now ${final.length} messages`);
			this.w({final:final});
			
			if(adds.sys.length) {
				//adds.wRating
				this.chatAiMsPush(ms,adds.sys,'system');
			}
			
			if(rooms) {
				this.w("room mode, let's concatenate everything");
				let imgs=[];
				for(const i of final) {
					if(!i.images||!i.images.length) continue;
					imgs.push(...i.images);
				}
				this.chatAiMsPush(ms,final.map(arr=>arr.content).join('\n\n'),'user',imgs);
			} else {
				this.w("chat mode, let's add everything as messages");
				for(const i of final) {
					this.chatAiMsPush(ms,i.content,i.role,i.images);
				}
			}
			
			this.w({'final msgs':ms});
			return ms;
		},
		chatAiMsPush(ms,c,r,i) {
			ms.push({ content:c,role:r });
			if(i&&i.length) ms[ms.length-1].images=i;
		},
		chatAiAdd(a,n,c,rt) {
			a.push(this.msgTmpl(n,c,null));
			//hack for chat style messages which needs role, making it look like it's user msg
			if(this.nicks[n].t==='u') {
				a[a.length-1]['role']='user';
			} else if(this.nicks[n].t==='a') {
				a[a.length-1]['role']='assistant';
			} else if(this.nicks[n].t==='s') {
				a[a.length-1]['role']='user';
			}
			a[a.length-1]['rating']=rt;
		},
		chatAiTurn2Ms(t,i,u) {
			const m		=this.msga(i);
			if(this.config.stories.v&&!m.nicks[u]) return;
			const tmp	=this.turns[i];
			let role;
			if(this.turnRole(i)==='assistant'&&this.config.otherAiAsUser.v&&m.nId!=u) {
				this.w(`overriding role of ${u}!=${m.nId} ${m.nick} to make it user`);
				role='user';
			} else {
				role=tmp.role;
			}
			let img;
			if(!this.config.imgsLastOnly.v||i==t) img=m.images;

			const msg=this.chatAiMsTmpl(
				m.content,
				role,
				m.nick,
				m.rating,
				img
			);
			return msg
		},
		chatAiMsTmpl(c,r,n,rt,i) {
			let tmp={
				'content':	(c.length?c:'continue'),
				'role':			r,
				'nick':			n,
				'rating':		rt,
			};
			if(this.config.replyWithRating.v) {
				tmp.content=this.chatRatingMod(rt,`${tmp.nick}: ${tmp.content}`)
			} else {
				tmp.content=`${tmp.nick}: ${tmp.content}`
			}
			if(i!=null&&i.length) {
				tmp.images=[];
				for(const img of i) {
					tmp.images.push(img.c);
				}
			}
			return tmp;
		},
		chatRatingMod(rt,s) {
			let tmp='';
			if(rt==1) {
				tmp='((+))';
			} else if(rt===0) {
				tmp='((-))'
			}
			return `${tmp}${s}`;
		},
		chatUserSide(turn,c) {
			let b=this.brancha(turn);
			this.msgNew(turn,this.userS("u"),this.userS("a"),(c??''),this.group); //contents needs to be inited
			b.msgs[b.msg]['side']=1;
			this.msgaStatusSet(turn,'waiting');
			this.w(`user is asking for a new own message at ${turn}`);
			turn=this.turn=turn-1;
			this.branchu(turn);
			this.w(`resetting turn to ${this.turn}`);
		},
		chatOptions() {
			const opt=this.chatOpt2hash(0);
			opt['options']=this.chatOpt2hash(1);
			return opt;
		},
		chatOpt2hash(m) {
			let opt={};
			const sets=m==1?this.settings.options:this.settings.req;
			for(const i in sets) {
				if(i=='modelEmb') continue; //dirty hack :)
				this.w(`processing settings param ${i}=${sets[i].v}`);
				if(!(sets[i].v+'').length) continue;
				this.w(`${i}=${sets[i].v}`)
				if(sets[i].t==='n') {
					opt[i]=sets[i].v*1;
				} else if(sets[i].t==='as') {
					opt[i]=[];
					for(const j of sets[i].v) {
						if(j==='') continue;
						opt[i].push(j+'');
					}
				} else if(sets[i].t==='sel') {
					opt[i]=sets[i].v.l[sets[i].v.v].tag;
				} else {
					opt[i]=sets[i].v+'';
				}
			}
			return opt;
		},
		rgEsc(string) {
			return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
		},

		//connection url stuff
		url() {
			return this.config.url.v;
		},
		urlTest(url) {
			if(this.working) {
				this.w('working right now, leaving');
				return;
			}
			
			this.connectionErr='';
			this.connection		=0;
			this.working			=1;
			
			this.w(`taking url`);
			if(!url) url=this.url();
			if(!url) {
				this.w(`no good address`);
				this.connectionErr='No good url found';
				this.working=0;
				return;
			}
			this.connectionErr='';

			fetch(url+"/api/tags",{
				"method": "GET",
			}).then(r=>{
				if(!r.ok) throw new Error(r.statusText);
				return r;
			}).then((r)=>{
				this.working=0;
				this.connectionErr=''
				this.w(`connection established, running models listing`);
				this.list();
				return 1;
			}).catch((error)=>{
				this.connectionErr=error.message;
				console.error(`network error ${error.message}`);
				this.working=0;
			});
		},
	}
})

app.component(
	'css',{
		template: '#tmplCss'
	}).component('nick',{
		template: '#tmplNick',
		props: ['id','name'],
	}).component('menun', {
		template: '#tmplMenuN',
		props: ['k','t'],
		inject: ['config']
	}).component('fields', {
		template: '#tmplField',
		props: ['i','n','nShow','id'],
		methods: {
			loadFile(n) {
				this.$root.loadFile(n);
			}
		},
	}).component('nickadd', {
		template: '#tmplNickAdd',
		props: ['t','group','nicks','groups','amountNicks'],
		computed: {
			ut() {
				return (this.t==="u"?"user":"ai");
			},
			uListAvail() {
				return this.msgUserListAvail({nicks:this.groups[this.group].u},this.t,0);
			},
		},
		data() {
			return {
				userGroupAddId:null,
				userNickA: '',
			}
		},
		watch: {
			'uListAvail'(v) {
				if(!this.uListAvail.length) return 0;
				this.userGroupAddId=this.uListAvail[0];
			}
		},
		methods: {
			sel(i) {
				this.userGroupAddId=i;
				return false;
			},
			userAdd() {
				this.$root.userAdd(this.t,this.userNickA);
				this.$root.userGroupAdd(this.group,this.amountNicks.idNext-1);
				this.userNickA='';
			},
			userGroupAdd() {
				this.$root.userGroupAdd(this.group,this.userGroupAddId)
				this.userGroupAddId=null;
			},
			msgUserListAvail(msg,t,g) {
				return this.$root.msgUserListAvail(msg,t,g);
			},
			pToggle(id) {
				this.$root.pToggle(id);
			},
		},
	}).component('heardBy', {
		template: '#tmplHeardBy',
		props: ['u','nicks','groups','group','config'],
		computed: {
			users() {
				//yes, i don't want to write that idiotic hash to array thing :).
				let arr=[[],[]];
				const g=this.groups[this.group].u[this.u];
				for(const i in g) { if(this.nicks[i].t==='u') arr[0].push(i) }
				for(const i in g) { if(this.nicks[i].t==='a') arr[1].push(i) }
				return [
					...arr[0].sort((a,b)=>(this.nicks[a].n.localeCompare(this.nicks[b].n))),
					...arr[1].sort((a,b)=>(this.nicks[a].n.localeCompare(this.nicks[b].n)))
				];
			}
		}
	}).component('talkers', {
		template: '#tmplTalkers',
		props: ['nicks','t','groups','group','config'],
		methods: {
			userS(t) {
				return this.$root.userS(t);
			},
			userVis(id) {
				return this.$root.userVis(this.t,id);
			},
			groupNext() {
				this.$root.groupNext();
			},
			groupPrev() {
				this.$root.groupPrev();
			},
			userCh() {
				this.$root.userCh(this.t);
			},
			send(e,m,aw,id) {
				if(this.t!='a') return;
				this.groups[this.group]["sel"][this.t]=id;
				this.$root.send(e,m,aw)
			}
		}
	}).component('userList', {
		template: '#tmplUserList',
		props: ['nicks','t','groups','group'],
		methods: {
			userVis(id) {
				return this.$root.userVis(this.t,id);
			},
			userGroupDel(id) {
				this.$root.userGroupDel(this.group,id);
			},
			userDel(id) {
				this.$root.userDel(id);
			},
			userTypeCh(id) {
				this.$root.userTypeCh(id);
			},
		}
	}).component('help', {
		template: '#tmplHelp',
	}).component('opt', {
		template: '#tmplOpt',
		props: ['config','settings','opt','pState','branch'],
		data() {
			return {
				
			}
		},
		methods: {
			optimizeRun() {
				this.$root.optimizeRun();
			},
			optimizeCancel() {
				this.$root.optimizeCancel();
			},
			optChUse(m,k) {
				this.$root.optChUse(m,k);
			},
			pToggle(id,v) {
				this.$root.pToggle(id,v);
			},
			optResSave() {
				this.$root.optResSave();
			}
		}
	}).component('optRes',{
		template: '#tmplOptRes',
		props: ['m','i']
	}).component('optResValsLine',{
		template: '#tmplOptResValsLine',
		props: ['m','mid','vals']
	}).component('optResValsHeader',{
		template: '#tmplOptResValsHeader',
		props: ['m']
	}).component('ragErr',{
		template: '#tmplRagErr',
		props: ['rag']
	}).component('ragStatus',{
		template: '#tmplRagStatus',
		props: ['rag','id'],
	}).component('charNewParsedParams',{
		template: '#tmplCharNewParsedParams',
		props: ['char-new'],
		computed: {
			disabled() {
				return (this.charNew.working||this.charNew.stepShow>=2)?true:false;
			}
		},
		methods: {
			charNewParamsDel(id) {
				this.$root.charNewParamsDel(id);
			},
			charNewCoreParamCh(r) {
				this.$root.charNewCoreParamCh(r);
			}
		}
	}).component('charNewMemSets',{
		template: '#tmplCharNewMemSets',
		props: ['charNew'],
		methods: {
			memSetsDel(o,id) {
				this.$root.memSetsDel(o,id);
			}
		}
	}).component('charNewMemParsed',{
		template: '#tmplCharNewMemParsed',
		props: ['char-new'],
		methods: {
			memParsedDel(o,id) {
				this.$root.memParsedDel(o,id);
			}
		}
	}).component('charNewSystemEdit',{
		template: '#tmplCharNewSystemEdit',
		props: ['char-new','pState','id'],
		methods: {
			charNewSystemReset(o,id) {
				this.$root.charNewSystemReset(o,id);
			},
			charNewReqReset(o,id,rid) {
				this.$root.charNewReqReset(o,id,rid);
			},
			pToggleDo(id) {
				this.$root.pToggleDo(id)
			},
			charNewCoreParamCh(r) {
				this.$root.charNewCoreParamCh(r);
			}
		}
	});

window.ap=app.mount('#app');

</script>
</body>
</html>
